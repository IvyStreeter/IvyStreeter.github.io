<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>5.2 Statistical Inference: | Perpetually trying to remember what I forgot</title>
  <meta name="description" content="5.2 Statistical Inference: | Perpetually trying to remember what I forgot" />
  <meta name="generator" content="bookdown 0.43 and GitBook 2.6.7" />

  <meta property="og:title" content="5.2 Statistical Inference: | Perpetually trying to remember what I forgot" />
  <meta property="og:type" content="book" />
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="5.2 Statistical Inference: | Perpetually trying to remember what I forgot" />
  
  
  




  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="setup.html"/>
<link rel="next" href="bayesian-statistics.html"/>
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.1.0/anchor-sections.css" rel="stylesheet" />
<link href="libs/anchor-sections-1.1.0/anchor-sections-hash.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.1.0/anchor-sections.js"></script>


<style type="text/css">
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<style type="text/css">
  
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="" data-path="ivys-digital-garden.html"><a href="ivys-digital-garden.html"><i class="fa fa-check"></i>Ivy’s Digital Garden</a></li>
<li class="chapter" data-level="1" data-path="journal-club.html"><a href="journal-club.html"><i class="fa fa-check"></i><b>1</b> Journal Club</a>
<ul>
<li class="chapter" data-level="1.1" data-path="ninj1-mediates-plasma-membrane-rupture-during-lytic-cell-death.html"><a href="ninj1-mediates-plasma-membrane-rupture-during-lytic-cell-death.html"><i class="fa fa-check"></i><b>1.1</b> NINJ1 mediates plasma membrane rupture during lytic cell death</a></li>
<li class="chapter" data-level="1.2" data-path="adoptive-cellular-therapy-with-t-cells-expressing-the-dendritic-cell-growth-factor-flt3l-drives-epitope-spreading-and-antitumor-immunity.html"><a href="adoptive-cellular-therapy-with-t-cells-expressing-the-dendritic-cell-growth-factor-flt3l-drives-epitope-spreading-and-antitumor-immunity.html"><i class="fa fa-check"></i><b>1.2</b> Adoptive cellular therapy with T cells expressing the dendritic cell growth factor Flt3L drives epitope spreading and antitumor immunity</a></li>
<li class="chapter" data-level="1.3" data-path="structural-cells-are-key-regulators-of-organ-specific-immune-responses.html"><a href="structural-cells-are-key-regulators-of-organ-specific-immune-responses.html"><i class="fa fa-check"></i><b>1.3</b> Structural cells are key regulators of organ-specific immune responses</a></li>
<li class="chapter" data-level="1.4" data-path="genome-wide-crisprcas9-screening-reveals-ubiquitous-t-cell-cancer-targeting-via-the-monomorphic-mhc-class-i-related-protein-mr1.html"><a href="genome-wide-crisprcas9-screening-reveals-ubiquitous-t-cell-cancer-targeting-via-the-monomorphic-mhc-class-i-related-protein-mr1.html"><i class="fa fa-check"></i><b>1.4</b> Genome-wide CRISPR–Cas9 screening reveals ubiquitous T cell cancer targeting via the monomorphic MHC class I-related protein MR1</a></li>
<li class="chapter" data-level="1.5" data-path="intratumoral-activity-of-the-cxcr3-chemokine-system-is-required-for-the-efficacy-of-anti-pd-1-therapy.html"><a href="intratumoral-activity-of-the-cxcr3-chemokine-system-is-required-for-the-efficacy-of-anti-pd-1-therapy.html"><i class="fa fa-check"></i><b>1.5</b> Intratumoral Activity of the CXCR3 Chemokine System Is Required for the Efficacy of Anti-PD-1 Therapy</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="immunology.html"><a href="immunology.html"><i class="fa fa-check"></i><b>2</b> Immunology</a></li>
<li class="chapter" data-level="3" data-path="protein-engineering.html"><a href="protein-engineering.html"><i class="fa fa-check"></i><b>3</b> Protein Engineering</a></li>
<li class="chapter" data-level="4" data-path="sequencing.html"><a href="sequencing.html"><i class="fa fa-check"></i><b>4</b> Sequencing</a></li>
<li class="chapter" data-level="5" data-path="data-science.html"><a href="data-science.html"><i class="fa fa-check"></i><b>5</b> Data Science</a>
<ul>
<li class="chapter" data-level="5.1" data-path="setup.html"><a href="setup.html"><i class="fa fa-check"></i><b>5.1</b> SetUp</a>
<ul>
<li class="chapter" data-level="" data-path="setup.html"><a href="setup.html#how-to-setup-vscode"><i class="fa fa-check"></i>How to setup VSCode</a></li>
<li class="chapter" data-level="" data-path="setup.html"><a href="setup.html#weird-behaviors"><i class="fa fa-check"></i>Weird behaviors:</a></li>
</ul></li>
<li class="chapter" data-level="5.2" data-path="statistical-inference.html"><a href="statistical-inference.html"><i class="fa fa-check"></i><b>5.2</b> Statistical Inference:</a>
<ul>
<li class="chapter" data-level="5.2.1" data-path="statistical-inference.html"><a href="statistical-inference.html#why-statistical-inference"><i class="fa fa-check"></i><b>5.2.1</b> Why Statistical Inference</a></li>
<li class="chapter" data-level="5.2.2" data-path="statistical-inference.html"><a href="statistical-inference.html#statistical-learning"><i class="fa fa-check"></i><b>5.2.2</b> Statistical Learning</a></li>
<li class="chapter" data-level="5.2.3" data-path="statistical-inference.html"><a href="statistical-inference.html#linear-regression"><i class="fa fa-check"></i><b>5.2.3</b> Linear Regression</a></li>
<li class="chapter" data-level="5.2.4" data-path="statistical-inference.html"><a href="statistical-inference.html#classification"><i class="fa fa-check"></i><b>5.2.4</b> Classification</a></li>
<li class="chapter" data-level="5.2.5" data-path="statistical-inference.html"><a href="statistical-inference.html#resampling-methods"><i class="fa fa-check"></i><b>5.2.5</b> Resampling Methods</a></li>
<li class="chapter" data-level="5.2.6" data-path="statistical-inference.html"><a href="statistical-inference.html#linear-model-selection-and-regularization"><i class="fa fa-check"></i><b>5.2.6</b> Linear Model Selection and Regularization</a></li>
<li class="chapter" data-level="5.2.7" data-path="statistical-inference.html"><a href="statistical-inference.html#moving-beyond-linearity"><i class="fa fa-check"></i><b>5.2.7</b> Moving Beyond linearity</a></li>
<li class="chapter" data-level="5.2.8" data-path="statistical-inference.html"><a href="statistical-inference.html#tree-based-methods"><i class="fa fa-check"></i><b>5.2.8</b> Tree-Based Methods</a>
<ul>
<li class="chapter" data-level="5.2.8.1" data-path="statistical-inference.html"><a href="statistical-inference.html#the-basics-of-decision-trees"><i class="fa fa-check"></i><b>5.2.8.1</b> The Basics of Decision Trees</a>
<ul>
<li class="chapter" data-level="5.2.8.1.1" data-path="statistical-inference.html"><a href="statistical-inference.html#regression-trees"><i class="fa fa-check"></i><b>5.2.8.1.1</b> Regression Trees</a></li>
<li class="chapter" data-level="5.2.8.1.2" data-path="statistical-inference.html"><a href="statistical-inference.html#prediction-via-strartification-of-the-feature-space"><i class="fa fa-check"></i><b>5.2.8.1.2</b> Prediction via Strartification of the Feature Space</a></li>
<li class="chapter" data-level="5.2.8.1.3" data-path="statistical-inference.html"><a href="statistical-inference.html#classification-trees"><i class="fa fa-check"></i><b>5.2.8.1.3</b> Classification Trees</a></li>
<li class="chapter" data-level="5.2.8.1.4" data-path="statistical-inference.html"><a href="statistical-inference.html#trees-versus-linear-models"><i class="fa fa-check"></i><b>5.2.8.1.4</b> Trees Versus Linear Models</a></li>
<li class="chapter" data-level="5.2.8.1.5" data-path="statistical-inference.html"><a href="statistical-inference.html#advantages-and-disadvantages-of-trees"><i class="fa fa-check"></i><b>5.2.8.1.5</b> Advantages and Disadvantages of Trees</a></li>
</ul></li>
<li class="chapter" data-level="5.2.8.2" data-path="statistical-inference.html"><a href="statistical-inference.html#bagging-random-forest-boosting"><i class="fa fa-check"></i><b>5.2.8.2</b> Bagging, Random Forest, Boosting</a>
<ul>
<li class="chapter" data-level="5.2.8.2.1" data-path="statistical-inference.html"><a href="statistical-inference.html#bagging"><i class="fa fa-check"></i><b>5.2.8.2.1</b> Bagging</a></li>
<li class="chapter" data-level="5.2.8.2.2" data-path="statistical-inference.html"><a href="statistical-inference.html#random-forest"><i class="fa fa-check"></i><b>5.2.8.2.2</b> Random Forest</a></li>
<li class="chapter" data-level="5.2.8.2.3" data-path="statistical-inference.html"><a href="statistical-inference.html#boosting"><i class="fa fa-check"></i><b>5.2.8.2.3</b> Boosting</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5.2.9" data-path="statistical-inference.html"><a href="statistical-inference.html#unsupervised-learning"><i class="fa fa-check"></i><b>5.2.9</b> Unsupervised learning</a>
<ul>
<li class="chapter" data-level="5.2.9.1" data-path="statistical-inference.html"><a href="statistical-inference.html#challenges-in-unsupervised-learning"><i class="fa fa-check"></i><b>5.2.9.1</b> Challenges in unsupervised learning</a></li>
<li class="chapter" data-level="5.2.9.2" data-path="statistical-inference.html"><a href="statistical-inference.html#principal-components-analysis-pca"><i class="fa fa-check"></i><b>5.2.9.2</b> Principal Components Analysis (PCA)</a>
<ul>
<li class="chapter" data-level="5.2.9.2.1" data-path="statistical-inference.html"><a href="statistical-inference.html#what-are-principal-components"><i class="fa fa-check"></i><b>5.2.9.2.1</b> What are principal components?</a></li>
<li class="chapter" data-level="5.2.9.2.2" data-path="statistical-inference.html"><a href="statistical-inference.html#another-interpretation-of-principle-components"><i class="fa fa-check"></i><b>5.2.9.2.2</b> Another interpretation of Principle Components</a></li>
<li class="chapter" data-level="5.2.9.2.3" data-path="statistical-inference.html"><a href="statistical-inference.html#the-proportion-of-variance-explained-pve-in-pca"><i class="fa fa-check"></i><b>5.2.9.2.3</b> The Proportion of Variance Explained (PVE) in PCA</a></li>
<li class="chapter" data-level="5.2.9.2.4" data-path="statistical-inference.html"><a href="statistical-inference.html#uniqueness-of-the-principal-components"><i class="fa fa-check"></i><b>5.2.9.2.4</b> Uniqueness of the Principal Components</a></li>
<li class="chapter" data-level="5.2.9.2.5" data-path="statistical-inference.html"><a href="statistical-inference.html#deciding-how-many-principal-components-to-use"><i class="fa fa-check"></i><b>5.2.9.2.5</b> Deciding How Many Principal Components to Use</a></li>
<li class="chapter" data-level="5.2.9.2.6" data-path="statistical-inference.html"><a href="statistical-inference.html#other-uses-for-principal-components"><i class="fa fa-check"></i><b>5.2.9.2.6</b> Other uses for principal components</a></li>
</ul></li>
<li class="chapter" data-level="5.2.9.3" data-path="statistical-inference.html"><a href="statistical-inference.html#clustering-methods"><i class="fa fa-check"></i><b>5.2.9.3</b> Clustering methods</a>
<ul>
<li class="chapter" data-level="5.2.9.3.1" data-path="statistical-inference.html"><a href="statistical-inference.html#k-means-clustering"><i class="fa fa-check"></i><b>5.2.9.3.1</b> K-means clustering</a></li>
<li class="chapter" data-level="5.2.9.3.2" data-path="statistical-inference.html"><a href="statistical-inference.html#hierarchial-clustering"><i class="fa fa-check"></i><b>5.2.9.3.2</b> Hierarchial clustering</a></li>
<li class="chapter" data-level="5.2.9.3.3" data-path="statistical-inference.html"><a href="statistical-inference.html#practical-issues-in-clustering"><i class="fa fa-check"></i><b>5.2.9.3.3</b> Practical Issues in Clustering</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5.2.10" data-path="statistical-inference.html"><a href="statistical-inference.html#support-vector-machines"><i class="fa fa-check"></i><b>5.2.10</b> Support Vector Machines</a>
<ul>
<li class="chapter" data-level="5.2.10.1" data-path="statistical-inference.html"><a href="statistical-inference.html#maximal-margin-classifier"><i class="fa fa-check"></i><b>5.2.10.1</b> Maximal Margin Classifier</a>
<ul>
<li class="chapter" data-level="5.2.10.1.1" data-path="statistical-inference.html"><a href="statistical-inference.html#what-is-a-hyperplane"><i class="fa fa-check"></i><b>5.2.10.1.1</b> What is a hyperplane?</a></li>
<li class="chapter" data-level="5.2.10.1.2" data-path="statistical-inference.html"><a href="statistical-inference.html#classification-using-a-seperating-hyperplane"><i class="fa fa-check"></i><b>5.2.10.1.2</b> Classification Using a Seperating hyperplane</a></li>
<li class="chapter" data-level="5.2.10.1.3" data-path="statistical-inference.html"><a href="statistical-inference.html#maximal-margin-classifier-1"><i class="fa fa-check"></i><b>5.2.10.1.3</b> Maximal Margin Classifier</a></li>
<li class="chapter" data-level="5.2.10.1.4" data-path="statistical-inference.html"><a href="statistical-inference.html#construction-of-the-maximal-margin-classifier"><i class="fa fa-check"></i><b>5.2.10.1.4</b> Construction of the Maximal Margin Classifier</a></li>
<li class="chapter" data-level="5.2.10.1.5" data-path="statistical-inference.html"><a href="statistical-inference.html#the-non-separable-case"><i class="fa fa-check"></i><b>5.2.10.1.5</b> The Non-separable Case</a></li>
</ul></li>
<li class="chapter" data-level="5.2.10.2" data-path="statistical-inference.html"><a href="statistical-inference.html#support-vector-classifiers"><i class="fa fa-check"></i><b>5.2.10.2</b> Support Vector Classifiers</a>
<ul>
<li class="chapter" data-level="5.2.10.2.1" data-path="statistical-inference.html"><a href="statistical-inference.html#overview-of-the-support-vector-classifier"><i class="fa fa-check"></i><b>5.2.10.2.1</b> Overview of the Support Vector Classifier</a></li>
<li class="chapter" data-level="5.2.10.2.2" data-path="statistical-inference.html"><a href="statistical-inference.html#details-of-the-support-vector-classifier"><i class="fa fa-check"></i><b>5.2.10.2.2</b> Details of the Support Vector Classifier</a></li>
</ul></li>
<li class="chapter" data-level="5.2.10.3" data-path="statistical-inference.html"><a href="statistical-inference.html#support-vector-machines-1"><i class="fa fa-check"></i><b>5.2.10.3</b> Support Vector Machines</a>
<ul>
<li class="chapter" data-level="5.2.10.3.1" data-path="statistical-inference.html"><a href="statistical-inference.html#classification-with-non-linerar-decision-boundaries"><i class="fa fa-check"></i><b>5.2.10.3.1</b> Classification with Non-Linerar Decision Boundaries</a></li>
<li class="chapter" data-level="5.2.10.3.2" data-path="statistical-inference.html"><a href="statistical-inference.html#the-supoort-vector-machines"><i class="fa fa-check"></i><b>5.2.10.3.2</b> The Supoort Vector Machines</a></li>
<li class="chapter" data-level="5.2.10.3.3" data-path="statistical-inference.html"><a href="statistical-inference.html#an-application-to-the-heart-disease-data"><i class="fa fa-check"></i><b>5.2.10.3.3</b> An Application to the Heart Disease Data</a></li>
</ul></li>
<li class="chapter" data-level="5.2.10.4" data-path="statistical-inference.html"><a href="statistical-inference.html#svm-with-more-than-two-classes"><i class="fa fa-check"></i><b>5.2.10.4</b> SVM with More than Two classes</a>
<ul>
<li class="chapter" data-level="5.2.10.4.1" data-path="statistical-inference.html"><a href="statistical-inference.html#one-versus-one-classification"><i class="fa fa-check"></i><b>5.2.10.4.1</b> One-Versus-One Classification</a></li>
<li class="chapter" data-level="5.2.10.4.2" data-path="statistical-inference.html"><a href="statistical-inference.html#one-versus-all-classification"><i class="fa fa-check"></i><b>5.2.10.4.2</b> One-Versus-All Classification</a></li>
</ul></li>
<li class="chapter" data-level="5.2.10.5" data-path="statistical-inference.html"><a href="statistical-inference.html#relationship-to-logistic-regression"><i class="fa fa-check"></i><b>5.2.10.5</b> Relationship to Logistic Regression</a></li>
</ul></li>
<li class="chapter" data-level="5.2.11" data-path="statistical-inference.html"><a href="statistical-inference.html#deep-learning"><i class="fa fa-check"></i><b>5.2.11</b> Deep Learning</a>
<ul>
<li class="chapter" data-level="5.2.11.1" data-path="statistical-inference.html"><a href="statistical-inference.html#single-layer-neural-network"><i class="fa fa-check"></i><b>5.2.11.1</b> Single Layer Neural Network</a></li>
<li class="chapter" data-level="5.2.11.2" data-path="statistical-inference.html"><a href="statistical-inference.html#multilayer-neural-networks"><i class="fa fa-check"></i><b>5.2.11.2</b> Multilayer Neural networks</a></li>
<li class="chapter" data-level="5.2.11.3" data-path="statistical-inference.html"><a href="statistical-inference.html#convolution-neural-networks"><i class="fa fa-check"></i><b>5.2.11.3</b> Convolution Neural Networks</a>
<ul>
<li class="chapter" data-level="5.2.11.3.1" data-path="statistical-inference.html"><a href="statistical-inference.html#convolution-layer"><i class="fa fa-check"></i><b>5.2.11.3.1</b> Convolution Layer</a></li>
<li class="chapter" data-level="5.2.11.3.2" data-path="statistical-inference.html"><a href="statistical-inference.html#pooling-layers"><i class="fa fa-check"></i><b>5.2.11.3.2</b> Pooling layers</a></li>
<li class="chapter" data-level="5.2.11.3.3" data-path="statistical-inference.html"><a href="statistical-inference.html#architecture-of-a-convolution-neural-network"><i class="fa fa-check"></i><b>5.2.11.3.3</b> Architecture of a convolution neural network</a></li>
<li class="chapter" data-level="5.2.11.3.4" data-path="statistical-inference.html"><a href="statistical-inference.html#data-augmentation"><i class="fa fa-check"></i><b>5.2.11.3.4</b> Data Augmentation</a></li>
<li class="chapter" data-level="5.2.11.3.5" data-path="statistical-inference.html"><a href="statistical-inference.html#results-using-a-pretrained-classifier"><i class="fa fa-check"></i><b>5.2.11.3.5</b> Results Using a Pretrained Classifier</a></li>
</ul></li>
<li class="chapter" data-level="5.2.11.4" data-path="statistical-inference.html"><a href="statistical-inference.html#document-classification"><i class="fa fa-check"></i><b>5.2.11.4</b> Document Classification</a>
<ul>
<li class="chapter" data-level="5.2.11.4.1" data-path="statistical-inference.html"><a href="statistical-inference.html#reccurent-neural-networks"><i class="fa fa-check"></i><b>5.2.11.4.1</b> Reccurent Neural networks</a></li>
</ul></li>
<li class="chapter" data-level="5.2.11.5" data-path="statistical-inference.html"><a href="statistical-inference.html#when-to-use-deep-learning"><i class="fa fa-check"></i><b>5.2.11.5</b> When to Use Deep Learning</a></li>
<li class="chapter" data-level="5.2.11.6" data-path="statistical-inference.html"><a href="statistical-inference.html#fitting-a-neural-network"><i class="fa fa-check"></i><b>5.2.11.6</b> Fitting a Neural Network</a>
<ul>
<li class="chapter" data-level="5.2.11.6.1" data-path="statistical-inference.html"><a href="statistical-inference.html#backpropagation"><i class="fa fa-check"></i><b>5.2.11.6.1</b> Backpropagation</a></li>
<li class="chapter" data-level="5.2.11.6.2" data-path="statistical-inference.html"><a href="statistical-inference.html#regulaization-and-stochastic-gradient-descent"><i class="fa fa-check"></i><b>5.2.11.6.2</b> Regulaization and Stochastic Gradient Descent</a></li>
<li class="chapter" data-level="5.2.11.6.3" data-path="statistical-inference.html"><a href="statistical-inference.html#dropout-learning"><i class="fa fa-check"></i><b>5.2.11.6.3</b> Dropout Learning</a></li>
<li class="chapter" data-level="5.2.11.6.4" data-path="statistical-inference.html"><a href="statistical-inference.html#network-tuning"><i class="fa fa-check"></i><b>5.2.11.6.4</b> Network Tuning</a></li>
</ul></li>
<li class="chapter" data-level="5.2.11.7" data-path="statistical-inference.html"><a href="statistical-inference.html#interpolation-and-double-descent"><i class="fa fa-check"></i><b>5.2.11.7</b> Interpolation and Double Descent</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5.3" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html"><i class="fa fa-check"></i><b>5.3</b> Bayesian Statistics:</a>
<ul>
<li class="chapter" data-level="5.3.1" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#properties-of-conditional-probability"><i class="fa fa-check"></i><b>5.3.1</b> Properties of Conditional Probability</a></li>
<li class="chapter" data-level="5.3.2" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#application-of-bayes-theorem-examples"><i class="fa fa-check"></i><b>5.3.2</b> Application of Bayes Theorem: Examples</a></li>
<li class="chapter" data-level="5.3.3" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#independence"><i class="fa fa-check"></i><b>5.3.3</b> Independence</a></li>
<li class="chapter" data-level="5.3.4" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#random-variables-joint-distributions-law-of-large-numbers-lln-central-limit-theorem-clt"><i class="fa fa-check"></i><b>5.3.4</b> Random Variables; Joint Distributions; Law of Large Numbers (LLN); Central Limit Theorem (CLT)</a></li>
<li class="chapter" data-level="5.3.5" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#common-probability-distributions-introduction-to-bayesian-inference-one-parameter-models"><i class="fa fa-check"></i><b>5.3.5</b> Common Probability Distributions; Introduction to Bayesian Inference; One-parameter Models</a></li>
<li class="chapter" data-level="5.3.6" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#exponential-family-frequentist-confidence-interval-bayesian-credible-interval"><i class="fa fa-check"></i><b>5.3.6</b> Exponential Family; Frequentist Confidence Interval; Bayesian (Credible) Interval</a></li>
<li class="chapter" data-level="5.3.7" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#sufficiency-rao-blackwell-theorem"><i class="fa fa-check"></i><b>5.3.7</b> Sufficiency; Rao-Blackwell Theorem;</a></li>
<li class="chapter" data-level="5.3.8" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#monte-carlo-approximation"><i class="fa fa-check"></i><b>5.3.8</b> Monte Carlo Approximation</a>
<ul>
<li class="chapter" data-level="5.3.8.1" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#monte-carlo-expectation"><i class="fa fa-check"></i><b>5.3.8.1</b> Monte Carlo Expectation</a></li>
<li class="chapter" data-level="5.3.8.2" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#additional-information-from-monte-carlo-approximation-other-than-estimating-parameters"><i class="fa fa-check"></i><b>5.3.8.2</b> Additional information from Monte Carlo approximation, other than estimating parameters</a></li>
<li class="chapter" data-level="5.3.8.3" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#understanding-discrepencies"><i class="fa fa-check"></i><b>5.3.8.3</b> Understanding discrepencies</a></li>
</ul></li>
<li class="chapter" data-level="5.3.9" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#normal-model"><i class="fa fa-check"></i><b>5.3.9</b> Normal Model</a>
<ul>
<li class="chapter" data-level="5.3.9.1" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#conjugate-analysis"><i class="fa fa-check"></i><b>5.3.9.1</b> Conjugate analysis</a></li>
<li class="chapter" data-level="5.3.9.2" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#precision-and-combining-information"><i class="fa fa-check"></i><b>5.3.9.2</b> Precision and combining information</a></li>
<li class="chapter" data-level="5.3.9.3" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#prediction-for-a-new-observation"><i class="fa fa-check"></i><b>5.3.9.3</b> Prediction for a new observation</a></li>
<li class="chapter" data-level="5.3.9.4" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#joint-inference-for-the-mean-and-variance"><i class="fa fa-check"></i><b>5.3.9.4</b> Joint inference for the mean and variance</a></li>
<li class="chapter" data-level="5.3.9.5" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#posterior-inference"><i class="fa fa-check"></i><b>5.3.9.5</b> Posterior inference</a></li>
<li class="chapter" data-level="5.3.9.6" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#monte-carlo-sampling"><i class="fa fa-check"></i><b>5.3.9.6</b> Monte Carlo sampling</a></li>
<li class="chapter" data-level="5.3.9.7" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#improper-priors"><i class="fa fa-check"></i><b>5.3.9.7</b> Improper Priors</a></li>
<li class="chapter" data-level="5.3.9.8" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#bias-variance-and-mean-squared-error-mse"><i class="fa fa-check"></i><b>5.3.9.8</b> Bias, Variance, and Mean Squared Error (MSE);</a></li>
<li class="chapter" data-level="5.3.9.9" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#prior-specification-based-on-expectations"><i class="fa fa-check"></i><b>5.3.9.9</b> Prior specification based on expectations</a></li>
<li class="chapter" data-level="5.3.9.10" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#the-normal-model-on-non-normal-data"><i class="fa fa-check"></i><b>5.3.9.10</b> The normal model on non-normal data</a></li>
</ul></li>
<li class="chapter" data-level="5.3.10" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#posterior-approximation-with-the-gibbs-sampler."><i class="fa fa-check"></i><b>5.3.10</b> Posterior approximation with the Gibbs sampler.</a>
<ul>
<li class="chapter" data-level="5.3.10.1" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#a-semiconjugate-prior-distribution"><i class="fa fa-check"></i><b>5.3.10.1</b> A semiconjugate prior distribution</a></li>
<li class="chapter" data-level="5.3.10.2" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#discrete-approximations"><i class="fa fa-check"></i><b>5.3.10.2</b> Discrete approximations</a></li>
<li class="chapter" data-level="5.3.10.3" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#sampling-from-the-conditional-distributions"><i class="fa fa-check"></i><b>5.3.10.3</b> Sampling from the conditional distributions</a></li>
<li class="chapter" data-level="5.3.10.4" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#gibbs-sampling"><i class="fa fa-check"></i><b>5.3.10.4</b> Gibbs sampling</a></li>
<li class="chapter" data-level="5.3.10.5" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#general-properties-of-the-gibbs-sampler"><i class="fa fa-check"></i><b>5.3.10.5</b> General properties of the Gibbs sampler</a></li>
<li class="chapter" data-level="5.3.10.6" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#introduction-to-mcmc-diagnostics"><i class="fa fa-check"></i><b>5.3.10.6</b> Introduction to MCMC diagnostics</a></li>
</ul></li>
<li class="chapter" data-level="5.3.11" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#multivariate-normal-model"><i class="fa fa-check"></i><b>5.3.11</b> Multivariate Normal Model</a></li>
<li class="chapter" data-level="5.3.12" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#group-comparisons-and-hierarchial-modeling"><i class="fa fa-check"></i><b>5.3.12</b> Group comparisons and hierarchial modeling</a></li>
<li class="chapter" data-level="5.3.13" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#linear-regression-1"><i class="fa fa-check"></i><b>5.3.13</b> Linear Regression</a></li>
<li class="chapter" data-level="5.3.14" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#nonconjugate-priors-and-metropolis-hastings-algorithm"><i class="fa fa-check"></i><b>5.3.14</b> Nonconjugate priors and Metropolis-Hastings algorithm</a>
<ul>
<li class="chapter" data-level="5.3.14.1" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#irreducibility-aperiodicity-and-recurrency"><i class="fa fa-check"></i><b>5.3.14.1</b> Irreducibility, Aperiodicity, and Recurrency</a></li>
<li class="chapter" data-level="5.3.14.2" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#ergodic-theorem"><i class="fa fa-check"></i><b>5.3.14.2</b> Ergodic Theorem</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5.4" data-path="cs50.html"><a href="cs50.html"><i class="fa fa-check"></i><b>5.4</b> CS50</a>
<ul>
<li class="chapter" data-level="5.4.1" data-path="cs50.html"><a href="cs50.html#introduction"><i class="fa fa-check"></i><b>5.4.1</b> Introduction</a>
<ul>
<li class="chapter" data-level="5.4.1.1" data-path="cs50.html"><a href="cs50.html#unicode"><i class="fa fa-check"></i><b>5.4.1.1</b> Unicode</a></li>
<li class="chapter" data-level="5.4.1.2" data-path="cs50.html"><a href="cs50.html#color"><i class="fa fa-check"></i><b>5.4.1.2</b> Color</a></li>
<li class="chapter" data-level="5.4.1.3" data-path="cs50.html"><a href="cs50.html#algorithms"><i class="fa fa-check"></i><b>5.4.1.3</b> Algorithms</a></li>
<li class="chapter" data-level="5.4.1.4" data-path="cs50.html"><a href="cs50.html#artificial-intelligence"><i class="fa fa-check"></i><b>5.4.1.4</b> Artificial Intelligence</a></li>
</ul></li>
<li class="chapter" data-level="5.4.2" data-path="cs50.html"><a href="cs50.html#c"><i class="fa fa-check"></i><b>5.4.2</b> C</a>
<ul>
<li class="chapter" data-level="5.4.2.1" data-path="cs50.html"><a href="cs50.html#running-cs50-locally"><i class="fa fa-check"></i><b>5.4.2.1</b> Running CS50 locally</a></li>
<li class="chapter" data-level="5.4.2.2" data-path="cs50.html"><a href="cs50.html#source-code"><i class="fa fa-check"></i><b>5.4.2.2</b> Source code</a></li>
<li class="chapter" data-level="5.4.2.3" data-path="cs50.html"><a href="cs50.html#from-scratch-to-c"><i class="fa fa-check"></i><b>5.4.2.3</b> From Scratch to C</a></li>
<li class="chapter" data-level="5.4.2.4" data-path="cs50.html"><a href="cs50.html#header-files"><i class="fa fa-check"></i><b>5.4.2.4</b> Header Files</a></li>
<li class="chapter" data-level="5.4.2.5" data-path="cs50.html"><a href="cs50.html#hello-you"><i class="fa fa-check"></i><b>5.4.2.5</b> Hello, You</a></li>
<li class="chapter" data-level="5.4.2.6" data-path="cs50.html"><a href="cs50.html#terminal-commands"><i class="fa fa-check"></i><b>5.4.2.6</b> Terminal Commands</a></li>
<li class="chapter" data-level="5.4.2.7" data-path="cs50.html"><a href="cs50.html#types"><i class="fa fa-check"></i><b>5.4.2.7</b> Types</a></li>
<li class="chapter" data-level="5.4.2.8" data-path="cs50.html"><a href="cs50.html#conditionals"><i class="fa fa-check"></i><b>5.4.2.8</b> Conditionals</a></li>
<li class="chapter" data-level="5.4.2.9" data-path="cs50.html"><a href="cs50.html#variables-and-compare.c"><i class="fa fa-check"></i><b>5.4.2.9</b> Variables and compare.c</a></li>
<li class="chapter" data-level="5.4.2.10" data-path="cs50.html"><a href="cs50.html#agree.c"><i class="fa fa-check"></i><b>5.4.2.10</b> agree.c</a></li>
<li class="chapter" data-level="5.4.2.11" data-path="cs50.html"><a href="cs50.html#loops-cat.c"><i class="fa fa-check"></i><b>5.4.2.11</b> Loops cat.c</a></li>
<li class="chapter" data-level="5.4.2.12" data-path="cs50.html"><a href="cs50.html#functions"><i class="fa fa-check"></i><b>5.4.2.12</b> Functions</a></li>
<li class="chapter" data-level="5.4.2.13" data-path="cs50.html"><a href="cs50.html#correctness-design-style"><i class="fa fa-check"></i><b>5.4.2.13</b> Correctness, Design, Style</a></li>
<li class="chapter" data-level="5.4.2.14" data-path="cs50.html"><a href="cs50.html#mario"><i class="fa fa-check"></i><b>5.4.2.14</b> Mario</a></li>
<li class="chapter" data-level="5.4.2.15" data-path="cs50.html"><a href="cs50.html#calculator.c"><i class="fa fa-check"></i><b>5.4.2.15</b> calculator.c</a></li>
<li class="chapter" data-level="5.4.2.16" data-path="cs50.html"><a href="cs50.html#integer-overflow"><i class="fa fa-check"></i><b>5.4.2.16</b> Integer Overflow</a></li>
<li class="chapter" data-level="5.4.2.17" data-path="cs50.html"><a href="cs50.html#boeing"><i class="fa fa-check"></i><b>5.4.2.17</b> Boeing</a></li>
<li class="chapter" data-level="5.4.2.18" data-path="cs50.html"><a href="cs50.html#pacman"><i class="fa fa-check"></i><b>5.4.2.18</b> Pacman</a></li>
<li class="chapter" data-level="5.4.2.19" data-path="cs50.html"><a href="cs50.html#truncation"><i class="fa fa-check"></i><b>5.4.2.19</b> Truncation</a></li>
<li class="chapter" data-level="5.4.2.20" data-path="cs50.html"><a href="cs50.html#type-casting"><i class="fa fa-check"></i><b>5.4.2.20</b> Type Casting</a></li>
<li class="chapter" data-level="5.4.2.21" data-path="cs50.html"><a href="cs50.html#floating-point-imprecision"><i class="fa fa-check"></i><b>5.4.2.21</b> Floating-Point Imprecision</a></li>
</ul></li>
<li class="chapter" data-level="5.4.3" data-path="cs50.html"><a href="cs50.html#arrays"><i class="fa fa-check"></i><b>5.4.3</b> Arrays</a></li>
<li class="chapter" data-level="5.4.4" data-path="cs50.html"><a href="cs50.html#memory"><i class="fa fa-check"></i><b>5.4.4</b> Memory</a></li>
<li class="chapter" data-level="5.4.5" data-path="cs50.html"><a href="cs50.html#data-structures"><i class="fa fa-check"></i><b>5.4.5</b> Data Structures</a></li>
<li class="chapter" data-level="5.4.6" data-path="cs50.html"><a href="cs50.html#python"><i class="fa fa-check"></i><b>5.4.6</b> Python</a></li>
<li class="chapter" data-level="5.4.7" data-path="cs50.html"><a href="cs50.html#artificial-intelligence-1"><i class="fa fa-check"></i><b>5.4.7</b> Artificial Intelligence</a></li>
<li class="chapter" data-level="5.4.8" data-path="cs50.html"><a href="cs50.html#sql"><i class="fa fa-check"></i><b>5.4.8</b> SQL</a></li>
<li class="chapter" data-level="5.4.9" data-path="cs50.html"><a href="cs50.html#html-css-javascript"><i class="fa fa-check"></i><b>5.4.9</b> HTML, CSS, JavaScript</a></li>
<li class="chapter" data-level="5.4.10" data-path="cs50.html"><a href="cs50.html#flask"><i class="fa fa-check"></i><b>5.4.10</b> Flask</a></li>
<li class="chapter" data-level="5.4.11" data-path="cs50.html"><a href="cs50.html#the-end"><i class="fa fa-check"></i><b>5.4.11</b> The End</a></li>
<li class="chapter" data-level="5.4.12" data-path="cs50.html"><a href="cs50.html#ace-reccomendation"><i class="fa fa-check"></i><b>5.4.12</b> ACE Reccomendation</a></li>
</ul></li>
<li class="chapter" data-level="5.5" data-path="deep-learning-1.html"><a href="deep-learning-1.html"><i class="fa fa-check"></i><b>5.5</b> Deep Learning</a>
<ul>
<li class="chapter" data-level="5.5.1" data-path="deep-learning-1.html"><a href="deep-learning-1.html#introduction-to-neural-networks-and-deep-learning"><i class="fa fa-check"></i><b>5.5.1</b> 9/5 Introduction to Neural Networks and Deep Learning,</a></li>
<li class="chapter" data-level="5.5.2" data-path="deep-learning-1.html"><a href="deep-learning-1.html#gradient-descent-and-back-propagation"><i class="fa fa-check"></i><b>5.5.2</b> 9/12 Gradient Descent and Back Propagation</a></li>
<li class="chapter" data-level="5.5.3" data-path="deep-learning-1.html"><a href="deep-learning-1.html#keras"><i class="fa fa-check"></i><b>5.5.3</b> 9/19 Keras</a></li>
<li class="chapter" data-level="5.5.4" data-path="deep-learning-1.html"><a href="deep-learning-1.html#convolutional-neural-networks-cnns"><i class="fa fa-check"></i><b>5.5.4</b> 9/26 Convolutional Neural Networks (CNNs)</a></li>
<li class="chapter" data-level="5.5.5" data-path="deep-learning-1.html"><a href="deep-learning-1.html#visualizing-feature-maps-of-cnn-layers-locating-objects-in-images"><i class="fa fa-check"></i><b>5.5.5</b> 10/3 Visualizing Feature Maps of CNN Layers, Locating Objects in Images</a></li>
<li class="chapter" data-level="5.5.6" data-path="deep-learning-1.html"><a href="deep-learning-1.html#transfer-learning-fine-tuning-augmentation"><i class="fa fa-check"></i><b>5.5.6</b> 10/10: Transfer Learning, Fine Tuning, Augmentation</a></li>
<li class="chapter" data-level="5.5.7" data-path="deep-learning-1.html"><a href="deep-learning-1.html#autoencoders-variational-autoencoders-and-manifold-hypothesis"><i class="fa fa-check"></i><b>5.5.7</b> 10/17 Autoencoders, Variational Autoencoders and Manifold Hypothesis</a></li>
<li class="chapter" data-level="5.5.8" data-path="deep-learning-1.html"><a href="deep-learning-1.html#natural-language-processing-nlp-doc2vec-like-api-s-and"><i class="fa fa-check"></i><b>5.5.8</b> 10/24 Natural Language Processing (NLP), Doc2Vec like API-s and</a></li>
<li class="chapter" data-level="5.5.9" data-path="deep-learning-1.html"><a href="deep-learning-1.html#analysis-and-transcription-of-speech"><i class="fa fa-check"></i><b>5.5.9</b> 10/31 Analysis and Transcription of Speech</a></li>
<li class="chapter" data-level="5.5.10" data-path="deep-learning-1.html"><a href="deep-learning-1.html#sequence-analysis-seq2seq-models-and-machine-translation"><i class="fa fa-check"></i><b>5.5.10</b> 11/7 Sequence Analysis, Seq2Seq Models and Machine Translation</a></li>
<li class="chapter" data-level="5.5.11" data-path="deep-learning-1.html"><a href="deep-learning-1.html#transformers"><i class="fa fa-check"></i><b>5.5.11</b> 11/14 Transformers</a></li>
<li class="chapter" data-level="5.5.12" data-path="deep-learning-1.html"><a href="deep-learning-1.html#class-12-large-language-models-llms"><i class="fa fa-check"></i><b>5.5.12</b> 11/21: Class 12: Large Language Models (LLMs)</a></li>
<li class="chapter" data-level="5.5.13" data-path="deep-learning-1.html"><a href="deep-learning-1.html#class-13-generative-adversarial-networks-gans"><i class="fa fa-check"></i><b>5.5.13</b> 12/5: Class 13: Generative Adversarial Networks (GANs)</a></li>
<li class="chapter" data-level="5.5.14" data-path="deep-learning-1.html"><a href="deep-learning-1.html#class-14-graphs-neural-networks-gnns"><i class="fa fa-check"></i><b>5.5.14</b> 12/12: Class 14: Graphs Neural Networks (GNNs)</a></li>
<li class="chapter" data-level="5.5.15" data-path="deep-learning-1.html"><a href="deep-learning-1.html#the-final-project-presentations"><i class="fa fa-check"></i><b>5.5.15</b> 12/19: The Final Project Presentations</a></li>
</ul></li>
<li class="chapter" data-level="5.6" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html"><i class="fa fa-check"></i><b>5.6</b> Data Mining, Discovery, and Exploration</a>
<ul>
<li class="chapter" data-level="5.6.1" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#course-introduction-and-introduction-to-data-mining"><i class="fa fa-check"></i><b>5.6.1</b> 9/3 Course introduction and introduction to data mining</a>
<ul>
<li class="chapter" data-level="5.6.1.1" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#what-is-data-mining"><i class="fa fa-check"></i><b>5.6.1.1</b> What is data mining?</a></li>
<li class="chapter" data-level="5.6.1.2" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#goals-of-data-mining"><i class="fa fa-check"></i><b>5.6.1.2</b> Goals of data mining</a></li>
<li class="chapter" data-level="5.6.1.3" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#limitations"><i class="fa fa-check"></i><b>5.6.1.3</b> Limitations</a></li>
<li class="chapter" data-level="5.6.1.4" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#bonferronis-principle"><i class="fa fa-check"></i><b>5.6.1.4</b> Bonferroni’s Principle</a></li>
<li class="chapter" data-level="5.6.1.5" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#what-is-a-hash-function-a-hash-table"><i class="fa fa-check"></i><b>5.6.1.5</b> What is a hash function, a hash table?</a></li>
<li class="chapter" data-level="5.6.1.6" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#hashing-for-managing-massive-data-sets"><i class="fa fa-check"></i><b>5.6.1.6</b> Hashing for managing massive data sets</a></li>
<li class="chapter" data-level="5.6.1.7" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#scalable-hypothesis-test-algorithms-for-data-mining"><i class="fa fa-check"></i><b>5.6.1.7</b> Scalable hypothesis test algorithms for data mining</a></li>
</ul></li>
<li class="chapter" data-level="5.6.2" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#data-mining-massive-and-streaming-data-part-1"><i class="fa fa-check"></i><b>5.6.2</b> 9/10 Data mining massive and streaming data, Part 1</a>
<ul>
<li class="chapter" data-level="5.6.2.1" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#the-nature-of-streaming-data"><i class="fa fa-check"></i><b>5.6.2.1</b> The nature of streaming data</a></li>
<li class="chapter" data-level="5.6.2.2" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#architectures-for-streaming-data"><i class="fa fa-check"></i><b>5.6.2.2</b> Architectures for streaming data</a></li>
<li class="chapter" data-level="5.6.2.3" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#filters-and-counting-for-streams"><i class="fa fa-check"></i><b>5.6.2.3</b> Filters and counting for streams</a></li>
<li class="chapter" data-level="5.6.2.4" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#updating-statistics-with-streams"><i class="fa fa-check"></i><b>5.6.2.4</b> Updating statistics with streams</a></li>
<li class="chapter" data-level="5.6.2.5" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#quantile-estimation-for-streams"><i class="fa fa-check"></i><b>5.6.2.5</b> Quantile estimation for streams</a></li>
</ul></li>
<li class="chapter" data-level="5.6.3" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#data-mining-massive-and-streaming-data-part-2"><i class="fa fa-check"></i><b>5.6.3</b> 9/17 Data mining massive and streaming data, Part 2</a></li>
<li class="chapter" data-level="5.6.4" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#mining-social-network-graphs"><i class="fa fa-check"></i><b>5.6.4</b> 9/24 Mining social-network graphs</a>
<ul>
<li class="chapter" data-level="5.6.4.1" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#nature-of-social-network-graphs"><i class="fa fa-check"></i><b>5.6.4.1</b> Nature of social-network graphs</a></li>
<li class="chapter" data-level="5.6.4.2" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#centrality-and-influence"><i class="fa fa-check"></i><b>5.6.4.2</b> Centrality and influence</a></li>
<li class="chapter" data-level="5.6.4.3" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#clustering-graphs"><i class="fa fa-check"></i><b>5.6.4.3</b> Clustering graphs</a></li>
<li class="chapter" data-level="5.6.4.4" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#spectral-decomposition-of-graphs"><i class="fa fa-check"></i><b>5.6.4.4</b> Spectral decomposition of graphs</a></li>
<li class="chapter" data-level="5.6.4.5" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#overlapping-communities-time-permitting"><i class="fa fa-check"></i><b>5.6.4.5</b> Overlapping communities – time permitting</a></li>
</ul></li>
<li class="chapter" data-level="5.6.5" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#similarity-search-at-massive-scale-part-1"><i class="fa fa-check"></i><b>5.6.5</b> 10/1 Similarity search at massive scale, Part 1</a>
<ul>
<li class="chapter" data-level="5.6.5.1" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#distance-measures"><i class="fa fa-check"></i><b>5.6.5.1</b> Distance measures</a></li>
<li class="chapter" data-level="5.6.5.2" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#similarity-measures"><i class="fa fa-check"></i><b>5.6.5.2</b> Similarity measures</a></li>
<li class="chapter" data-level="5.6.5.3" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#search-with-kd-trees"><i class="fa fa-check"></i><b>5.6.5.3</b> Search with KD-trees</a></li>
<li class="chapter" data-level="5.6.5.4" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#approximate-similarity-search-at-massive-scale"><i class="fa fa-check"></i><b>5.6.5.4</b> Approximate similarity search at massive scale</a></li>
<li class="chapter" data-level="5.6.5.5" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#indexes-for-massive-similarity-serarch"><i class="fa fa-check"></i><b>5.6.5.5</b> Indexes for massive similarity serarch</a></li>
<li class="chapter" data-level="5.6.5.6" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#evaluation-of-approximate-similarity-search-algorithms"><i class="fa fa-check"></i><b>5.6.5.6</b> Evaluation of approximate similarity search algorithms</a></li>
</ul></li>
<li class="chapter" data-level="5.6.6" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#similarity-search-at-massive-scale-part-2"><i class="fa fa-check"></i><b>5.6.6</b> 10/8 Similarity search at massive scale, Part 2</a></li>
<li class="chapter" data-level="5.6.7" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#information-retrieval-for-document-and-web-search"><i class="fa fa-check"></i><b>5.6.7</b> 10/15 Information retrieval for document and web search</a>
<ul>
<li class="chapter" data-level="5.6.7.1" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#dense-vs.-sparse-embedding-for-documents-search"><i class="fa fa-check"></i><b>5.6.7.1</b> Dense vs. sparse embedding for documents search</a></li>
<li class="chapter" data-level="5.6.7.2" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#dense-neural-embedding-algorithms"><i class="fa fa-check"></i><b>5.6.7.2</b> Dense neural embedding algorithms</a></li>
<li class="chapter" data-level="5.6.7.3" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#sparse-embedding-algorithms"><i class="fa fa-check"></i><b>5.6.7.3</b> Sparse embedding algorithms</a></li>
<li class="chapter" data-level="5.6.7.4" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#term-expansion-algorithms"><i class="fa fa-check"></i><b>5.6.7.4</b> Term expansion algorithms</a></li>
<li class="chapter" data-level="5.6.7.5" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#embedding-images-and-clip"><i class="fa fa-check"></i><b>5.6.7.5</b> Embedding images and CLIP</a></li>
</ul></li>
<li class="chapter" data-level="5.6.8" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#learning-to-rank-for-search-and-recommendation-part-1"><i class="fa fa-check"></i><b>5.6.8</b> 10/22 Learning to rank for search and recommendation, Part 1</a>
<ul>
<li class="chapter" data-level="5.6.8.1" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#embedding-high-cardinality-features"><i class="fa fa-check"></i><b>5.6.8.1</b> Embedding high cardinality features</a></li>
<li class="chapter" data-level="5.6.8.2" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#content-based-methods"><i class="fa fa-check"></i><b>5.6.8.2</b> Content based methods</a></li>
<li class="chapter" data-level="5.6.8.3" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#collaborative-filtering"><i class="fa fa-check"></i><b>5.6.8.3</b> Collaborative filtering</a></li>
<li class="chapter" data-level="5.6.8.4" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#latent-variable-algorithms"><i class="fa fa-check"></i><b>5.6.8.4</b> Latent variable algorithms</a></li>
<li class="chapter" data-level="5.6.8.5" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#the-pagerank-algorithm"><i class="fa fa-check"></i><b>5.6.8.5</b> The PageRank algorithm</a></li>
<li class="chapter" data-level="5.6.8.6" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#priority-queues-and-heaps"><i class="fa fa-check"></i><b>5.6.8.6</b> Priority queues and heaps</a></li>
</ul></li>
<li class="chapter" data-level="5.6.9" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#learning-to-rank-for-search-and-recommendation-part-2"><i class="fa fa-check"></i><b>5.6.9</b> 10/29 Learning to rank for search and recommendation, Part 2</a></li>
<li class="chapter" data-level="5.6.10" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#clustering-algorithms-part-1"><i class="fa fa-check"></i><b>5.6.10</b> 11/5 Clustering Algorithms, Part 1</a>
<ul>
<li class="chapter" data-level="5.6.10.1" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#finding-structure-in-data"><i class="fa fa-check"></i><b>5.6.10.1</b> Finding structure in data</a></li>
<li class="chapter" data-level="5.6.10.2" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#the-k-means-algorithm"><i class="fa fa-check"></i><b>5.6.10.2</b> The k-means algorithm</a></li>
<li class="chapter" data-level="5.6.10.3" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#problems-with-evaluating-clustering-results"><i class="fa fa-check"></i><b>5.6.10.3</b> Problems with evaluating clustering results</a></li>
<li class="chapter" data-level="5.6.10.4" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#probabilistic-clustering-dealing-with-uncertainty"><i class="fa fa-check"></i><b>5.6.10.4</b> Probabilistic clustering, dealing with uncertainty</a></li>
<li class="chapter" data-level="5.6.10.5" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#agglomerative-hierarchical-clustering-and-k-medoids-algorithms-for-non-euclidean-spaces"><i class="fa fa-check"></i><b>5.6.10.5</b> Agglomerative hierarchical clustering and k-medoids algorithms for non-Euclidean spaces</a></li>
<li class="chapter" data-level="5.6.10.6" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#density-based-clustering-algorithms"><i class="fa fa-check"></i><b>5.6.10.6</b> Density-based clustering algorithms</a></li>
<li class="chapter" data-level="5.6.10.7" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#graph-based-clustering-algorithms"><i class="fa fa-check"></i><b>5.6.10.7</b> Graph-based clustering algorithms</a></li>
<li class="chapter" data-level="5.6.10.8" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#database-scale-clustering-algorithms"><i class="fa fa-check"></i><b>5.6.10.8</b> Database scale clustering algorithms</a></li>
</ul></li>
<li class="chapter" data-level="5.6.11" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#clustering-algorithms-part-2"><i class="fa fa-check"></i><b>5.6.11</b> 11/12 Clustering Algorithms, Part 2</a></li>
<li class="chapter" data-level="5.6.12" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#dimensionality-reduction"><i class="fa fa-check"></i><b>5.6.12</b> 11/19 Dimensionality reduction</a>
<ul>
<li class="chapter" data-level="5.6.12.1" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#eigenvalues-and-pca"><i class="fa fa-check"></i><b>5.6.12.1</b> Eigenvalues and PCA</a></li>
<li class="chapter" data-level="5.6.12.2" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#singular-value-decomposition-and-its-interpretation"><i class="fa fa-check"></i><b>5.6.12.2</b> Singular value decomposition and its interpretation</a></li>
<li class="chapter" data-level="5.6.12.3" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#manifold-learning-and-nonlinear-spaces"><i class="fa fa-check"></i><b>5.6.12.3</b> Manifold learning and nonlinear spaces</a></li>
<li class="chapter" data-level="5.6.12.4" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#spectral-embedding"><i class="fa fa-check"></i><b>5.6.12.4</b> Spectral embedding</a></li>
<li class="chapter" data-level="5.6.12.5" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#the-umap-algorithm"><i class="fa fa-check"></i><b>5.6.12.5</b> The UMAP algorithm</a></li>
</ul></li>
<li class="chapter" data-level="5.6.13" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#section"><i class="fa fa-check"></i><b>5.6.13</b> 11/23</a></li>
<li class="chapter" data-level="5.6.14" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#frequent-item-sets-market-basket-analysis"><i class="fa fa-check"></i><b>5.6.14</b> 12/3 Frequent item sets; market basket analysis</a>
<ul>
<li class="chapter" data-level="5.6.14.1" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#market-basket-models"><i class="fa fa-check"></i><b>5.6.14.1</b> Market basket models</a></li>
<li class="chapter" data-level="5.6.14.2" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#the-a-priori-algorithm"><i class="fa fa-check"></i><b>5.6.14.2</b> The A-Priori algorithm</a></li>
<li class="chapter" data-level="5.6.14.3" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#limited-pass-algorithms"><i class="fa fa-check"></i><b>5.6.14.3</b> Limited pass algorithms</a></li>
<li class="chapter" data-level="5.6.14.4" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#streaming-algorithms-time-permitting"><i class="fa fa-check"></i><b>5.6.14.4</b> Streaming algorithms – time permitting</a></li>
</ul></li>
<li class="chapter" data-level="5.6.15" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#additional-topics"><i class="fa fa-check"></i><b>5.6.15</b> 12/10 Additional Topics</a></li>
<li class="chapter" data-level="5.6.16" data-path="data-mining-discovery-and-exploration.html"><a href="data-mining-discovery-and-exploration.html#final-project-due"><i class="fa fa-check"></i><b>5.6.16</b> 12/17: Final Project Due</a></li>
</ul></li>
</ul></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Perpetually trying to remember what I forgot</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="statistical-inference" class="section level2 hasAnchor" number="5.2">
<h2><span class="header-section-number">5.2</span> Statistical Inference:<a href="statistical-inference.html#statistical-inference" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Readings from:
An Introduction to Statistical Learning with applications in R, <a href="https://www.statlearning.com/" class="uri">https://www.statlearning.com/</a></p>
<div id="why-statistical-inference" class="section level3 hasAnchor" number="5.2.1">
<h3><span class="header-section-number">5.2.1</span> Why Statistical Inference<a href="statistical-inference.html#why-statistical-inference" class="anchor-section" aria-label="Anchor link to header"></a></h3>
</div>
<div id="statistical-learning" class="section level3 hasAnchor" number="5.2.2">
<h3><span class="header-section-number">5.2.2</span> Statistical Learning<a href="statistical-inference.html#statistical-learning" class="anchor-section" aria-label="Anchor link to header"></a></h3>
</div>
<div id="linear-regression" class="section level3 hasAnchor" number="5.2.3">
<h3><span class="header-section-number">5.2.3</span> Linear Regression<a href="statistical-inference.html#linear-regression" class="anchor-section" aria-label="Anchor link to header"></a></h3>
</div>
<div id="classification" class="section level3 hasAnchor" number="5.2.4">
<h3><span class="header-section-number">5.2.4</span> Classification<a href="statistical-inference.html#classification" class="anchor-section" aria-label="Anchor link to header"></a></h3>
</div>
<div id="resampling-methods" class="section level3 hasAnchor" number="5.2.5">
<h3><span class="header-section-number">5.2.5</span> Resampling Methods<a href="statistical-inference.html#resampling-methods" class="anchor-section" aria-label="Anchor link to header"></a></h3>
</div>
<div id="linear-model-selection-and-regularization" class="section level3 hasAnchor" number="5.2.6">
<h3><span class="header-section-number">5.2.6</span> Linear Model Selection and Regularization<a href="statistical-inference.html#linear-model-selection-and-regularization" class="anchor-section" aria-label="Anchor link to header"></a></h3>
</div>
<div id="moving-beyond-linearity" class="section level3 hasAnchor" number="5.2.7">
<h3><span class="header-section-number">5.2.7</span> Moving Beyond linearity<a href="statistical-inference.html#moving-beyond-linearity" class="anchor-section" aria-label="Anchor link to header"></a></h3>
</div>
<div id="tree-based-methods" class="section level3 hasAnchor" number="5.2.8">
<h3><span class="header-section-number">5.2.8</span> Tree-Based Methods<a href="statistical-inference.html#tree-based-methods" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>This chapter introduces tree-based methods for regression and classification, which work by <em>straifying</em> or <em>segmenting</em> (i.e. dividing) the predictor space into simple regions using splitting rules that form a decision tree. These methods are easy to interpret, but usually less accurate than other supervised learning techniques. To improve accuracy, thiz chapter also covers advanced methods like bagging, random forests, boosting, and Bayesian additive regression trees, which combine many trees to enhance predictions, though this comes with some loss of interpretability.</p>
<div id="the-basics-of-decision-trees" class="section level4 hasAnchor" number="5.2.8.1">
<h4><span class="header-section-number">5.2.8.1</span> The Basics of Decision Trees<a href="statistical-inference.html#the-basics-of-decision-trees" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Decision Trees are applicabile to both Regression and Classification problems.</p>
<div id="regression-trees" class="section level5 hasAnchor" number="5.2.8.1.1">
<h5><span class="header-section-number">5.2.8.1.1</span> Regression Trees<a href="statistical-inference.html#regression-trees" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>Decision trees are a class of predictive modeling algorithms that partitions the predictor space (the set of all possible values of the input variables) into distinct and non-overlapping regions, using a sequence of decision rules based on the values of the input variables.</p>
<p>Each rule is based on the value of one input variable, and each split divides the data into two branches according to whether the rule is true or false.</p>
<p>In regression, the goal is to predict a numerical (continuous) response variable. The decision tree algorithm recursively splits the predictor space into regions by finding the value and variable that best separates the data to minimize prediction error. At each split (internal node), the data is divided based on whether the value of a particular predictor variable is less than or greater than/equal to a threshold. We can also use decision trees for predition.</p>
</div>
<div id="prediction-via-strartification-of-the-feature-space" class="section level5 hasAnchor" number="5.2.8.1.2">
<h5><span class="header-section-number">5.2.8.1.2</span> Prediction via Strartification of the Feature Space<a href="statistical-inference.html#prediction-via-strartification-of-the-feature-space" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>To make a prediction for a new observation (player), you start at the top of the tree and follow the path dictated by the player’s values for each predictor. Each internal node represents a decision rule, and each leaf represents the predicted value for the response variable, which is the average of the training responses in that region.</p>
<p>Decision trees segment the predictor space using sequential binary splits based on variable thresholds.
At each internal node, the left branch corresponds to observations where the splitting condition is true and the right branch corresponds to the opposite. Each terminal node (leaf) holds the mean response for all training points that fall in that region.</p>
<p><strong>Data Preprocessing</strong></p>
<ul>
<li><p>Missing Data: Before fitting the model, any missing information are removed from the dataset. This is necessary because regression methods require a complete set of predictor and response values.</p></li>
<li><p>Log Transformation: The variable is log-transformed (i.e., replaced by its natural logarithm) so that its distribution is closer to normal (bell-shaped). This is a common step in regression analysis when the response variable is skewed or has outliers, because it can make modeling and interpretation more stable and meaningful.</p></li>
</ul>
<p><strong>Prediction via Stratification of the Feature Space</strong></p>
<p>Builing a regression tree for prediction occurs in a two-step process.</p>
<p>Step 1: Dividing the Predictor Space</p>
<ul>
<li><p>The goal is to divide the predictor space—meaning the set of all possible combinations of the input variables <span class="math inline">\(X_1, X_2, \ldots, X_p\)</span>—into <span class="math inline">\(J\)</span> distinct, non-overlapping regions <span class="math inline">\(R_1, R_2, \ldots, R_J\)</span>.</p></li>
<li><p>Each region is like a box in the multi-dimensional space defined by the features.</p></li>
</ul>
<p>Step 2: Making Predictions</p>
<ul>
<li><p>For each region <span class="math inline">\(R_j\)</span>, all observations that fall inside it (i.e., all data points whose feature values meet the region’s conditions) are assigned the same prediction.</p></li>
<li><p>This prediction is the average (mean) of the response variable (<span class="math inline">\(y\)</span>) for all training observations in <span class="math inline">\(R_j\)</span>.</p></li>
<li><p>If a new observation falls into region <span class="math inline">\(R_2\)</span>, its predicted value is just the mean of the response values for all training data points in <span class="math inline">\(R_2\)</span>.</p></li>
</ul>
<p><strong>How are regions constructed?</strong></p>
<p>In theory, the regions could be of any shape or size; they don’t have to be boxes or rectangles. In practice, we restrict ourselves to “boxes” (high-dimensional rectangles) because they are easier to interpret and computationally feasible. Ultimately, the goal is to minimize the Residual Sum of Squares (RSS).</p>
<ul>
<li>The ideal partition is the one that minimizes the total sum of squared differences between the observed responses and the mean response in each region:</li>
</ul>
<p><span class="math display">\[
    \sum_{j=1}^J \sum_{i \in R_j} (y_i - \hat{y}_{R_j})^2
    \]</span></p>
<ul>
<li><span class="math inline">\(y_i\)</span> is the actual value for observation <span class="math inline">\(i\)</span></li>
<li><span class="math inline">\(\hat{y}_{R_j}\)</span> is the average response for region <span class="math inline">\(R_j\)</span></li>
</ul>
<p>This is called the residual sum of squares (RSS) and is a measure of how well the regions fit the data.</p>
<p><strong>Why Not Try All Possibilities?</strong></p>
<p>Trying every possible way to divide the predictor space into <span class="math inline">\(J\)</span> regions would require checking an enormous number of combinations, which is computationally impossible for all but the very smallest datasets.</p>
<p><strong>The Greedy, Top-Down Approach (aka Recursive Binary Splitting)</strong></p>
<p>To approach via “Top-Down”, we start with the entire dataset considered as one region. At each step, we look for the single best way to split one region into two new regions, according to a simple decision rule.</p>
<p>To approach “Greedy” means that at each step, we make the locally optimal choice: we pick the split that gives the greatest immediate reduction in RSS, without considering how this split will affect future splits. This means we do not look ahead or try to optimize the tree globally; we only optimize at the current step.</p>
<p><strong>Recursive Binary Splitting Step-by-Step Process</strong></p>
<p>For each feature <span class="math inline">\(X_j\)</span> and for each possible value <span class="math inline">\(s\)</span> that feature can take:</p>
<ol style="list-style-type: decimal">
<li>Divide the observations into two regions:  </li>
</ol>
<p><span class="math display">\[
  R_1(j, s) = \{X \mid X_j &lt; s\}
\]</span></p>
<p><span class="math display">\[
  R_2(j, s) = \{X \mid X_j \geq s\}
\]</span></p>
<ol start="2" style="list-style-type: decimal">
<li>For each region, calculate the mean of the response for training observations inside that region.<br />
</li>
<li>Compute the sum of squared differences from the mean (RSS) for both regions.<br />
</li>
<li>Find the feature <span class="math inline">\(j\)</span> and split point <span class="math inline">\(s\)</span> that result in the smallest total RSS.<br />
</li>
</ol>
<ul>
<li>This is the greedy and considered the best split.<br />
</li>
</ul>
<ol start="5" style="list-style-type: decimal">
<li>Once the split is made on the data into two regions, repeat this recursively:<br />
</li>
</ol>
<ul>
<li>For each existing region, find the best new split (best feature and best cutpoint) that further reduces the RSS within that region.</li>
<li>At each stage, only one region is split at a time (not all at once). This recursive splitting continues, region by region, always choosing the locally best split at each step. The stopping criterion to stop occurs when a region reaches some minimal size (e.g., no region has fewer than five observations), or another condition is met (such as a minimum reduction in RSS).</li>
</ul>
<ol start="6" style="list-style-type: decimal">
<li>Once the regions <span class="math inline">\(R_1, R_2, \ldots, R_J\)</span> have been created, the tree is complete. To make a prediction for a new observation, find which region it falls into (by following the tree’s decision rules) and assign it the mean response value of that region, computed from the training data.</li>
</ol>
<p><strong>Limitations to Regression Decision Tree</strong></p>
<p>The tree presented is likely an over-simplification of the real, potentially complex, relationship among predictors. It does not capture interactions or nuances beyond the splits used.</p>
<p><strong>Advantages to Regression Decision Tree</strong></p>
<ul>
<li>They are easy to interpret from the path from the root to any leaf and can be described in plain language. Graphical representation makes it clear how predictions are made and which features matter most in different regions.<br />
</li>
<li>Compared to other regression models (such as linear regression, polynomial regression, or more flexible models) may fit the data more closely, but are often harder to interpret than a simple tree.  </li>
</ul>
<div id="pruning" class="section level6 hasAnchor" number="5.2.8.1.2.1">
<h6><span class="header-section-number">5.2.8.1.2.1</span> Pruning<a href="statistical-inference.html#pruning" class="anchor-section" aria-label="Anchor link to header"></a></h6>
<p>The process described above may produce good predictions, but is likely to overfit the data. This is where we can introduce tree pruning to balance the fit and complexity.</p>
<p>The overfitting occurs because as we continue to split on the training data, the tree will typically make very accurate predictions on the training set (“training error” is low), but it will likely perform poorly on new, unseen data (high “test error”) because it has captured too much of the idiosyncratic noise in the training data—a phenomenon known as overfitting.</p>
<p>There is a trade-off between complexity and generalization. A smaller tree (with fewer splits and larger regions) generally has:</p>
<ul>
<li>Lower variance: Its predictions are less sensitive to small changes in the training data, so its test error is often lower. </li>
<li>Greater interpretability: It’s easier to visualize and understand.<br />
</li>
<li>Slightly higher bias: It may be less accurate on the training data because it doesn’t fit all the fine details.</li>
</ul>
<p>Therefore, the goal is to find a tree size (number of splits/leaves) that best balances good generalization (low test error) with simplicity and interpretability.</p>
<p><strong>Naive Stopping Strategy</strong></p>
<p>One naive strategy is to stop growing the tree once the reduction in RSS at each split falls below a threshold (i.e., only split if the improvement is “large enough”). This can prevent overfitting by not making splits that don’t help much. The limitation from this approach can be shortsighted. Sometimes, an early split may not seem helpful (little reduction in RSS), but necessary to enable a later, very helpful split. If we don’t allow the early split, we may miss important structure in the data.</p>
<p><strong>Grow Large, Then Prune Strategy</strong></p>
<p>The preferred approach is to grow a large tree first, allowing many splits, even those that seem only marginally useful. Once the large tree (<span class="math inline">\(T_0\)</span>​) is built, we then prune it back, removing splits and branches to produce a series of smaller subtrees. Each subtree is defined by a subset of the splits of the original large tree. The goal is to find the subtree that gives the best performance on new data, i.e., the lowest test error rate.</p>
<p>The subtree selection, aka, the pruning process starts with an estimate of how well it will predict on new, unseen data. This is done by using methods such as cross-validation or a validation set to measure the prediction error on data not used to build the tree. There are challengees when the tree is enormous, as there are an enormous number of possible subtrees, so it’s not feasible to check them all.</p>
<p>To efficiently search for good subtrees, we use a procedure called cost complexity pruning (also known as weakest link pruning). Rather than examining every possible subtree, we consider a sequence of subtrees defined by a tuning parameter <span class="math inline">\(\alpha\)</span>.</p>
<p>For each value of <span class="math inline">\(\alpha\)</span>, we define a measure:<br />
</p>
<p><span class="math display">\[
        \sum_{m=1}^{|T|} \sum_{i: x_i \in R_m} (y_i - \hat{y}_{R_m})^2 + \alpha |T|
        \]</span></p>
<ul>
<li>The first term is the total RSS (fit to the training data).  </li>
<li>The second term penalizes large trees (<span class="math inline">\(|T|\)</span> is the number of terminal nodes in the tree), with the strength of the penalty determined by <span class="math inline">\(\alpha\)</span>.</li>
<li>When <span class="math inline">\(\alpha = 0\)</span>, we get the fully grown tree (no penalty for complexity).</li>
<li>As <span class="math inline">\(\alpha\)</span> increases, the penalty for extra leaves grows, so optimal trees become smaller and simpler.</li>
</ul>
<p>As you increase <span class="math inline">\(\alpha\)</span> from zero, branches are pruned from the fully grown tree in a nested, predictable fashion, so that for each <span class="math inline">\(\alpha\)</span>, there’s a single best subtree. The process yields a sequence of trees, ranging from the largest (unpruned) tree to the smallest (just a root node).</p>
<p>To pick the optimal value of <span class="math inline">\(\alpha\)</span>, and hence the best subtree, we use K-fold cross-validation:</p>
<ol style="list-style-type: decimal">
<li>Split the data into <span class="math inline">\(K\)</span> roughly equal parts (“folds”).<br />
</li>
<li>For each fold:<br />

<ul>
<li>Grow a large tree and prune it using the remaining <span class="math inline">\(K-1\)</span> folds.<br />
</li>
<li>Use the left-out fold to estimate the prediction error for each candidate subtree. </li>
</ul></li>
<li>Repeat for all folds and average the error for each subtree (or each value of <span class="math inline">\(\alpha\)</span>).<br />
</li>
<li>Choose the value of <span class="math inline">\(\alpha\)</span> that minimizes the average cross-validated prediction error.<br />
</li>
<li>Return the subtree corresponding to this optimal <span class="math inline">\(\alpha\)</span>.</li>
</ol>
<p>Other considerations:<br />
- The penalty parameter <span class="math inline">\(\alpha\)</span> controls the trade-off between goodness of fit (low RSS) and simplicity (small number of leaves).
- This is analogous to regularization in linear models (like Lasso), where a penalty term discourages overfitting by shrinking coefficients or reducing the number of predictors.
- As <span class="math inline">\(\alpha\)</span> increases, the selected tree becomes smaller, prioritizing generalization over fitting every detail of the training data. The sequence of pruned subtrees is nested. As you prune, each smaller tree is a subset of the previous larger tree.</p>
</div>
</div>
<div id="classification-trees" class="section level5 hasAnchor" number="5.2.8.1.3">
<h5><span class="header-section-number">5.2.8.1.3</span> Classification Trees<a href="statistical-inference.html#classification-trees" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>A classification tree is a type of decision tree used specifically for predicting outcomes that are qualitative or categorical—meaning the responses fall into distinct classes or groups (for example, “spam” vs “not spam,” “disease” vs “no disease,” etc.). This is in contrast to a regression tree, which is used when the predicted outcome is quantitative or numerical (for example, predicting a person’s income or the price of a house).</p>
<p>Key differences:</p>
<p>In a regression tree, for any input, the tree outputs the mean value of the training observations in the terminal node (final leaf) where the input belongs.
In a classification tree, the output is the most frequently occurring class among the training observations in the terminal node where the input falls.</p>
<p>General Example:
Suppose you want to predict whether a customer will buy a product (“Yes” or “No”) based on their age and income. A classification tree will assign each customer to the most common class (“Yes” or “No”) among similar customers (those in the same terminal node), while a regression tree would predict an average value (like expected spending).</p>
<p>Interpreting Classification Trees
When using classification trees, two things are of interest:</p>
<p>Class Prediction: For each region (i.e., each terminal node of the tree), the tree predicts the most common class among the training data in that region.
Class Proportions: Besides just the predicted class, we often also care about the proportion of each class in a region. For example, if a node has 90% “Yes” and 10% “No,” we’re more confident in predicting “Yes” than if the split was 51% to 49%.</p>
<p>Growing the Tree: Binary Splitting
Both regression and classification trees are built using a process called recursive binary splitting:</p>
<p>At each step, the data is split into two groups (“binary”), based on some criterion, to maximize the “purity” of the resulting groups.
This continues until a stopping criterion is reached (like each node has a minimum number of observations, or a maximum depth).</p>
<p>Which Criterion to Use?</p>
<p>Regression Trees: Commonly use Residual Sum of Squares (RSS) to decide where to split.
Classification Trees: RSS is not suitable, so other metrics are used.</p>
<p>Classification Error Rate
The classification error rate is a simple measure of how often a randomly chosen observation in a region does not belong to the most common class in that region.</p>
<p><span class="math display">\[
E = 1 - \max_k(\hat{p}_{mk}),
\]</span>
where:</p>
<ul>
<li><span class="math inline">\(\hat{p}_{mk}\)</span> is the proportion of training observations in node <span class="math inline">\(m\)</span> belonging to class <span class="math inline">\(k\)</span>.</li>
<li><span class="math inline">\(\max_k(\hat{p}_{mk})\)</span> gives the highest class proportion (i.e., the most common class in the node).</li>
</ul>
<p>Generalized Example:</p>
<p>If a node has 80% “A” and 20% “B,” then <span class="math inline">\(E = 1 - 0.8 = 0.2\)</span>.
This means 20% of the training data in that region would be misclassified if we always predict the most common class.</p>
<p>Node Purity and Alternative Metrics
Classification error rate, while intuitive, is not very sensitive for splitting decisions. Two main alternatives are used in practice because they are more sensitive to how mixed or pure a node is:
1. Gini Index</p>
<p><span class="math display">\[
G = \sum_{k=1}^K \hat{p}_{mk}(1 - \hat{p}_{mk})
\]</span></p>
<ul>
<li><span class="math inline">\(K\)</span> is the number of possible classes.
Measures the “total variance” among the class proportions.
Node purity: If a node contains only one class (<span class="math inline">\(\hat{p}_{mk} = 1\)</span> for some <span class="math inline">\(k\)</span>), the Gini index is 0 (maximum purity).</li>
</ul>
<p>If classes are mixed (<span class="math inline">\(\hat{p}_{mk}\)</span> are closer to each other), the index is higher (less pure).
Used to evaluate the quality of a split—lower is better.</p>
<p>Generalized Example:</p>
<p>For a node with 50% “A” and 50% “B” <span class="math inline">\(\hat{p}_{mA} = 0.5\)</span>, <span class="math inline">\(\hat{p}_{mB} = 0.5\)</span>
<span class="math display">\[
  G = 0.5(1-0.5) + 0.5(1-0.5) = 0.25 + 0.25 = 0.5
  \]</span></p>
<p>For a pure node (100% “A”)
<span class="math display">\[
  G = 1(1-1) + 0(1-0) = 0 + 0 = 0
  \]</span></p>
<ol start="2" style="list-style-type: decimal">
<li>Entropy (Cross-Entropy or Information Gain)</li>
</ol>
<p><span class="math display">\[
D = -\sum_{k=1}^{K} \hat{p}_{mk} \log \hat{p}_{mk}
\]</span></p>
<ul>
<li>Measures disorder or uncertainty. Entropy is 0 if a node is pure (one class only).</li>
<li>Like the Gini index, lower entropy means higher purity.</li>
<li>Used extensively, especially in algorithms like ID3 and C4.5.</li>
</ul>
<p>Generalized Example:</p>
<p>For a node with all observations in one class:
<span class="math display">\[
  D = -1 \log 1 = 0
  \]</span></p>
<p>For a node with equal proportions <span class="math inline">\(\hat{p}_{mA} = 0.5, \hat{p}_{mB} = 0.5\)</span>:</p>
<p><span class="math display">\[
  D = -0.5 \log 0.5 - 0.5 \log 0.5 = -0.5(-0.693) - 0.5(-0.693) = 0.693
  \]</span></p>
<p>Why Prefer Gini or Entropy Over Error Rate?
The Gini index and entropy are more sensitive to changes in the node’s composition than the classification error rate. This sensitivity helps the tree algorithm to make better splits by favoring splits that increase the purity of the resulting nodes, even if the most common class does not change.</p>
<p>Importance of Node Purity
Node purity is crucial because:</p>
<p>Higher purity nodes mean more confident predictions.
Even if both child nodes after a split predict “Yes,” one might be 100% “Yes,” while the other is only 70% “Yes.” Predictions from the pure node are more reliable.</p>
<p>Summary of Key Points (without summarizing the text):</p>
<p>Classification trees predict qualitative outcomes by assigning new observations to the most common class in their region.
The tree is grown by recursive binary splitting, guided by measures of node impurity (Gini index, entropy), not just classification error rate.
Gini index and entropy are sensitive to how “mixed” or “pure” a node is, making them preferable for tree growth.
Trees can handle both continuous and categorical predictors.
Splits that increase node purity are valuable, even if they do not change the most common class, because they yield more confident predictions.</p>
</div>
<div id="trees-versus-linear-models" class="section level5 hasAnchor" number="5.2.8.1.4">
<h5><span class="header-section-number">5.2.8.1.4</span> Trees Versus Linear Models<a href="statistical-inference.html#trees-versus-linear-models" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>Model Assumptions
Linear Regression Model:
Linear regression is a classical statistical method that assumes the relationship between the input variables (features) and the output (response) can be modeled as a linear combination of the features. The general mathematical form is:
<span class="math display">\[
f(X) = \beta_0 + \sum_{j=1}^{p} X_j \beta_j
\]</span>
- <span class="math inline">\(X_j\)</span>: The value of the <span class="math inline">\(j\)</span>-th feature (input variable) for a given observation.  
- <span class="math inline">\(\beta_j\)</span>: The coefficient representing the effect of the <span class="math inline">\(j\)</span>-th feature on the response.<br />
- <span class="math inline">\(\beta_0\)</span>: The intercept term.<br />
- <span class="math inline">\(p\)</span>: The number of features.<br />
</p>
<p>This model assumes that as you change <span class="math inline">\(X_j\)</span> by one unit, the output <span class="math inline">\(f(X)\)</span> changes by exactly <span class="math inline">\(\beta_j\)</span> units, holding all other features constant. The relationship is strictly additive and linear.</p>
<p>Regression Tree Model:
Regression trees (and, by extension, classification trees) make no assumption of linearity. Instead, they partition the feature space into distinct regions and assign a constant prediction to each region. The model can be written as:</p>
<p><span class="math display">\[
f(X) = \sum_{m=1}^{M} c_m \cdot 1_{(X \in R_m)}
\]</span></p>
<ul>
<li><span class="math inline">\(R_m\)</span>: The m-th region, which is a subset of the feature space as defined by the splits in the tree.</li>
<li><span class="math inline">\(c_m\)</span>: The predicted value for region <span class="math inline">\(R_m\)</span> (e.g., the mean response for regression, or the most common class for classification).</li>
<li><span class="math inline">\(1_{(X \in R_m)}\)</span>: An indicator function that is 1 if <span class="math inline">\(X\)</span> is in region <span class="math inline">\(R_m\)</span>​, and 0 otherwise.</li>
<li><span class="math inline">\(M\)</span>: The number of terminal nodes (leaves) in the tree.</li>
</ul>
<p>The tree divides the feature space into non-overlapping regions, and any observation falling into a given region gets the same prediction, regardless of the exact values of its features (as long as they fall within that region).</p>
<p>Which Model is Better?
The text emphasizes that the choice between linear models and tree-based models depends on the nature of the relationship between features and response:</p>
<ol style="list-style-type: decimal">
<li><p>When Linear Models Work Best:
If the relationship is truly linear or well-approximated by a linear function (i.e., the effect of each feature on the response is additive and constant), then linear regression is preferable. It leverages the linear structure, yielding more accurate and efficient predictions.</p></li>
<li><p>When Trees Work Best:
If the relationship is complex or highly non-linear—meaning the effect of features on response changes depending on the values of other features, or involves abrupt jumps or different regimes—then trees can be superior, since they are able to model such complexity by dividing the feature space into arbitrary regions.</p></li>
</ol>
<p>Partitioning Feature Space
Trees work by dividing the input (feature) space into rectangular regions, each associated with a constant prediction. Each split is defined by a rule on a single feature—e.g., “if <span class="math inline">\(X_1 &lt; 0\)</span>, go left; else, go right.” This axis-aligned splitting leads to rectangular (or box-shaped) regions in two or more dimensions.</p>
<p>Assessing Model Performance
The text suggests that model performance should be evaluated empirically, using metrics such as test error, which estimates how well the model will generalize to new, unseen data. Cross-validation and validation set approaches are standard ways to estimate this error.</p>
<p>Beyond Test Error: Interpretability and Visualization
Besides predictive performance, other factors can influence the choice between trees and linear models:</p>
<p>Interpretability: Trees often provide more interpretable models, especially for non-technical audiences. The sequence of splits can be visualized as a flow chart or tree diagram, making it easy to explain decision logic.
Visualization: Trees naturally produce visualizations that show how the feature space is partitioned, which is helpful for understanding and communicating the model.</p>
<p>Linear models assume and exploit a linear relationship, resulting in additive effects and straight-line decision boundaries.
Trees partition the feature space into regions, allowing for complex, nonlinear, and interaction effects, but with step-like boundaries.
The best model depends on the true nature of the data: linear models for linear relationships; trees for nonlinear or interaction-heavy relationships.
Model choice should be guided by performance (test error), but also by interpretability and visualization needs.</p>
</div>
<div id="advantages-and-disadvantages-of-trees" class="section level5 hasAnchor" number="5.2.8.1.5">
<h5><span class="header-section-number">5.2.8.1.5</span> Advantages and Disadvantages of Trees<a href="statistical-inference.html#advantages-and-disadvantages-of-trees" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<ol style="list-style-type: decimal">
<li>Trees are very easy to explain to people. In fact, they are even easier to explain than linear regression!
Deep Explanation:
Decision trees work by making a series of simple decisions, each based on the value of a single feature. At each step, you answer a yes/no or categorical question about the data (for example: “Is income greater than $50,000?” or “Is the color red?”), and move down the tree accordingly until you reach a final prediction at a terminal node (leaf).</li>
</ol>
<p>This process mimics the way people often make decisions in everyday life—by following a sequence of conditional rules.
Each split in the tree is easy to understand on its own: you don’t need to understand complex mathematics or interpret coefficients.
In contrast, linear regression requires understanding how each feature contributes to the outcome through its coefficient, which can be less intuitive, especially when there are many variables or when the variables are correlated.</p>
<ol start="2" style="list-style-type: decimal">
<li>Some people believe that decision trees more closely mirror human decision-making than do the regression and classification approaches seen in previous chapters.
Deep Explanation:
Humans often naturally make decisions by breaking down complex choices into a sequence of simpler ones, focusing on one factor at a time. Decision trees replicate this process:</li>
</ol>
<p>Each split considers a single factor and its value, just as a human might evaluate one aspect of a situation before moving to the next.
The tree’s structure—starting from a root and splitting into branches—resembles the way people follow a set of “if-then-else” rules.
This resemblance to human reasoning makes trees feel more “natural” and relatable.</p>
<ol start="3" style="list-style-type: decimal">
<li>Trees can be displayed graphically, and are easily interpreted even by a non-expert (especially if they are small).
Deep Explanation:
Decision trees can be visualized as branching diagrams, where each internal node represents a split, each branch represents a possible outcome of the split, and each leaf node represents a prediction.</li>
</ol>
<p>This visual format is accessible and can be understood without specialized training.
Small trees especially can be drawn on paper or a whiteboard, making them practical for presentations or team discussions.
Visualizing the flow from root to leaf helps non-experts trace the logic leading to any prediction.</p>
<ol start="4" style="list-style-type: decimal">
<li>Trees can easily handle qualitative predictors without the need to create dummy variables.
Deep Explanation:
Many real-world datasets contain categorical (qualitative) variables, such as color, type, or category. Classical methods like linear regression require these to be converted into numeric forms—typically by creating “dummy” or “indicator” variables (one for each category level).</li>
</ol>
<p>Decision trees, by contrast, can split directly on categorical variables, assigning different branches to different categories.
There is no need for preprocessing or transformation; the tree inherently deals with both numeric and categorical predictors.</p>
<p>Disadvantages of Decision Trees
1. Trees generally do not have the same level of predictive accuracy as some of the other regression and classification approaches seen in this book.
Deep Explanation:
While trees are intuitive and easy to use, they often do not perform as well as more sophisticated models in terms of prediction accuracy. Reasons include:</p>
<p>Trees make sharp splits in the data, which can lead to overfitting—fitting noise rather than signal, especially with small or noisy datasets.
Single trees may not capture subtle relationships between variables that more flexible or ensemble methods (like random forests, boosting, or even well-tuned linear models) can exploit.
Other methods can smooth over the data, reducing variance and capturing more complex relationships, leading to better predictions on new data.</p>
<ol start="2" style="list-style-type: decimal">
<li>Trees can be very non-robust. In other words, a small change in the data can cause a large change in the final estimated tree.
Deep Explanation:
Trees are sensitive to the specific data used to build them:</li>
</ol>
<p>If the training data changes slightly—such as by adding or removing a few observations, or if a single value is changed—the structure of the resulting tree can change drastically. This is called instability or lack of robustness.
The splits chosen at each step depend heavily on the data available, and a small change early in the tree can propagate through all subsequent splits, leading to an entirely different tree.
This instability can reduce confidence in the model, especially when explanations need to be consistent across different samples.</p>
<p>Aggregating Trees: Overcoming Limitations
Deep Explanation:
To address the weaknesses of single decision trees, ensemble methods aggregate the predictions of many trees to improve performance and stability:</p>
<p>Bagging (Bootstrap Aggregating): Multiple trees are built on different random samples of the training data; their predictions are averaged (for regression) or voted on (for classification).
Random Forests: An extension of bagging that also randomizes which features are considered at each split, further reducing correlation among trees.
Boosting: Trees are built sequentially, each focusing on correcting errors made by previous ones. Their predictions are combined for better accuracy.</p>
<p>These ensemble methods result in models that are more accurate and robust than a single tree, often rivaling or exceeding the performance of other advanced algorithms.</p>
</div>
</div>
<div id="bagging-random-forest-boosting" class="section level4 hasAnchor" number="5.2.8.2">
<h4><span class="header-section-number">5.2.8.2</span> Bagging, Random Forest, Boosting<a href="statistical-inference.html#bagging-random-forest-boosting" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>This section introduces ensemble methods, which combine many simple models (called weak learners, such as regression or classification trees) to create a more powerful predictive model. The section will cover specific ensemble methods: bagging, random forests, boosting, and Bayesian additive regression trees.</p>
<div id="bagging" class="section level5 hasAnchor" number="5.2.8.2.1">
<h5><span class="header-section-number">5.2.8.2.1</span> Bagging<a href="statistical-inference.html#bagging" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>The Bootstrap and Its Role in Bagging
Bootstrap Overview:
The bootstrap is a statistical technique that involves repeatedly sampling (with replacement) from a dataset to create multiple new samples, known as “bootstrap samples.” Originally, the bootstrap was developed to estimate the variability (such as standard deviation or confidence intervals) of a statistic when the underlying distribution is unknown or when direct calculation is too difficult.</p>
<p>High Variance in Decision Trees
Variance in Statistical Models:
Variance refers to how much a model’s predictions would change if it were trained on a different dataset from the same process. High variance means small changes in the data can lead to large changes in the model.</p>
<p>Decision Trees:
Decision trees are especially prone to high variance. If you randomly split your data in half, fit a tree to each half, the resulting trees could be very different—choosing different variables and splits, and producing different predictions.</p>
<p>Contrast With Low Variance Methods:
Methods like linear regression (when the sample size n is much larger than the number of predictors p) tend to have low variance, so results are stable across different samples of the data.</p>
<p>The Principle of Bagging (Bootstrap Aggregation)
Bagging Purpose:
Bagging is a general approach to reducing the variance of a model. The idea is to take multiple models, each trained on a different sample of the data, and average their predictions.</p>
<p>Mathematical Foundation:
Suppose you have <span class="math inline">\(n\)</span> independent measurements <span class="math inline">\(Z_1, Z_2, \ldots, Z_n\)</span> each with variance <span class="math inline">\(\sigma^2\)</span>. The variance of their mean, <span class="math inline">\(\bar{Z}\)</span>, is <span class="math inline">\(\sigma^2 / n\)</span>. Thus, averaging reduces variance.</p>
<p>Extension to Models:
If you could train <span class="math inline">\(B\)</span> separate models, each on a different independent dataset, and average their predictions, you would get a result with much lower variance than any individual model.</p>
<p><span class="math display">\[
\hat{f}_{\mathrm{avg}}(x) = \frac{1}{B} \sum_{b=1}^B \hat{f}^b(x)
\]</span></p>
<p>where <span class="math inline">\(\hat{f}^b(x)\)</span> is the prediction from the <span class="math inline">\(b\)</span>-th model.</p>
<p>Practical Bagging With Bootstrapping
Limitation:
In reality, we don’t have multiple independent datasets; we typically have only one.
Solution:
We use the bootstrap:</p>
<p>From the original dataset, generate B bootstrap samples (random samples with replacement).
Train a separate model (e.g., a decision tree) on each bootstrap sample.
For prediction, average the predictions of all models (for regression), or use majority vote (for classification).</p>
<p><span class="math display">\[
\hat{f}_{\mathrm{bag}}(x) = \frac{1}{B} \sum_{b=1}^B \hat{f}^{*b}(x)
\]</span></p>
<p>where <span class="math inline">\(\hat{f}^{*b}(x)\)</span> is the prediction from the model trained on the <span class="math inline">\(b\)</span>-th bootstrap sample.</p>
<p>Bagging for Decision Trees
Why It’s Useful:
Decision trees are particularly suited for bagging because:</p>
<p>Each tree, grown deep and unpruned, has high variance (unstable, sensitive to data).
Averaging many such trees dramatically reduces variance, leading to more reliable predictions.
Each tree individually may overfit, but their average prediction is much more stable.</p>
<p>Practical Implementation:</p>
<p>Construct <span class="math inline">\(B\)</span> deep, unpruned regression trees, each on a different bootstrap sample.
For regression: average the predictions of all <span class="math inline">\(B\)</span> trees.
For classification: for each test observation, record the predicted class from each tree, and use the most common class (majority vote).</p>
<p>Performance:</p>
<p>Bagging has been shown to substantially improve prediction accuracy, sometimes using hundreds or thousands of trees to produce a single robust model.
The number <span class="math inline">\(B\)</span> (number of trees) is not very sensitive; typically, using a sufficiently large <span class="math inline">\(B\)</span> (such as <span class="math inline">\(B = 100\)</span>) is enough, and large values do not cause overfitting.</p>
<p>Summary of Bagging’s Deep Principles</p>
<p>Bagging is about reducing the instability (variance) of a model by averaging many versions of it, each trained on a slightly different version of the data (via bootstrapping).
It is especially powerful for models like decision trees that are accurate but unstable.
Bagging leads to more reliable, stable, and generally more accurate predictions, without increasing the risk of overfitting as the number of trees grows.</p>
<div id="out-of-the-bag-estimation" class="section level6 hasAnchor" number="5.2.8.2.1.1">
<h6><span class="header-section-number">5.2.8.2.1.1</span> Out of the bag estimation<a href="statistical-inference.html#out-of-the-bag-estimation" class="anchor-section" aria-label="Anchor link to header"></a></h6>
<p>Out-of-Bag (OOB) Error Estimation in Bagging
The Challenge of Test Error Estimation
In predictive modeling, an important goal is to estimate how well a model will perform on new, unseen data. Traditionally, this is done using methods like:</p>
<p>Cross-validation: Partitioning the data into several subsets, repeatedly training the model on some subsets and testing it on the others.
Validation set approach: Setting aside a portion of the data only for testing.</p>
<p>However, these methods can be computationally expensive, especially when the dataset is large or when model training is slow.</p>
<p>The Structure of Bagging
Recall that bagging (bootstrap aggregation) repeatedly fits models (e.g., decision trees) to bootstrap samples of the data:</p>
<p>Bootstrap sample: A sample drawn with replacement from the original dataset, typically the same size as the original data.
Key detail: Because sampling is with replacement, about two-thirds of the original data points are included in each bootstrap sample, while about one-third are excluded.</p>
<p>Mathematical Expectation:</p>
<p>For each tree, the probability that a given observation is not selected in a bootstrap sample is <span class="math inline">\((1 - 1/n)^n\)</span>, which tends to <span class="math inline">\(e^{-1} \approx 0.37\)</span> as n becomes large. So, approximately 37% (about one-third) of the observations are not used to train each tree.</p>
<p>The Out-of-Bag (OOB) Set</p>
<p>Definition:
For each bootstrap sample used to train a tree, the observations not included in that sample are called the “out-of-bag” (OOB) observations for that tree.</p>
<p>Implication:
Each observation in the dataset will be OOB for about one-third of the trees in a bagged ensemble of B trees. For example, if you build 150 bagged trees, each observation will be left out of around 50 trees.</p>
<p>Constructing OOB Predictions</p>
<p>For each observation i, consider all trees for which observation i was OOB (i.e., not used in training that tree).
For each of these trees, make a prediction for observation i.
Aggregate these predictions:</p>
<p>Regression problem: Average the predictions from all the OOB trees for observation i.
Classification problem: Take a majority vote among the OOB tree predictions for observation i.</p>
<p>This results in a single OOB prediction for each observation.</p>
<p>Calculating the OOB Error</p>
<p>Once you have an OOB prediction for every observation in the dataset, you can compare these predictions to the true values.
Calculate the overall error:</p>
<p>For regression: Compute the mean squared error (MSE) between actual values and OOB predictions.
For classification: Compute the classification error rate (fraction of misclassified observations) using the OOB predictions.</p>
<p>This overall error is called the OOB error.</p>
<p>Why OOB Error Is a Valid Test Error Estimate</p>
<p>Independence:
For each observation, its OOB prediction is made using only trees that did not see that observation during training. This is conceptually similar to cross-validation, where you test on data not used for training.
Efficiency:
OOB error estimation does not require explicit data splitting or repeated model retraining—it is a natural byproduct of the bagging process.
Equivalence:
With a large enough number of trees (B), the OOB error closely approximates the error you would get from leave-one-out cross-validation, where each observation is left out once.</p>
<p>Practical Advantages</p>
<p>No Need for Separate Validation Set:
OOB error uses all available data for both training and error estimation, maximizing data efficiency.
Computationally Efficient:
Especially valuable when working with large datasets, where traditional cross-validation would require retraining the model many times, greatly increasing computational cost.
Continuous Monitoring:
As you build more trees, you can monitor the OOB error to determine when adding more trees no longer improves performance.</p>
<p>Summary of Deep Principles</p>
<p>OOB error estimation is a built-in, efficient, and unbiased method for assessing the predictive performance of bagged ensemble models.
It leverages the structure of the bagging process, requiring no extra data or computational effort compared to traditional cross-validation.
OOB error is especially useful for large datasets and complex models, where computational efficiency and data maximization are critical.</p>
</div>
<div id="variable-importance-measures" class="section level6 hasAnchor" number="5.2.8.2.1.2">
<h6><span class="header-section-number">5.2.8.2.1.2</span> Variable importance Measures<a href="statistical-inference.html#variable-importance-measures" class="anchor-section" aria-label="Anchor link to header"></a></h6>
<p>Single Decision Tree Interpretability
One of the greatest strengths of a single decision tree is interpretability:</p>
<p>The tree can be visualized as a flowchart or diagram, where the path from the root to a leaf represents a sequence of splits on different variables.
By examining the tree, you can easily see which variables are used for splits, at what thresholds, and in what order, giving a clear, visual sense of how predictions are made and which variables are most influential.
For example, in a medical diagnosis tree, you could see that “Age &gt; 60” or “Blood Pressure &gt; 140” are key decision points.</p>
<p>Loss of Interpretability in Bagging
When you use bagging (bootstrap aggregation) to improve predictive accuracy:</p>
<p>Instead of a single tree, you have a large collection of trees (hundreds or thousands).
Each tree is built on a different bootstrap sample of the data, leading to different splits and variable usage across the ensemble.
As a result, you can no longer visualize the model as a single tree or easily identify which variables are most important just by looking at a diagram.
The price you pay for improved accuracy and stability is reduced interpretability: the model becomes a “black box,” and you lose the straightforward understanding of variable roles that a single tree provides.</p>
<p>Quantifying Variable Importance in Bagged Trees
Despite the complexity of the ensemble, it is still possible to summarize the overall importance of each predictor variable across all the trees. This is done using statistical measures that aggregate information from all trees:</p>
<p>For Regression Trees: Residual Sum of Squares (RSS)</p>
<p>RSS Definition:
In regression, RSS measures the total squared difference between the observed values and the predicted values.
Variable Importance Calculation:
For each tree, every time a split is made on a predictor variable, that split reduces the RSS for the training data in that node. The decrease in RSS for that split is credited to the variable used for the split.
Aggregation:
For each variable, sum all RSS decreases attributed to that variable across all splits and all trees, then average over the number of trees For Regression Trees: Residual Sum of Squares (RSS)</p>
<p>RSS Definition:
In regression, RSS measures the total squared difference between the observed values and the predicted values.
Variable Importance Calculation:
For each tree, every time a split is made on a predictor variable, that split reduces the RSS for the training data in that node. The decrease in RSS for that split is credited to the variable used for the split.
Aggregation:
For each variable, sum all RSS decreases attributed to that variable across all splits and all trees, then average over the number of trees .
Interpretation:
A large total decrease in RSS for a variable means that splits on this variable frequently and substantially help to explain (predict) the response variable, indicating high importance.</p>
<p>For Classification Trees: Gini Index</p>
<p>Gini Index Definition:
The Gini index is a measure of node impurity in classification trees. A lower Gini index means the node is more pure (contains mostly one class).
Variable Importance Calculation:
For each split in each tree, when a variable is used to split a node, the Gini index for that node decreases (the node becomes purer). The decrease in Gini index is attributed to the variable used.
Aggregation:
Sum up the total decrease in Gini index for each variable across all splits and all trees, then average over all <span class="math inline">\(B\)</span> trees.
Interpretation:
A variable that consistently reduces the Gini index by a large amount is important for classifying the data correctly.</p>
<p>Visualizing Variable Importance</p>
<p>After computing the variable importance scores, you can create a plot (such as a bar chart) showing the relative importance of each variable.
The height of each bar represents the mean decrease in RSS (for regression) or Gini index (for classification) attributed to that variable, relative to the largest value.
Variables with the largest mean decreases are the most important in the ensemble model.</p>
</div>
</div>
<div id="random-forest" class="section level5 hasAnchor" number="5.2.8.2.2">
<h5><span class="header-section-number">5.2.8.2.2</span> Random Forest<a href="statistical-inference.html#random-forest" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>The Motivation for Random Forests
Bagging (bootstrap aggregation) improves the prediction accuracy of unstable models like decision trees by averaging the predictions of many trees, each built on a different bootstrap sample. However, bagged trees—while reducing variance—can still be highly correlated with each other if some predictors are very strong.</p>
<p>Correlation Among Trees:
If one feature in your dataset is extremely predictive, almost every tree in the bagged ensemble will split first (or high up) on that feature. This causes most of the trees to look similar and make similar mistakes or successes, thus their errors are correlated.
Effect on Variance Reduction:
Averaging reduces variance most effectively when the individual elements being averaged are uncorrelated. Averaging highly correlated predictions does not yield as much variance reduction as averaging uncorrelated ones.</p>
<p>The Key Innovation: Decorrelating the Trees
Random forests introduce a simple but powerful tweak to reduce the correlation among trees:</p>
<p>At each split in each tree, do not consider all predictors as candidates for the split.
Instead, randomly select a subset of <span class="math inline">\(m\)</span> predictors (out of the full set of <span class="math inline">\(p\)</span> predictors), and only allow the split to be made on one of those <span class="math inline">\(m\)</span> predictors.
This process is repeated independently at every split in every tree, and a new random subset of <span class="math inline">\(m\)</span> predictors is chosen for each split.</p>
<p><strong>Typical Choice for <span class="math inline">\(p\)</span>:</strong></p>
<p>For classification problems, it is common to use <span class="math inline">\(m \approx \sqrt{p}\)</span>​, where <span class="math inline">\(p\)</span> is the total number of predictors.
For regression, often <span class="math inline">\(m \approx p/3\)</span>.</p>
<p><strong>Why Randomly Limit Split Candidates?</strong>
This restriction may seem counterintuitive—why not use the best variable at every split? But it has a clear and important rationale:</p>
<p>Suppose there is one very strong predictor and several moderately strong ones.
In bagging, almost every tree will select the strongest predictor for its top split, causing the trees to be similar and their predictions to be correlated.
In random forests, because only a random subset of predictors is considered at each split, the strong predictor is often not even among the candidates. This gives other predictors a chance to be used for splits, leading to more diverse trees.</p>
<p><strong>The Effect: More Diverse, Less Correlated Trees</strong></p>
<p>Increased Diversity:
By forcing trees to consider different subsets of predictors, random forests ensure that the trees in the ensemble are more varied in their structure, splits, and predictions.
Decreased Correlation:
Because the trees are less likely to always split on the same dominant variables, their errors are less likely to be correlated.
Greater Variance Reduction:
Averaging these less correlated predictions results in a greater reduction in variance of the ensemble’s prediction compared to bagging, improving predictive performance and reliability.</p>
<p>Mathematical/Algorithmic Process</p>
<ol style="list-style-type: decimal">
<li>Bootstrap Sampling:<br />
As in bagging, generate <span class="math inline">\(B\)</span> bootstrap samples from the data.</li>
<li>Tree Construction:<br />
</li>
</ol>
<ul>
<li>For each bootstrap sample, grow an unpruned decision tree.
<ul>
<li>At each node, randomly select m predictors (from the total <span class="math inline">\(p\)</span> predictors).</li>
<li>Find the best split among only these <span class="math inline">\(m\)</span> predictors.</li>
<li>Repeat until the tree is fully grown (no pruning).</li>
</ul></li>
</ul>
<p><strong>Prediction Aggregation:</strong>
- For regression: average the predictions of all trees.<br />
- For classification: use majority vote among the trees.</p>
<p>Insights and Implications</p>
<p>Random forests generalize bagging:
If you set m=p, random forests reduce to bagging.
Choosing m is key:
Smaller m increases tree diversity and reduces prediction correlation, but if m is too small, important predictors may be ignored too often, reducing predictive power.
No Need to Worry About Overfitting by Increasing B:
Like bagging, random forests do not overfit as more trees are added; use as many trees as needed until the error rate stabilizes.
Powerful for Many Predictors and Correlated Data:
Random forests are especially effective in settings with many predictors and strong correlations among them, such as biological data with thousands of genes, financial prediction with many indicators, or image classification with many pixels.
Summary of Deep Principles</p>
<p>Random forests improve upon bagging by decorrelating trees through random predictor selection at each split.
This decorrelation increases the effectiveness of variance reduction through averaging, leading to more reliable, accurate models, especially when predictors are correlated.
Random forests are robust, perform well on complex data, and can handle large numbers of predictors without overfitting as the number of trees grows.</p>
</div>
<div id="boosting" class="section level5 hasAnchor" number="5.2.8.2.3">
<h5><span class="header-section-number">5.2.8.2.3</span> Boosting<a href="statistical-inference.html#boosting" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>What is BART (Bayesian Additive Regression Trees)?
BART is an ensemble method that uses decision trees as its basic building blocks to model complex relationships in data, especially for regression problems. While related to bagging, random forests, and boosting, BART introduces a unique Bayesian perspective and a different way to generate and update trees.</p>
<p>How Do Bagging, Random Forests, and Boosting Relate to BART?</p>
<p>Bagging and Random Forests:
These methods create an ensemble by averaging the predictions of many individual regression trees. Each tree is built independently (separately) using random samples of data (and/or predictors). The final prediction is simply the average (for regression) or majority vote (for classification) across all trees.</p>
<p>Boosting:
This approach builds trees sequentially, not independently. Each new tree is trained to correct the errors (residuals) made by the ensemble so far. The final model is a weighted sum of all trees, with each tree focusing on what previous trees missed.</p>
<p>BART’s Position:
BART borrows ideas from both:</p>
<p>Like bagging and random forests, each tree is built using randomness.
Like boosting, each tree tries to capture signal not yet accounted for by the ensemble so far.
The key novelty is in how BART generates and updates its trees, integrating a Bayesian framework.</p>
<p>BART Algorithm: Mathematical and Procedural Details
Let’s walk through the BART algorithm, step-by-step, using the notation and formulas from the text:
Notation and Initialization</p>
<p>Let <span class="math inline">\(K\)</span> be the number of regression trees in the ensemble.
Let <span class="math inline">\(B\)</span> be the number of algorithm iterations (draws).
For each tree <span class="math inline">\(k\)</span> and iteration <span class="math inline">\(b\)</span>, <span class="math inline">\(\hat{f}_k^b(x)\)</span> is the prediction at input <span class="math inline">\(x\)</span> from the <span class="math inline">\(k\)</span>th tree at the <span class="math inline">\(b\)</span>th iteration.</p>
<p>Step 1: Initialization</p>
<ul>
<li><p>At the start (first iteration), all trees are initialized to have a single root node (no splits).</p></li>
<li><p>The value at the root is set to the overall mean of the response values, divided equally among all K trees:
<span class="math display">\[
\hat{f}_k^1(x) = \frac{1}{nK} \sum_{i=1}^n y_i
\]</span></p></li>
</ul>
<p>for all <span class="math inline">\(k = 1, \ldots, K\)</span>, where <span class="math inline">\(n\)</span> is the number of data points.</p>
<p>The sum across all trees gives the overall mean:
<span class="math display">\[
  \hat{f}^1(x) = \sum_{k=1}^K \hat{f}_k^1(x) = \frac{1}{n}\sum_{i=1}^n y_i
  \]</span></p>
<p>Step 2: Sequential Iterative Updates</p>
<p>For each subsequent iteration <span class="math inline">\(b = 2, \ldots, B\)</span>, the BART algorithm updates each of the <span class="math inline">\(K\)</span> trees, one at a time.
(a) For each tree <span class="math inline">\(k\)</span>:
i. Compute the partial residuals
For each observation <span class="math inline">\(i\)</span>, calculate the partial residual:</p>
<p><span class="math display">\[
r_i = y_i - \sum_{k&#39;&lt;k} \hat{f}_{k&#39;}^b(x_i) - \sum_{k&#39;&gt;k} \hat{f}_{k&#39;}^{b-1}(x_i)
\]</span></p>
<ul>
<li><span class="math inline">\(y_i\)</span> is the observed response.</li>
<li>The first sum subtracts the predictions from all trees already updated in this iteration.</li>
<li>The second sum subtracts the predictions from all trees yet to be updated (using their values from the previous iteration).</li>
</ul>
<ol start="2" style="list-style-type: lower-roman">
<li>Update the tree by perturbation</li>
</ol>
<p>Instead of fitting a completely new tree to the residuals, BART perturbs (modifies) the current tree <span class="math inline">\(\hat{f}_k^{b-1}(x)\)</span> to improve the fit to the partial residuals.</p>
<p><strong>The perturbation can involve:</strong>
Changing the structure of the tree: by adding, removing, or changing splits (branches).
Changing the predicted values at the terminal nodes (leaves): adjusting the output values at the ends of the branches.</p>
<p>Among all possible perturbations, those that improve the fit to the partial residuals are favored, but some randomness is maintained to explore the space of possible trees.</p>
<ol start="2" style="list-style-type: lower-alpha">
<li>Aggregate the predictions</li>
</ol>
<ul>
<li>After updating all K trees for iteration b, the total prediction is:
<span class="math display">\[
\hat{f}^b(x) = \sum_{k=1}^K \hat{f}_k^b(x)
\]</span></li>
</ul>
<p>Step 3: Burn-in Period and Final Estimation</p>
<ul>
<li><p>The first L<span class="math inline">\(L\)</span>iterations are considered the “burn-in” period and are discarded, since early models may not represent a good fit.</p></li>
<li><p>The final prediction for any x is computed by averaging the predictions from the remaining <span class="math inline">\(B - L\)</span> iterations:
<span class="math display">\[
\hat{f}(x) = \frac{1}{B-L} \sum_{b=L+1}^B \hat{f}^b(x)
\]</span></p></li>
<li><p>This averaging produces the final regression estimate from the BART model.</p></li>
<li><p>Additionally, you can use the full set of post-burn-in predictions <span class="math inline">\(\{\hat{f}^{L+1}(x), \ldots, \hat{f}^B(x)\}\)</span> to compute uncertainty intervals (such as percentiles), which is a strength of the Bayesian approach.</p></li>
</ul>
<p>Algorithm 8.3: Pseudocode Summary</p>
<ol style="list-style-type: decimal">
<li><p>Initialize all trees to the same single-node tree with the overall mean response divided among trees.</p></li>
<li><p>Repeat for each iteration <span class="math inline">\(b = 2, \ldots, B\)</span></p></li>
</ol>
<ul>
<li>For each tree <span class="math inline">\(k\)</span>
<ul>
<li>Compute the partial residuals for all data points, subtracting the predictions of all other trees.</li>
<li>Propose a random perturbation to the tree (change structure or leaf values).</li>
<li>Select perturbations that improve fit to the partial residuals, but maintain randomness.</li>
</ul></li>
<li>Aggregate the predictions from all trees.</li>
</ul>
<ol start="3" style="list-style-type: decimal">
<li>After discarding <span class="math inline">\(L\)</span> burn-in iterations, average the remaining predictions to get the final model.</li>
</ol>
<p><strong>Why Does BART Work? What Are Its Strengths?</strong>
Guarding Against Overfitting:
Unlike boosting, which fits new trees as closely as possible to the residuals (potentially overfitting if too many trees are added), BART only perturbs existing trees at each step and typically keeps each tree small. This prevents any single tree from fitting the noise in the data.
Bayesian Model Averaging:
The algorithm can be interpreted as a Bayesian procedure, where the ensemble of trees is sampled from a posterior distribution, and the averaging step produces a Bayesian posterior mean prediction.
Uncertainty Quantification:
By keeping all predictions after burn-in, BART can provide not just a point estimate, but credible intervals (ranges) for predictions, reflecting model uncertainty.
Minimal Tuning Required:
BART generally performs well “out-of-the-box,” meaning you do not have to spend a lot of effort tuning hyperparameters.
Generalized Practical Scenario
Suppose you are predicting house prices based on dozens of features (size, location, age, number of rooms, etc.), and you suspect there are complex, nonlinear relationships among features and target. You want an ensemble that:</p>
<p>Captures complex patterns (like bagging/random forests/boosting)
Avoids overfitting (like boosting might do if unchecked)
Gives you a measure of uncertainty for each predicted price</p>
<p>You fit a BART model with a reasonable number of trees and iterations. The model sequentially perturbs its trees to better fit the data without overfitting, and after discarding early (“burn-in”) iterations, averages the remaining predictions for each house. You can use the spread of these predictions to form a “confidence interval” for each price estimate.</p>
<ol style="list-style-type: decimal">
<li>Additive Model Structure
BART models the regression function as a sum of <span class="math inline">\(K\)</span> regression trees:</li>
</ol>
<p><span class="math display">\[
f(x) = \sum_{k=1}^{K} g(x ; T_k, M_k)
\]</span></p>
<ul>
<li><p>Here, <span class="math inline">\(g(x; T_k, M_k)\)</span> is the prediction of the kth regression tree at input x.</p></li>
<li><p><span class="math inline">\(T_k\)</span> represents the structure of the kth tree (how it splits the input space).</p></li>
</ul>
<p><span class="math inline">\(M_k\)</span> represents the set of predicted values at the terminal nodes (leaves) of the kth tree.
The total prediction is the sum of predictions from all <span class="math inline">\(K\)</span> trees.</p>
<ol start="2" style="list-style-type: decimal">
<li>Iterative Bayesian Updating via Markov Chain Monte Carlo (MCMC)
BART uses an MCMC algorithm to sample from the posterior distribution over possible ensembles of trees. The process iteratively updates each tree, aiming to fit the residuals left by all other trees.</li>
</ol>
<p>At each MCMC iteration <span class="math inline">\(b = 1, 2, \ldots, B\)</span> and for each tree <span class="math inline">\(k = 1, \ldots, K\)</span></p>
<ol style="list-style-type: lower-alpha">
<li>Partial Residuals
For each observation <span class="math inline">\(i = 1, \ldots, n\)</span>, compute the partial residual for the <span class="math inline">\(k\)</span>th tree:
<span class="math display">\[
r_i = y_i - \sum_{k&#39; \neq k} \hat{f}_{k&#39;}(x_i)
\]</span></li>
</ol>
<p>In the BART update described in the text, this is done sequentially for each tree, so the sum over <span class="math inline">\(k&#39; &lt; k\)</span> uses current iteration values and <span class="math inline">\(k&#39; &gt; k\)</span> uses previous iteration values:</p>
<p><span class="math display">\[
r_i = y_i - \sum_{k&#39; &lt; k} \hat{f}_{k&#39;}^{b}(x_i) - \sum_{k&#39; &gt; k} \hat{f}_{k&#39;}^{b-1}(x_i)
\]</span></p>
<ol start="3" style="list-style-type: decimal">
<li>Tree Perturbation Instead of Full Refitting</li>
</ol>
<ul>
<li><p>Instead of fitting a brand new tree to the residuals (as in boosting), BART proposes a random perturbation to the existing tree structure and/or its leaf values:</p>
<ol style="list-style-type: lower-alpha">
<li><p>Structural changes: Add, remove, or change splits in the tree.</p></li>
<li><p>Leaf value changes: Adjust the predicted value at the terminal nodes.</p></li>
</ol></li>
<li><p>Perturbations are accepted probabilistically, favoring those that improve the fit to the partial residuals (i.e., those that increase posterior probability).</p></li>
</ul>
<ol start="4" style="list-style-type: decimal">
<li>Posterior Summaries and Burn-in</li>
</ol>
<p>After discarding the first <span class="math inline">\(L\)</span> “burn-in” iterations, the remaining sampled models are averaged to form the final prediction:
<span class="math display">\[
\hat{f}(x) = \frac{1}{B-L} \sum_{b=L+1}^{B} \hat{f}^b(x)
\]</span></p>
<p>where</p>
<p><span class="math display">\[
\hat{f}^b(x) = \sum_{k=1}^{K} \hat{f}_k^b(x)
\]</span></p>
<p>This Bayesian averaging not only gives a point estimate, but also allows you to compute intervals (e.g., a 95% credible interval) for uncertainty quantification by looking at the distribution of the predictions <span class="math inline">\(\hat{f}^{L+1}(x), \ldots, \hat{f}^B(x)\)</span>.</p>
<ol start="5" style="list-style-type: decimal">
<li>Regularization and Overfitting Avoidance</li>
</ol>
<ul>
<li><p>Tree size is typically kept small (shallow trees with few splits), limiting each tree’s capacity to overfit.</p></li>
<li><p>Bayesian priors are imposed on the structure and predictions of the trees, further regularizing the ensemble.</p></li>
<li><p>The perturbation scheme and the Bayesian averaging prevent the ensemble from fitting the training data too closely, a common problem in boosting.</p></li>
</ul>
<ol start="6" style="list-style-type: decimal">
<li>Posterior Predictive Distribution</li>
</ol>
<p>For any new input <span class="math inline">\(x^*\)</span>, BART provides a full posterior predictive distribution, not just a single estimate:</p>
<p>For each post-burn-in iteration, compute <span class="math inline">\(\hat{f}^b(x^*)\)</span>.
The collection <span class="math inline">\(\{\hat{f}^{L+1}(x^*), \ldots, \hat{f}^B(x^*)\}\)</span> can be used to compute percentiles or credible intervals, quantifying uncertainty in the prediction.</p>
<ol start="7" style="list-style-type: decimal">
<li>Hyperparameters</li>
</ol>
<ul>
<li><span class="math inline">\(K\)</span>: Number of trees in the ensemble (commonly 100–200).</li>
<li><span class="math inline">\(B\)</span>: Number of MCMC iterations (often 1,000–10,000 or more).</li>
<li><span class="math inline">\(L\)</span>: Number of burn-in iterations (e.g., 100–200).</li>
<li>These are chosen based on problem complexity and computational resources, but BART is known to be robust to these choices.</li>
</ul>
<div id="why-use-trees-as-base-learners-in-ensembles" class="section level6 hasAnchor" number="5.2.8.2.3.1">
<h6><span class="header-section-number">5.2.8.2.3.1</span> Why Use Trees as Base Learners in Ensembles?<a href="statistical-inference.html#why-use-trees-as-base-learners-in-ensembles" class="anchor-section" aria-label="Anchor link to header"></a></h6>
<p>Decision trees are a popular choice for building ensemble methods because:</p>
<p>Flexibility: Trees can model both linear and non-linear relationships.
Mixed Data Types: Trees handle both qualitative (categorical) and quantitative (numerical) predictors without requiring transformation or specialized encoding.
Automatic Variable Selection: Trees naturally select relevant variables by choosing splits that best separate the data.
Interpretability (for single trees): The structure of a tree can be visualized and interpreted.</p>
<p>However, single trees are unstable and prone to overfitting. Ensemble methods combine multiple trees to improve predictive performance and stability.</p>
<p>Bagging (Bootstrap Aggregating)
How it works:</p>
<p>Build multiple trees, each on a different random sample (with replacement) of the training data (bootstrap sample).
Each tree is grown independently of the others.
For prediction, average the results (regression) or take a majority vote (classification) across all trees.</p>
<p>Implications:</p>
<p>Because all trees are trained on similar (but not identical) datasets, and because the trees use all available variables at each split, they often find similar splits and end up structurally similar.
This similarity means the ensemble might not explore the full range of possible models (“model space”), and can get stuck in “local optima”—missing better solutions elsewhere in the model space.</p>
<p>Random Forests
How it works:</p>
<p>Like bagging, but with an added layer of randomness: at each split in each tree, only a random subset of predictors is considered as split candidates.
Each tree is still trained independently on a bootstrap sample.</p>
<p>Mathematical Mechanism:
If there are p predictors, at each split, randomly select m predictors (commonly m=p​ for classification, or m=p/3 for regression), and choose the best split among only those m.</p>
<p>Implications:</p>
<p>By restricting the set of variables eligible for splits, trees become more diverse: they don’t always split on the strongest predictor.
This decorrelation between trees means the average prediction is more stable and less sensitive to the peculiarities of the data.
The ensemble explores a broader range of models than bagging.</p>
<p>Boosting
How it works:</p>
<p>Uses the original dataset; does not sample data.
Builds trees sequentially—each tree is trained to predict the errors (residuals) of the combined previous trees.
Each new tree is “shrunk” (its predictions are weighted less strongly) before being added to the ensemble. This is often called a “slow” or “weak” learning approach.</p>
<p>Mathematical Mechanism:
At each step, the model is updated as:</p>
<p><span class="math display">\[
F_{m}(x) = F_{m-1}(x) + \nu \cdot h_{m}(x)
\]</span></p>
<p>Where:</p>
<ul>
<li><span class="math inline">\(F_{m}(x)\)</span> is the ensemble after m trees,</li>
<li><span class="math inline">\(h_{m}(x)\)</span> is the new tree fit to current residuals,</li>
<li><span class="math inline">\(\nu\)</span> is a learning rate (shrinkage parameter, typically <span class="math inline">\(0 &lt; \nu &lt; 1\)</span>).
Implications:</li>
</ul>
<p>Boosting is highly effective at capturing complex patterns.
The sequential dependency means each tree “corrects” the errors of the ensemble so far.
Without proper regularization (like shrinkage or limiting tree depth), boosting can overfit—fit the training data too closely and perform poorly on new data.</p>
<p>BART (Bayesian Additive Regression Trees)
How it works:</p>
<p>Like boosting, BART fits trees sequentially, each trying to explain part of the signal not captured by the ensemble so far.
Unlike boosting, BART does not fit entirely new trees at each step. Instead, it perturbs (modifies) existing trees from the previous iteration, either by changing their structure (splitting/pruning) or by adjusting the values at the leaves.
The update process is stochastic and Bayesian: random proposals for modifying trees are made, with preference given to those that improve the fit to the residuals.</p>
<p>Mathematical Mechanism:
Let <span class="math inline">\(K\)</span> be the number of trees and <span class="math inline">\(B\)</span> the number of iterations. At each iteration, the prediction is:</p>
<p><span class="math display">\[
\hat{f}^{b}(x) = \sum_{k=1}^{K} \hat{f}_{k}^{b}(x)
\]</span></p>
<p>After discarding <span class="math inline">\(L\)</span> burn-in iterations, the final prediction is:</p>
<p><span class="math display">\[
\hat{f}(x) = \frac{1}{B-L} \sum_{b=L+1}^{B} \hat{f}^{b}(x)
\]</span></p>
<p>Where each <span class="math inline">\(\hat{f}_{k}^{b}(x)\)</span> is a tree updated by perturbing the previous tree for that position in the ensemble.</p>
<p>Implications:</p>
<p>BART’s random perturbation mechanism guards against overfitting and local minima by continually exploring new tree structures, rather than fitting residuals as closely as possible.
BART provides not only a point estimate but also a distribution of predictions, allowing for uncertainty quantification.
The process can be viewed as a Markov chain Monte Carlo algorithm sampling from the posterior distribution over possible ensembles.</p>
<p>Key Differences and Similarities</p>
<p>Bagging and Random Forests:
Grow trees independently using random samples (bagging), with random forests introducing additional randomness at each split.
Boosting:
Builds trees sequentially, each correcting the residuals of the ensemble so far, but risks overfitting without shrinkage.
BART:
Grows trees sequentially, but instead of fitting new trees, it perturbs existing ones in a Bayesian way, robustly exploring the model space and providing uncertainty measures.</p>
</div>
</div>
</div>
</div>
<div id="unsupervised-learning" class="section level3 hasAnchor" number="5.2.9">
<h3><span class="header-section-number">5.2.9</span> Unsupervised learning<a href="statistical-inference.html#unsupervised-learning" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Supervised learning with refer to statistical methods such as regression and classification. The goal of supervised learning to predict a response variable <span class="math inline">\(Y\)</span> using features <span class="math inline">\(X_{1}, X_{2}, \ldots, X_{p}\)</span>. This chapter, however, focuses on unsupervised learning, where there is no response variable <span class="math inline">\(Y\)</span>. Instead, the aim is to discover patterns or interesting structures within the features themselves. The chapter specifically covers two methods of unsupervised learning: principal components analysis (for visualizing or preprocessing data) and clustering (for finding unknown subgroups in the data).</p>
<div id="challenges-in-unsupervised-learning" class="section level4 hasAnchor" number="5.2.9.1">
<h4><span class="header-section-number">5.2.9.1</span> Challenges in unsupervised learning<a href="statistical-inference.html#challenges-in-unsupervised-learning" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Supervised learning is well-understood, with clear goals and established tools for evaluating performance, such as predicting a response variable and checking accuracy. In contrast, unsupervised learning is more challenging and subjective because there is no response variable, making it difficult to assess results or check the correctness of findings. Unsupervised learning is often used for exploratory data analysis, and its techniques are important in many fields, such as identifying subgroups in genetic data, grouping customers in online shopping, or personalizing search engine results.</p>
</div>
<div id="principal-components-analysis-pca" class="section level4 hasAnchor" number="5.2.9.2">
<h4><span class="header-section-number">5.2.9.2</span> Principal Components Analysis (PCA)<a href="statistical-inference.html#principal-components-analysis-pca" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Principal Components Analysis (PCA) is a method used to reduce a large set of correlated variables into a smaller set of representative variables (principal components) that explain most of the variability in the data. PCA identifies directions in the data with the most variation and creates new variables along those directions. It is an unsupervised technique, relying only on the features and not on any response variable. PCA is useful for data visualization, dimensionality reduction, and even filling in missing data, and is discussed here as a tool for exploring data without labeled outcomes.</p>
<div id="what-are-principal-components" class="section level5 hasAnchor" number="5.2.9.2.1">
<h5><span class="header-section-number">5.2.9.2.1</span> What are principal components?<a href="statistical-inference.html#what-are-principal-components" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>We aim to visualize high-dimensional data and reduce it in principal components analysis. Suppose you have a dataset with <span class="math inline">\(n\)</span> observations. For each observation, you have measured <span class="math inline">\(p\)</span> different features or variables, denoted <span class="math inline">\(X_{1}, X_{2}, \ldots, X_{p}\)</span>. You want to visually explore this data, which is a common first step in exploratory data analysis.</p>
<p>One simple approach is to create scatterplots of the data. A scatterplot typically shows two variables at a time, with one on the x-axis and the other on the y-axis. If you have p variables, you could, in theory, make a scatterplot for every possible pair of variables. The number of such pairs is given by the binomial coefficient <span class="math inline">\(\binom{p}{2} = \frac{p(p-1)}{2}\)</span>​. For example, if you have 10 features (i.e., <span class="math inline">\(p = 10\)</span>), there are 45 different scatterplots you could make.</p>
<p>However, as <span class="math inline">\(p\)</span> increases, the number of possible scatterplots grows quickly and becomes unmanageable. Not only is it impractical to look at so many plots, but most of them won’t be very useful. Each scatterplot only shows the relationship between two features at a time, and therefore contains only a small part of the overall information present in the entire dataset. When <span class="math inline">\(p\)</span> is large, you need a better way to visualize the structure of the data.</p>
<p>The goal is to find a way to represent the data in a low-dimensional space (for example, two or three dimensions) that still preserves as much of the important information (variation) in the data as possible. If you can find such a representation, you can plot the data in this new space and get a meaningful visualization, even if the original data had many more dimensions.</p>
<p><strong>What Principal Components Analysis (PCA) Does</strong></p>
<p>Principal Components Analysis (PCA) is a mathematical technique that addresses this problem. PCA finds a new set of dimensions, called principal components, which are linear combinations of the original features. Each observation in your data (which originally lived in a p-dimensional space) can now be represented in a lower-dimensional space (for example, two or three principal components), where each new dimension captures as much of the variation (difference among observations) in the data as possible.</p>
<p>The idea is that not all of the original <span class="math inline">\(p\)</span> variables are equally “interesting” in terms of how much they vary across your observations. PCA finds the directions (in the <span class="math inline">\(p\)</span>-dimensional space) along which the data varies the most. These directions are called principal components. The first principal component is the direction along which the data varies the most; the second is the direction (orthogonal to the first) along which the remaining variation is maximized, and so on.</p>
<p><strong>How the First Principal Component is Defined</strong></p>
<p>The first principal component is a normalized linear combination of the original variables:
<span class="math display">\[
Z_{1} = \phi_{11} X_{1} + \phi_{21} X_{2} + \cdots + \phi_{p1} X_{p}
\]</span></p>
<p>The coefficients<span class="math inline">\(\phi_{11}, \ldots, \phi_{p1}\)</span>​ are called the loadings for the first principal component. The vector <span class="math inline">\(\phi_{1} = (\phi_{11}, \phi_{21}, \ldots, \phi_{p1})^{T}\)</span> is called the loading vector.</p>
<p>Normalization means that the sum of the squares of the loadings is equal to 1:
<span class="math display">\[
\sum_{j=1}^{p} \phi_{j1}^{2} = 1
\]</span></p>
<p>This normalization is important so that you don’t get arbitrarily large variances by just making the coefficients very large.</p>
<p><strong>Finding the First Principal Component</strong></p>
<p>Suppose your dataset is represented as a matrix <span class="math inline">\(\mathbf{X}\)</span> of size <span class="math inline">\(n \times p\)</span>, where <span class="math inline">\(n\)</span> is the number of observations and <span class="math inline">\(p\)</span> is the number of features. Before finding principal components, you center each variable (feature) so that it has mean zero. This is done by subtracting the mean of each column from every entry in that column.</p>
<p>You look for the linear combination of features (using coefficients <span class="math inline">\(\phi_{11}, \ldots, \phi_{p1}\)</span> that gives a new variable <span class="math inline">\(z_{i1}\)</span>for each observation <span class="math inline">\(i\)</span>:</p>
<p><span class="math display">\[
z_{i1} = \phi_{11} x_{i1} + \phi_{21} x_{i2} + \cdots + \phi_{p1} x_{ip}
\]</span></p>
<p>The goal is to choose the coefficients <span class="math inline">\(\phi_{11}, \ldots, \phi_{p1}\)</span> so that the sample variance of the <span class="math inline">\(z_{i1}\)</span> values is as large as possible, subject to the constraint that the sum of squared coefficients is 1:</p>
<p><span class="math display">\[
\underset{\phi_{11}, \ldots, \phi_{p1}}{\operatorname{maximize}} \left\{ \frac{1}{n} \sum_{i=1}^{n} \left( \sum_{j=1}^{p} \phi_{j1} x_{ij} \right)^2 \right\} \quad \text{subject to} \quad \sum_{j=1}^{p} \phi_{j1}^2 = 1
\]</span></p>
<p>This is a classic optimization problem, and it can be solved using a method called eigen decomposition from linear algebra.
The resulting <span class="math inline">\(z_{i1}\)</span> values (for <span class="math inline">\(i = 1, 2, \ldots, n\)</span>) are called the scores of the first principal component. The loading vector <span class="math inline">\(\phi_{1}\)</span>​ defines the direction in which the data vary the most. If you project the data points onto this direction, you obtain the principal component scores.</p>
<p><strong>Geometric Interpretation</strong></p>
<p>Geometrically, the loading vector <span class="math inline">\(\phi_{1}\)</span>gives a direction in the original feature space. Each observation (data point) is projected onto this direction, and the resulting value is the score for that observation on the first principal component. In the special case where there are only two features, this direction can be easily drawn as a line on a scatterplot. In higher dimensions, it’s a direction in p-dimensional space.
As an example, if you have two features, the first principal component loading vector might be <span class="math inline">\(\phi_{11} = 0.839\)</span>, <span class="math inline">\(\phi_{21} = 0.544\)</span>. This defines a specific direction in the two-dimensional space of the features.</p>
<p><strong>The Second Principal Component</strong></p>
<p>After finding the first principal component, you can look for a second linear combination of the features (the second principal component) that:</p>
<p>Has the largest possible variance among all linear combinations that are uncorrelated with the first principal component; and
Is orthogonal (perpendicular) to the first principal component in the feature space.</p>
<p>Mathematically, the second principal component scores are:</p>
<p><span class="math display">\[
z_{i2} = \phi_{12} x_{i1} + \phi_{22} x_{i2} + \cdots + \phi_{p2} x_{ip}
\]</span></p>
<p>where the loading vector <span class="math inline">\(\phi_{2} = (\phi_{12}, \phi_{22}, \ldots, \phi_{p2})^T\)</span> is chosen so that <span class="math inline">\(\phi_{1}\)</span>​ is orthogonal to <span class="math inline">\(\phi_{2}\)</span> and the sum of squared coefficients is 1.
If you only have two features, the direction of the second principal component is uniquely determined (it must be perpendicular to the first). With more features, there can be several principal components, each defined in the same way (maximizing variance, being orthogonal to all previous components).</p>
<p><strong>Using Principal Components for Visualization</strong></p>
<p>Once you have computed the principal components, you can use them to create low-dimensional representations of the data. For example, you can make a scatterplot of the data using the first two principal component scores as the axes. This gives you a two-dimensional plot that tries to preserve as much of the variation in the original high-dimensional data as possible.</p>
<p>You can also plot the first principal component against the second, or the second against the third, and so on, to explore different aspects of the data’s structure. Geometrically, this is like projecting the data into the subspace spanned by the first few principal components and plotting the projected points.</p>
</div>
<div id="another-interpretation-of-principle-components" class="section level5 hasAnchor" number="5.2.9.2.2">
<h5><span class="header-section-number">5.2.9.2.2</span> Another interpretation of Principle Components<a href="statistical-inference.html#another-interpretation-of-principle-components" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>Principal component loading vectors and their relationship with variance. The first two principal component loading vectors in a simulated three-dimensional dataset are shown in Figure 12.2. These two loading vectors span a plane in 3D space. A “plane” in 3D is a flat, two-dimensional surface, and in this context, it is defined by the two principal component loading vectors. This plane is special because it is the plane along which the set of data points (the observations) have the highest variance. In other words, if you were to look for the flattest surface that best fits the spread of the data, the plane defined by the first two principal component directions is that surface.</p>
<p>These Principal Components are directions of maximal variation. Principal component loading vectors were described as directions in feature space along which the data varies the most. That is, PCA finds directions in the dataset such that, if you were to project all your data points onto these directions, the spread (variance) of the projected values would be as large as possible. The principal component scores are the coordinates of the projections of the data points onto these directions.</p>
<p>When we think about principal components, they are closest to low-dimensional planes as possible for all data points. This is an alternative (but equivalent) interpretation of principal components.Principal components identify low-dimensional linear surfaces (lines, planes, hyperplanes, etc.) that are as close as possible to all of the data points. “Closeness” here is measured using the average squared Euclidean distance from each data point to the surface. The Euclidean distance is the straight-line distance between two points in space.</p>
<p>The first Principal Component is the first line in <span class="math inline">\(p\)</span>-dimensional space (where <span class="math inline">\(p\)</span>oints (where <span class="math inline">\(n\)</span> is the number of observations). “As close as possible” means that the sum of the squared distances from each data point to the line is as small as possible, among all possible lines through the origin in <span class="math inline">\(p\)</span>-dimensional space. In Figure 6.15, this is illustrated by dashed lines showing the distance from each observation to the line. The appeal of this is that you find a single dimension that lies “in the middle” of all the data points, providing a summary of the entire dataset in just one dimension.</p>
<p>When we state “closest”, the principal component are low-dimensional approximations. The first two principal components define a plane in <span class="math inline">\(p\)</span>-dimensional space that is as close as possible (in terms of average squared Euclidean distance) to all <span class="math inline">\(n\)</span> observations. In general, the first <span class="math inline">\(M\)</span> principal components (for any <span class="math inline">\(M\)</span>) define an <span class="math inline">\(M\)</span>-dimensional linear subspace (hyperplane) that is as close as possible to the data cloud. This interpretation leads to the idea of approximating each element <span class="math inline">\(x_{ij}\)</span> of the data matrix (the value of feature <span class="math inline">\(j\)</span> for observation <span class="math inline">\(i\)</span>) by a sum involving the first <span class="math inline">\(M\)</span> principal components:</p>
<p><span class="math display">\[
    x_{ij} \approx \sum_{m=1}^{M} z_{im} \phi_{jm}
    \]</span></p>
<p>Here, <span class="math inline">\(z_{im}\)</span> is the score of observation <span class="math inline">\(i\)</span> on principal component <span class="math inline">\(m\)</span>.
<span class="math inline">\(\phi_{jm}\)</span> is the loading of feature <span class="math inline">\(j\)</span> on principal component <span class="math inline">\(m\)</span>.</p>
<p>In other words, for each observation-feature pair, the value is approximated by multiplying the score of the observation on each principal component by the loading of the feature on that principal component, and summing over the first <span class="math inline">\(M\)</span> components.</p>
<p>The formal optimization of the best low-dimensional approximation can initially be expressed as:</p>
<p><span class="math inline">\(x_{ij} \approx \sum_{m=1}^{M} a_{im} b_{jm}\)</span></p>
<p>where <span class="math inline">\(a_{im}\)</span> and <span class="math inline">\(b_{jm}\)</span>are numbers to be determined.</p>
<p>The best approximation (in the sense of being closest to the actual data) is the one that minimizes the sum of squared residuals (the squared differences between the actual data and the approximation), summed over all features and all observations:</p>
<p><span class="math display">\[
    \underset{A \in \mathbb{R}^{n \times M}, B \in \mathbb{R}^{p \times M}}{\operatorname{minimize}}
    \left\{ \sum_{j=1}^{p} \sum_{i=1}^{n} \left( x_{ij} - \sum_{m=1}^{M} a_{im} b_{jm} \right)^2 \right\}
    \]</span></p>
<p>Here, <span class="math inline">\(A\)</span> is an <span class="math inline">\(n \times M\)</span> matrix (with entries <span class="math inline">\(a_{im}\)</span>​), and <span class="math inline">\(B\)</span> is a <span class="math inline">\(p \times M\)</span> matrix (with entries <span class="math inline">\(b_{jm}\)</span>​).</p>
<p>It turns out that the solution to this minimization problem is given by the first <span class="math inline">\(M\)</span> principal component scores and loadings: for the optimal <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, <span class="math inline">\(a_{im} = z_{im}\)</span> (the score of observation <span class="math inline">\(i\)</span> on component <span class="math inline">\(m\)</span>), and <span class="math inline">\(b_{jm} = \phi_{jm}\)</span> (the loading of feature <span class="math inline">\(j\)</span> on component <span class="math inline">\(m\)</span>).</p>
<p>This means the smallest possible value of the sum of squared residuals (the best possible approximation) is:</p>
<p><span class="math display">\[
    \sum_{j=1}^{p} \sum_{i=1}^{n} \left( x_{ij} - \sum_{m=1}^{M} z_{im} \phi_{jm} \right)^2
    \]</span></p>
<p>The first <span class="math inline">\(M\)</span> principal component score vectors and the first <span class="math inline">\(M\)</span> loading vectors together give the best possible linear, <span class="math inline">\(M\)</span>-dimensional approximation to the data (in terms of squared Euclidean distance).
If you choose <span class="math inline">\(M\)</span> large enough (specifically, <span class="math inline">\(M = \min(n-1, p)\)</span>), then the approximation becomes exact:</p>
<p><span class="math display">\[
    x_{ij} = \sum_{m=1}^{M} z_{im} \phi_{jm}
    \]</span></p>
<p>This means that, for a sufficiently large number of principal components, you can reconstruct the entire original dataset exactly from the principal component scores and loadings.</p>
</div>
<div id="the-proportion-of-variance-explained-pve-in-pca" class="section level5 hasAnchor" number="5.2.9.2.3">
<h5><span class="header-section-number">5.2.9.2.3</span> The Proportion of Variance Explained (PVE) in PCA<a href="statistical-inference.html#the-proportion-of-variance-explained-pve-in-pca" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>When we perform Principal Component Analysis (PCA) on a dataset, we transform the data from its original coordinate system (often, each axis is a measured variable or feature) to a new system defined by the principal components. We want to project the data so that we can capture patterns in the data. For example, if we have a dataset with three features (so every observation is a point in 3D space), we can use PCA to find three new axes (principal components) that are linear combinations of the original axes.</p>
<p>Often, the most important structure in the data can be seen by looking only at the first few principal components (those that capture the most variation in the data). For example, by projecting the data onto the first two principal components, we get a two-dimensional view of the data. If the data really “lives” mostly in a two-dimensional subspace, this projection will preserve most of the relationships between the observations.</p>
<p>In Figure 12.2, the first two principal component loading vectors are used to create a two-dimensional “plane” in the original three-dimensional space. When the data is projected onto this plane, the main patterns are preserved: groups of points that are near each other in 3D also remain close in the 2D projection. Similarly, in the USArrests data example (with 50 observations and 4 variables), projecting the data onto the first two principal components gives a good summary of the main structure in the data.</p>
<p>This leads to an important question: How much information do we lose by keeping only the first few principal components? Or, put differently: How much of the total variation in the data is captured by the first few principal components? This motivates the concept of the proportion of variance explained (PVE) by each principal component.</p>
<p>The total variance in the data is a measure of how much the values of all variables differ from their means across all observations. In PCA, we usually center each variable to have mean zero (subtract the mean of each column from every entry in that column). The total variance is calculated by summing the variances of each variable:</p>
<p><span class="math display">\[
\sum_{j=1}^{p} \operatorname{Var}(X_j) = \sum_{j=1}^{p} \frac{1}{n} \sum_{i=1}^{n} x_{ij}^2
\]</span></p>
<ul>
<li><span class="math inline">\(p\)</span> is the number of variables (features).  </li>
<li><span class="math inline">\(n\)</span> is the number of observations (samples).  </li>
<li><span class="math inline">\(x_{ij}\)</span>​ is the centered value (mean-zero) of variable <span class="math inline">\(j\)</span> for observation <span class="math inline">\(i\)</span>.</li>
</ul>
<p>So, for each feature, we square each centered value, sum over all observations, divide by n (to get the variance for that feature), and then sum over all features.</p>
<p>Each principal component is itself a new variable, created as a specific linear combination of the original variables:</p>
<p><span class="math display">\[
z_{im} = \sum_{j=1}^{p} \phi_{jm} x_{ij}
\]</span></p>
<p><span class="math inline">\(z_{im}\)</span> is the score of observation <span class="math inline">\(i\)</span> on principal component m.
<span class="math inline">\(\phi_{jm}\)</span>is the loading (weight) of variable <span class="math inline">\(j\)</span> on principal component <span class="math inline">\(m\)</span>.</p>
<p>The variance explained by the mth principal component is:
<span class="math display">\[
\frac{1}{n} \sum_{i=1}^{n} z_{im}^2 = \frac{1}{n} \sum_{i=1}^{n} \left( \sum_{j=1}^{p} \phi_{jm} x_{ij} \right)^2
\]</span></p>
<p>This formula squares each score, sums over all observations, and divides by n to get the variance.</p>
<p>The (Proportion of Variance Explained) PVE for the <span class="math inline">\(m\)</span>th principal component is the fraction of the total variance that is captured by that component:</p>
<p><span class="math display">\[
\text{PVE}_m = \frac{ \sum_{i=1}^n z_{im}^2 }{ \sum_{j=1}^p \sum_{i=1}^n x_{ij}^2 } = \frac{ \sum_{i=1}^n \left( \sum_{j=1}^p \phi_{jm} x_{ij} \right)^2 }{ \sum_{j=1}^p \sum_{i=1}^n x_{ij}^2 }
\]</span></p>
<p>The numerator is the total variance explained by the mth principal component. The denominator is the total variance in the entire dataset.</p>
<p>Each PVE is a positive number between 0 and 1. The sum of the PVEs for all principal components is 1, meaning that together, they account for all the variance in the data. To find the cumulative PVE for the first <span class="math inline">\(M\)</span> principal components, simply add the PVEs for each of those components.</p>
<p>Relationship to Data Approximation and Residual Error
Recall from the previous section: the first M principal components provide the best M-dimensional linear approximation to the data (in terms of minimizing the squared error between the actual data and the approximation). The total variance in the data can be split into two parts:</p>
<p>The variance explained by the first <span class="math inline">\(M\)</span> principal components.
The mean squared error (MSE) of the approximation using those <span class="math inline">\(M\)</span> components.</p>
<p>This decomposition is written:</p>
<p><span class="math display">\[
\sum_{j=1}^p \frac{1}{n} \sum_{i=1}^n x_{ij}^2 = \sum_{m=1}^M \frac{1}{n} \sum_{i=1}^n z_{im}^2 + \frac{1}{n} \sum_{j=1}^p \sum_{i=1}^n \left( x_{ij} - \sum_{m=1}^M z_{im} \phi_{jm} \right)^2
\]</span></p>
<p>The left side is the total variance in the data.
The first term on the right is the variance explained by the first M principal components.
The second term is the mean squared error of the best M-dimensional approximation.</p>
<p>This relationship means that maximizing the variance explained by the first <span class="math inline">\(M\)</span> principal components is equivalent to minimizing the mean squared error of the approximation.</p>
<p>The PVE for the first <span class="math inline">\(M\)</span> components can also be written in terms of total and residual sum of squares <span class="math inline">\(R^2\)</span>:</p>
<p><span class="math display">\[
1 - \frac{ \sum_{j=1}^p \sum_{i=1}^n \left( x_{ij} - \sum_{m=1}^M z_{im} \phi_{jm} \right)^2 }{ \sum_{j=1}^p \sum_{i=1}^n x_{ij}^2 } = 1 - \frac{\mathrm{RSS}}{\mathrm{TSS}}
\]</span></p>
<p>TSS (Total Sum of Squares): the sum of squared entries in the data matrix.
RSS (Residual Sum of Squares): the sum of squared errors of the <span class="math inline">\(M\)</span>-dimensional approximation.</p>
<p>This formula is analogous to the <span class="math inline">\(R^2\)</span> statistic in regression, representing the proportion of variance explained by the approximation, or in this case, by the first <span class="math inline">\(M\)</span> principal components.</p>
</div>
<div id="uniqueness-of-the-principal-components" class="section level5 hasAnchor" number="5.2.9.2.4">
<h5><span class="header-section-number">5.2.9.2.4</span> Uniqueness of the Principal Components<a href="statistical-inference.html#uniqueness-of-the-principal-components" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>A principal component loading vector is a set of coefficients (weights) assigned to the original variables (features) in a dataset. In PCA, each principal component is defined as a particular linear combination of the original variables. The coefficients in this linear combination are called the loadings, and for each principal component, these loadings are collected into a vector—the principal component loading vector.
If you have<span class="math inline">\(p\)</span> variables, the loading vector for the <span class="math inline">\(m\)</span>th principal component is:</p>
<p><span class="math display">\[
\phi_{1m},\, \phi_{2m},\, \ldots,\, \phi_{pm}
\]</span></p>
<p>This vector describes a direction in the <span class="math inline">\(p\)</span>-dimensional space of your features.</p>
<p>When we say a principal component loading vector is “unique up to a sign flip,” we mean that the direction defined by the loading vector is unique, but the actual vector you get could point in either direction along the same line. That is, both <span class="math inline">\(\phi\)</span> and <span class="math inline">\(-\phi\)</span> define exactly the same line or direction in space. If you run PCA using two different software packages, you may find that the loading vectors for a principal component are the same except for the sign of every element: one package might give [0.5,-0.7,0.5], while another gives [-0.5,0.7,-0.5]. Both are equally valid. The sign does not matter for interpretation, because the principal component represents a direction, not an arrow pointing a particular way along that direction.</p>
<p>In mathematical terms, the principal component loading vector specifies a one-dimensional linear subspace (a line) in p-dimensional space.
A line has no preferred direction: the line through the origin defined by <span class="math inline">\(\phi\)</span> is exactly the same as the line defined by <span class="math inline">\(-\phi\)</span>.
Flipping the sign of the loading vector just reverses the direction of the vector, not the subspace it spans. For example, imagine a line through the origin in 3D space. If you specify a direction, say (1,2,3), that line also includes the direction (-1,-2,-3). Both directions describe the same infinite line, just pointing in opposite directions.</p>
<p>The principal component scores for each observation (the projections of the data onto the principal component direction) are also unique up to a sign flip. Suppose the score for observation i on component m is zim​. If you flip the sign of the loading vector (<span class="math inline">\(\phi_{jm}\)</span>to <span class="math inline">\(-\phi_{jm}\)</span>), then the scores for each observation also flip sign (<span class="math inline">\(z_{im}\)</span> to <span class="math inline">\(-z_{im}\)</span>. This is because:</p>
<p><span class="math display">\[
    z_{im} = \sum_{j=1}^p \phi_{jm} x_{ij}
    \]</span></p>
<p>When using principal components to approximate or reconstruct the original data (using the formula <span class="math inline">\(x_{ij} \approx \sum_{m=1}^M z_{im} \phi_{jm}\)</span>, the product <span class="math inline">\(z_{im} \phi_{jm}\)</span> is what matters. If you flip the sign of both the loading vector and the scores, you have:</p>
<p><span class="math inline">\(z_{im} \to -z_{im}\)</span><br />
<span class="math inline">\(\phi_{jm} \to -\phi_{jm}\)</span><br />
The product <span class="math inline">\(z_{im} \phi_{jm} \to (-z_{im})(- \phi_{jm}) = z_{im} \phi_{jm}\)</span></p>
<p>Therefore, the reconstructed or approximated value xij​ does not change at all if both are sign-flipped. The final result is completely unchanged.</p>
<p>In geometric terms, the principal component direction is a line through the origin in feature space. The sign flip corresponds to moving along the line in the opposite direction, but because the line is infinite in both directions, the choice of “which way is positive” is arbitrary. This is analogous to how, in a coordinate system, the direction of axes is arbitrary, and flipping all values along an axis doesn’t change the data’s structure, just the orientation. When comparing principal component results from different sources (e.g., different software, textbooks, or computations), do not be concerned if the loadings or scores appear with opposite signs. As long as the directions (and relationships between variables) are preserved, the analysis and interpretation remain valid and unchanged.</p>
</div>
<div id="deciding-how-many-principal-components-to-use" class="section level5 hasAnchor" number="5.2.9.2.5">
<h5><span class="header-section-number">5.2.9.2.5</span> Deciding How Many Principal Components to Use<a href="statistical-inference.html#deciding-how-many-principal-components-to-use" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>Suppose you have a data matrix <span class="math inline">\(\mathbf{X}\)</span> with <span class="math inline">\(n\)</span> rows (observations, or samples) and <span class="math inline">\(p\)</span> columns (variables, or features). The process of Principal Component Analysis (PCA) decomposes this matrix into a set of principal components. Mathematically, the maximum number of distinct principal components you can extract is <span class="math inline">\(\min(n-1, p)\)</span>:</p>
<p>If you have more features than observations <span class="math inline">\(p &gt; n-1\)</span>, then you can only get <span class="math inline">\(n-1\)</span> principal components with nonzero variance, because after centering, the data lies in an <span class="math inline">\(n-1\)</span> dimensional subspace.
If you have more observations than features <span class="math inline">\(n &gt; p\)</span>, you can get <span class="math inline">\(p\)</span> principal components.</p>
<p>However, in practice, we are rarely interested in keeping all possible principal components. We want to reduce the dimensionality of the data and retain only those components that capture the main structure or variation in the data.</p>
<p>Our aim is to use the smallest number of principal components that give us a good understanding of the data. “Good understanding” here means being able to capture the main patterns, clusters, or trends present in the data, while discarding noise or less informative variation.</p>
<p>There is no single, universally agreed-upon rule for how many principal components should be kept. The answer depends on the specific context, the data, and the goals of the analysis.</p>
<p>A scree plot is a graphical tool used to help decide how many principal components to retain.</p>
<p>In a scree plot, the x-axis shows the component number (1st, 2nd, 3rd, etc.), and the y-axis shows the proportion of variance explained (PVE) by each component.</p>
<p>The plot often starts high (with the first component explaining a large amount of variance), then drops off as you go to higher-numbered components.</p>
<p>Often, the scree plot shows a sharp drop in variance explained after the first few components, then levels off.
The “elbow” in the scree plot is the point where this drop occurs—the plot bends like an elbow.
The components before the “elbow” explain a sizable amount of variance and are typically retained. Components after the elbow explain much less variance and are often discarded.
For example, if the first two components explain a large proportion of variance, and the third and fourth add little, one might keep only the first two.</p>
<p>If the third principal component explains less than 10% of the variance, and the fourth explains less than half that, then those components add little to our understanding.
In such a case, the “elbow” appears after the second component, suggesting that two components are enough.</p>
<p>This scree plot method is ad hoc (informal and based on visual inspection, not a strict rule).
There is no universally accepted, objective criterion for how many principal components are “enough.” What is enough depends on:</p>
<p>The specific dataset (how much structure is in the data, how quickly the variance explained drops off).
The area of application (for example, genetics, finance, image analysis, etc.).
The goals of the analysis (visualization, pattern discovery, noise reduction, etc.).</p>
<p>PCA is most often used for exploratory data analysis—looking for patterns, clusters, or interesting structure in the data without a target variable.
In practice, we:</p>
<p>Examine the first few principal components for interesting patterns.
If these components reveal structure, clusters, or trends, we may look at a few more.
If the first few components show no interesting structure, it’s unlikely that later components will.</p>
<p>The Process is Iterative and Subjective</p>
<p>If you find interesting patterns in the first few components, you may look at additional components until nothing new is learned.
This process is subjective and depends on the analyst’s goals and judgment.</p>
<p>In supervised analysis, we have an outcome variable (for example, in regression or classification).
When using PCA for supervised analysis, such as principal components regression (PCR), we can use objective criteria to select the number of components:</p>
<p>The number of principal components to use can be treated as a tuning parameter (just like the number of neighbors in k-NN, or the penalty parameter in ridge regression).
We can use methods like cross-validation to select the number that gives the best predictive performance on held-out data.</p>
<p>This makes the process of choosing the number of components more objective and reproducible.</p>
<p>The subjectivity in unsupervised PCA (no outcome variable) reflects the open-ended, exploratory nature of the analysis.
The objectivity in supervised PCA (with outcome variable) reflects the well-defined nature of prediction tasks, where the “best” number of components is the one that gives the best predictive accuracy as determined by a clear metric.</p>
</div>
<div id="other-uses-for-principal-components" class="section level5 hasAnchor" number="5.2.9.2.6">
<h5><span class="header-section-number">5.2.9.2.6</span> Other uses for principal components<a href="statistical-inference.html#other-uses-for-principal-components" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>In Section 6.3.1, regression was performed not on the original variables (features) themselves, but on the principal component score vectors.</p>
<p>Each principal component score vector is a new variable created by projecting the data onto a principal component loading vector (a direction in the original variable space).
For a data set with n observations and p variables, the principal component scores form an <span class="math inline">\(n \times p\)</span> matrix (if all components are used), but you can select just the first <span class="math inline">\(M\)</span> components to get an <span class="math inline">\(n \times M\)</span> matrix.</p>
<p>Generalization to Other Statistical Methods</p>
<p>Principal Component Regression (PCR):</p>
<p>Instead of using all <span class="math inline">\(p\)</span> original variables as predictors in a regression model, you use only the scores from the first <span class="math inline">\(M\)</span> principal components as predictors.
This reduces dimensionality and can help avoid problems like multicollinearity and overfitting, especially when <span class="math inline">\(p\)</span> is large or when predictors are highly correlated.</p>
<p>Classification:</p>
<p>In classification problems (for example, deciding which category an observation belongs to), you can use the principal component scores as input features to your classifier (such as logistic regression, support vector machines, decision trees, etc.).
This can help the classifier focus on the main structure in the data and ignore irrelevant details.</p>
<p>Clustering:</p>
<p>Clustering algorithms (like k-means) can also be applied to the matrix of principal component scores instead of the original data.
By using just the principal component scores, you often reveal the true groupings in the data more clearly, since noise and irrelevant dimensions are reduced or removed.</p>
<p>Using the <span class="math inline">\(n \times M\)</span> Matrix</p>
<p>The <span class="math inline">\(n \times M\)</span> matrix is formed by keeping only the first <span class="math inline">\(M\)</span> principal component score vectors (columns), where <span class="math inline">\(M\)</span> is much smaller than <span class="math inline">\(M \ll p\)</span>, the total number of original variables.</p>
<p>For example, if you start with 100 variables (<span class="math inline">\(p = 100\)</span>) but most of the variation and structure in the data is explained by just 3 principal components (<span class="math inline">\(M = 3\)</span>), you can reduce your data to an <span class="math inline">\(n \times 3\)</span> matrix.</p>
<p>This dimensionality reduction leads to more efficient and often more interpretable analysis.</p>
<p>Why This Leads to Less Noisy Results</p>
<p>In real-world data, not all variables contain useful information (signal). Many variables may be mostly noise or random variation.
PCA orders the principal components so that the first component explains the most variance, the second explains the next most, and so on.
Often, the signal (meaningful structure and patterns) in the data is captured by the first few principal components.</p>
<p>For example, in gene expression data, thousands of genes (variables) may be measured, but only a few combinations (principal components) capture most of the biological differences between samples.</p>
<p>The later principal components often capture only noise or minor details.
By using only the first <span class="math inline">\(M\)</span> principal components as features, you remove much of the noise, leading to more robust and reliable statistical analysis.</p>
<p>Start with your original data matrix (n observations, p variables).
Perform PCA to find the principal components.
Project your data onto the first M principal components to get an <span class="math inline">\(n \times M\)</span> matrix of scores.
Use this matrix as the input for regression, classification, clustering, or any other statistical method.</p>
</div>
</div>
<div id="clustering-methods" class="section level4 hasAnchor" number="5.2.9.3">
<h4><span class="header-section-number">5.2.9.3</span> Clustering methods<a href="statistical-inference.html#clustering-methods" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Clustering is a group of techniques used to find subgroups (clusters) within a dataset by grouping together similar observations and separating dissimilar ones. The definition of “similar” or “different” is context-dependent and relies on domain knowledge. For example, in medical data, clustering can be used to find unknown subtypes of a disease by grouping tissue samples with similar measurements.
Clustering is an unsupervised learning problem, meaning there is no known outcome variable; the goal is to discover structure (clusters) in the data. In contrast, supervised learning tries to predict a known outcome. Both clustering and principal component analysis (PCA) simplify data, but PCA does so by reducing dimensionality and summarizing variance, while clustering finds homogeneous groups within the observations.
Clustering is widely used, including in marketing for “market segmentation,” where the aim is to identify groups of people likely to respond similarly to marketing strategies.
There are many clustering methods, but two of the most common are:</p>
<p>K-means clustering: Partitions data into a pre-specified number of clusters.
Hierarchical clustering: Does not require the number of clusters to be specified in advance; it creates a tree-like diagram (dendrogram) that shows relationships among observations for all possible numbers of clusters.</p>
<p>Clustering can be done on observations or features, depending on the analysis goal. The rest of the chapter focuses on clustering observations based on their features.</p>
<div id="k-means-clustering" class="section level5 hasAnchor" number="5.2.9.3.1">
<h5><span class="header-section-number">5.2.9.3.1</span> K-means clustering<a href="statistical-inference.html#k-means-clustering" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>K-means clustering is a widely used, conceptually simple, and effective algorithm for dividing a dataset into a set number (<span class="math inline">\(K\)</span>) of distinct, non-overlapping groups called clusters. The key goal is to partition the data so that:</p>
<p>Each observation (data point) belongs to exactly one cluster.
Data points within the same cluster are as similar as possible to each other.
Data points in different clusters are as dissimilar as possible.</p>
<p>To use K-means, you must specify in advance the number of clusters (<span class="math inline">\(K\)</span>) you want to find. The algorithm then automatically assigns each observation to one of these clusters.</p>
<p><strong>Notation and Cluster Assignment</strong></p>
<p>Suppose you have n observations (data points) and <span class="math inline">\(p\)</span> features (variables). You want to split the observations into <span class="math inline">\(K\)</span> clusters. Here’s how we formalize this:</p>
<ul>
<li><p>Let <span class="math inline">\(C_1, C_2, ..., C_K\)</span> be the sets of indices for the <span class="math inline">\(K\)</span> clusters.</p>
<ul>
<li>For example, if the 4th, 7th, and 10th observations belong to cluster 2, then <span class="math inline">\(C_2 = \{4, 7, 10\}\)</span>.</li>
</ul></li>
<li><p>These sets must satisfy two important properties:</p>
<ol style="list-style-type: decimal">
<li><p>Every observation must belong to at least one cluster:
<span class="math display">\[
C_{1} \cup C_{2} \cup ... \cup C_{K} = \{1, 2, ..., n\}
\]</span></p></li>
<li><p>No observation belongs to more than one cluster (clusters do not overlap):
<span class="math display">\[
C_k \cap C_{k&#39;} = \emptyset \quad \text{for all } k \neq k&#39;
\]</span></p></li>
</ol></li>
</ul>
<p><strong>The Optimization Objective: Within-Cluster Variation</strong></p>
<p>The idea behind K-means is to find a clustering such that the observations within each cluster are as similar as possible. This is measured by within-cluster variation—a measure of how “spread out” the points in a cluster are.</p>
<p>For cluster <span class="math inline">\(C_k\)</span>, the within-cluster variation is denoted <span class="math inline">\(W(C_k)\)</span>.
The goal is to find a partition (assignment of points to clusters) that minimizes the total within-cluster variation across all <span class="math inline">\(K\)</span> clusters.</p>
<p>Mathematically, the objective is:
<span class="math display">\[
\underset{C_1, ..., C_K}{\operatorname{minimize}} \left\{ \sum_{k=1}^K W(C_k) \right\}
\]</span>
That is, find the partition of the data into K clusters such that the sum of the within-cluster variations is as small as possible.</p>
<p>How Do We Measure Within-Cluster Variation?
The most common way is to use the squared Euclidean distance between observations. For cluster <span class="math inline">\(C_k\)</span>:
<span class="math display">\[
W(C_k) = \frac{1}{|C_k|} \sum_{i, i&#39; \in C_k} \sum_{j=1}^p (x_{ij} - x_{i&#39;j})^2
\]</span></p>
<ul>
<li><span class="math inline">\(|C_k|\)</span> is the number of observations in cluster <span class="math inline">\(C_k\)</span>.<br />
</li>
<li>The double sum <span class="math inline">\(\sum_{i, i&#39; \in C_k}\)</span> sums over every possible pair of observations in the cluster.<br />
</li>
<li>For each pair, we sum the squared differences across all features (<span class="math inline">\(p\)</span>).<br />
</li>
<li>This computes the average squared distance between every pair of observations within cluster C<span class="math inline">\(C_k\)</span>.</li>
</ul>
<p>Combining this with the original objective gives:
<span class="math display">\[
\underset{C_1, ..., C_K}{\operatorname{minimize}} \left\{ \sum_{k=1}^{K} \frac{1}{|C_k|} \sum_{i, i&#39; \in C_k} \sum_{j=1}^p (x_{ij} - x_{i&#39;j})^2 \right\}
\]</span></p>
<p><strong>Why is This Problem Hard?</strong></p>
<p>For <span class="math inline">\(n\)</span> observations and <span class="math inline">\(K\)</span> clusters, there are <span class="math inline">\(K^n\)</span> possible ways to assign each point to a cluster. This number grows astronomically with even moderate <span class="math inline">\(n\)</span> and <span class="math inline">\(K\)</span>.
Therefore, it is infeasible to check every possible assignment to find the absolute best (global optimum).</p>
<p>The K-means Algorithm: A Practical (Local) Solution
Despite the complexity, a simple iterative algorithm can be used to find a local optimum, which is often good enough in practice. This is the classic K-means algorithm:</p>
<p>Algorithm Steps</p>
<ol style="list-style-type: decimal">
<li><p>Initialization:</p>
<ul>
<li>Randomly assign each observation to one of the K clusters (so each gets a temporary cluster label).</li>
</ul></li>
<li><p>Iterate until assignments stop changing: a) For each cluster, compute the centroid (mean) of all observations assigned to that cluster. The centroid is a vector of length <span class="math inline">\(p\)</span>, with each element being the average value for that feature in the cluster. b) Reassign each observation to the cluster whose centroid is closest (using Euclidean distance).</p>
<ul>
<li>Repeat steps 2a and 2b until the cluster assignments no longer change (convergence).</li>
</ul></li>
</ol>
<p><strong>Why Does This Work?</strong></p>
<ul>
<li>At each iteration, the within-cluster variation (the objective) always decreases or stays the same; it never increases.</li>
<li>This is because:
<ul>
<li>The centroids are calculated to minimize the total squared distance for the current assignments.</li>
<li>Reassigning observations to the nearest centroid can only decrease the total distance.</li>
</ul></li>
<li>The process stops at a local optimum: a set of assignments where moving a single observation to a different cluster would not decrease the objective further.</li>
</ul>
<p><strong>Important Note: Local Optima</strong></p>
<ul>
<li>The result depends on the initial random assignment. Running the algorithm multiple times with different initializations and choosing the best result (lowest total within-cluster variation) is standard practice.</li>
</ul>
<p><strong>The algorithm is demonstrated in the figures:</strong></p>
<p>Figure 12.7: Shows how the same data can be clustered into 2, 3, or 4 clusters, with each observation colored according to its cluster assignment.
Figure 12.8: Shows the progression of the K-means algorithm on a toy example. It illustrates:</p>
<ul>
<li>Initial random assignments,</li>
<li>Calculation of initial centroids,</li>
<li>Iterative reassignments and centroid updates,</li>
<li>Final clustering after convergence.</li>
</ul>
<p><strong>Selecting the Number of Clusters K</strong>
To use K-means, you must decide in advance how many clusters you expect in the data. This is a nontrivial problem and is addressed later in the text.</p>
<p><strong>Mathematical Details</strong>
- The within-cluster variation can also be rewritten for computational convenience:</p>
<p><span class="math display">\[
\frac{1}{|C_k|} \sum_{i, i&#39; \in C_k} \sum_{j=1}^p (x_{ij} - x_{i&#39;j})^2 = 2 \sum_{i \in C_k} \sum_{j=1}^p (x_{ij} - \bar{x}_{kj})^2
\]</span></p>
<ul>
<li>Here, <span class="math inline">\(\bar{x}_{kj}\)</span> is the mean of feature <span class="math inline">\(j\)</span> in cluster <span class="math inline">\(k\)</span>.</li>
<li>This identity shows why updating the centroids and reassigning points always decreases the objective.</li>
</ul>
</div>
<div id="hierarchial-clustering" class="section level5 hasAnchor" number="5.2.9.3.2">
<h5><span class="header-section-number">5.2.9.3.2</span> Hierarchial clustering<a href="statistical-inference.html#hierarchial-clustering" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>Hierarchical clustering is an alternative to K-means clustering that does not require specifying the number of clusters in advance. Instead, it builds a tree-like structure called a dendrogram to represent how observations are grouped together at different levels of similarity. This approach has the advantage of providing a visual, flexible representation of the data’s clustering structure. The section focuses on bottom-up (agglomerative) hierarchical clustering, which is the most common type, where clusters are formed by progressively merging the closest pairs of observations or groups.</p>
<div id="interpreting-a-dendrogram" class="section level6 hasAnchor" number="5.2.9.3.2.1">
<h6><span class="header-section-number">5.2.9.3.2.1</span> Interpreting a dendrogram<a href="statistical-inference.html#interpreting-a-dendrogram" class="anchor-section" aria-label="Anchor link to header"></a></h6>
<p>Building and Interpreting a Dendrogram
The Structure of a Dendrogram</p>
<ul>
<li>A dendrogram is a tree-like diagram commonly used to visualize the results of hierarchical clustering.<br />

<ul>
<li>It is usually drawn “upside down”—the leaves (the bottom ends) represent individual observations, and as you move up the tree, branches join together, combining observations and clusters.<br />
</li>
</ul></li>
<li>The process of building a dendrogram starts with each observation as its own separate cluster (the leaves).<br />

<ul>
<li>Clusters are then merged together step by step according to some similarity or distance measure, until all observations are combined into one single cluster (the trunk).</li>
</ul></li>
</ul>
<p><strong>How to Read a Dendrogram</strong></p>
<ul>
<li>In the dendrogram, each leaf corresponds to one observation.<br />
</li>
<li>Branches form when two leaves (or clusters) are joined together—this represents the merging of two similar observations or groups.<br />
</li>
<li>As you move up the tree, clusters previously formed at lower levels merge into larger clusters.<br />

<ul>
<li>The lower a fusion occurs (closer to the bottom), the more similar those observations or clusters are.<br />
</li>
<li>The higher a fusion occurs (closer to the top), the less similar the merged clusters are.<br />
</li>
</ul></li>
<li>The vertical axis of the dendrogram reflects the distance or dissimilarity at which clusters are joined.<br />

<ul>
<li>For any two observations, you can trace up the tree to the point where they first join; the height of this connection is a measure of their dissimilarity.</li>
</ul></li>
</ul>
<p><strong>Common Misinterpretations</strong></p>
<p>The horizontal axis (left-to-right order) of the dendrogram is arbitrary and can be rearranged at each fusion point without changing the meaning of the tree.</p>
<p>For n observations, there are <span class="math inline">\(2^{n-1}\)</span> possible orderings.
Observations close together horizontally are not necessarily more similar than those far apart unless their branches are directly joined at a low height.</p>
<p>Two observations might be plotted next to each other (horizontally) but actually become part of the same cluster only at a high level (meaning they are not particularly similar). The correct way to assess similarity is by looking at the vertical position where their branches first merge.</p>
<p><strong>Identifying Clusters: Cutting the Dendrogram</strong></p>
<ul>
<li>To decide how many clusters to extract from a dendrogram, you make a horizontal cut across the tree at a chosen height.<br />

<ul>
<li>Every branch below the cut line is considered a separate cluster.<br />
</li>
<li>The number of clusters equals the number of branches intersected by the cut.</li>
</ul></li>
</ul>
<p><strong>The height of the cut determines the granularity:</strong>
- A high cut yields fewer, larger clusters.<br />
- A low cut yields more, smaller clusters.<br />
- Cutting at height zero gives every observation its own cluster.</p>
<p>This approach is flexible: you can extract any number of clusters from a single dendrogram, unlike K-means, which requires a fixed <span class="math inline">\(K\)</span>.</p>
<p><strong>The Nature and Limitations of Hierarchical Clustering</strong></p>
<ul>
<li><p>The term hierarchical refers to the fact that clusters at a lower cut (more clusters) are always fully contained within clusters at a higher cut (fewer clusters). This is called “nested structure.”</p></li>
<li><p>In some real-world cases, this assumption of nested clusters does not fit the actual data structure.<br />
</p>
<ul>
<li>The best split into two clusters might be by gender (men vs. women).<br />
</li>
<li>The best split into three clusters might be by nationality (American, Japanese, French).<br />
</li>
<li>These groupings are not nested: the three-way split does not arise from further splitting either of the two gender groups.</li>
</ul></li>
<li><p>As a result, hierarchical clustering can sometimes perform worse than K-means (which does not assume nested clusters), yielding less accurate or meaningful groups for a given number of clusters.</p></li>
<li><p>Interpreting a dendrogram requires focusing on vertical fusion heights to assess similarity, not horizontal proximity.<br />
</p></li>
<li><p>The dendrogram’s flexibility allows you to select any number of clusters after clustering has been performed.<br />
</p></li>
<li><p>However, the hierarchical nature (nesting) of clusters may not always reflect the true structure in the data, and in such cases, hierarchical clustering can be less accurate than other methods.</p></li>
</ul>
</div>
<div id="the-hierarchial-clustering-algorithm" class="section level6 hasAnchor" number="5.2.9.3.2.2">
<h6><span class="header-section-number">5.2.9.3.2.2</span> The Hierarchial Clustering Algorithm<a href="statistical-inference.html#the-hierarchial-clustering-algorithm" class="anchor-section" aria-label="Anchor link to header"></a></h6>
<p>The Goal: Building a Dendrogram</p>
<p>The end product of hierarchical clustering is a dendrogram, a tree diagram that shows how observations or clusters are combined in a sequence of steps until all are joined together. The dendrogram provides a visual summary of the nested grouping structure found in the data, allowing you to see at a glance which observations are most similar and how clusters merge.</p>
<p>Step 1: Measuring Dissimilarity Between Observations</p>
<p>The process begins by defining a dissimilarity measure between every pair of observations (data points).</p>
<p>The most common dissimilarity measure is Euclidean distance—the straight-line distance between two points in feature space.
More generally, any appropriate distance or dissimilarity metric can be used, and the choice may depend on the context or data type.</p>
<p>Step 2: Initial Clusters</p>
<p>At the start (the bottom of the dendrogram), each observation is treated as its own cluster.</p>
<p>For <span class="math inline">\(n\)</span> observations, there are initially <span class="math inline">\(n\)</span> clusters, each containing just one data point.
For example, if you have 9 data points, you begin with clusters <span class="math inline">\(\{1\}, \{2\}, ..., \{9\}\)</span>.</p>
<p>Step 3: Iterative Merging (Fusing) of Clusters</p>
<p>The algorithm proceeds iteratively: at each step, it finds the two clusters that are most similar (i.e., that have the smallest dissimilarity between them) and merges them into a single cluster.</p>
<p>After the first merge, there are <span class="math inline">\(n-1\)</span> clusters.
After the second, <span class="math inline">\(n-2\)</span>, and so on, until finally all observations are merged into one cluster at the top of the dendrogram.</p>
<p>Step 4: Recalculating Dissimilarities Between Clusters</p>
<p>After each merge, you now have clusters that could contain more than one observation.
You must define how to compute the dissimilarity between two clusters, not just between two single points.</p>
<p>This is not obvious: there are many possible ways to do this.</p>
<p>The process of extending the concept of dissimilarity between pairs of points to groups of points is called the notion of linkage.</p>
<p>Linkage Methods: How to Measure Dissimilarity Between Clusters</p>
<p>The linkage method specifies how to calculate the distance between two groups of observations (clusters).
The four most common types of linkage are:
- Complete linkage: The maximum distance between any pair of observations, one from each cluster. This tends to produce compact, spherical clusters since a cluster will only merge with another if all its members are sufficiently close to all members of the other cluster.<br />
- Single linkage: The minimum distance between any pair of observations, one from each cluster. This can lead to long, “trailing” clusters because clusters can be joined by single points that are close, even if the rest of the cluster is far away.  
- Average linkage: The average distance between all pairs of observations, one from each cluster. This is a compromise between single and complete linkage.<br />
- Centroid linkage: The distance between the centroids (means) of the two clusters. This can result in a phenomenon called “inversion,” where the height at which two clusters are merged is less than the height of earlier merges, which can make interpretation difficult.</p>
<ol style="list-style-type: decimal">
<li>Start: Compute all pairwise dissimilarities for the <span class="math inline">\(n\)</span> observations (for n points, there are <span class="math inline">\(n(n-1)/2\)</span> pairs). Each observation is its own cluster.
Iterate:</li>
<li>For <span class="math inline">\(i = n, n-1, ..., 2\)</span>:<br />

<ul>
<li><ol style="list-style-type: lower-alpha">
<li>Find the two clusters with the smallest inter-cluster dissimilarity (according to the chosen linkage method) and fuse them. Record the height of the fusion in the dendrogram.<br />
</li>
</ol></li>
<li><ol start="2" style="list-style-type: lower-alpha">
<li>Recompute the pairwise dissimilarities among the new set of clusters.<br />
</li>
</ol></li>
</ul></li>
</ol>
<ul>
<li>Repeat this process until all points are merged into a single cluster.</li>
</ul>
<p><strong>Important Notes and Implications</strong></p>
<p>The linkage method chosen has a significant effect on the resulting dendrogram and the structure of the clusters found.</p>
<ul>
<li>Complete and average linkage methods are generally preferred because they tend to produce more balanced, interpretable cluster trees.<br />
</li>
<li>Single linkage can produce “chained” clusters that are not compact.<br />
</li>
<li>Centroid linkage, used mostly in specialized contexts like genomics, can produce confusing inversions.<br />
</li>
<li>The final dendrogram depends not only on the linkage method, but also on the original measure of dissimilarity (e.g., Euclidean distance).</li>
</ul>
<p>Repeat this process until all points are merged into a single cluster.</p>
</div>
<div id="choice-of-dissimilarity-measure" class="section level6 hasAnchor" number="5.2.9.3.2.3">
<h6><span class="header-section-number">5.2.9.3.2.3</span> Choice of Dissimilarity Measure<a href="statistical-inference.html#choice-of-dissimilarity-measure" class="anchor-section" aria-label="Anchor link to header"></a></h6>
<p>Euclidean Distance as Dissimilarity</p>
<p>In most clustering examples so far, Euclidean distance has been used as the dissimilarity measure.</p>
<p>For two observations (data points), their Euclidean distance is the square root of the sum of squared differences across all variables/features. Mathematically, for points <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> with <span class="math inline">\(p\)</span> features,
<span class="math inline">\(d(x, y) = \sqrt{\sum_{j=1}^p (x_j - y_j)^2}\)</span></p>
<p>This measure is intuitive for geometric data: points close together in space are considered similar.</p>
<p>Alternative: Correlation-Based Distance</p>
<p>Sometimes, other measures are more appropriate. For example, correlation-based distance considers two observations similar if their profiles (across features) are highly correlated, even if their values are far apart in Euclidean terms.</p>
<p>This is an unusual use of correlation: typically, correlation measures the relationship between two variables (columns), but here it is used between two observations (rows).
Correlation-based distance focuses on the shape or pattern of the observations, not their overall magnitude.
For instance, if two shoppers both buy the same items in the same proportions (even if one buys 100x more than the other), they will have a high correlation and thus a small correlation-based distance.</p>
<p>The Critical Impact of the Dissimilarity Measure</p>
<p>The choice of dissimilarity measure is crucial because it fundamentally determines how clusters are formed.</p>
<p>Different measures can yield very different dendrograms (see Figure 12.14 for how linkage method affects cluster shapes).
The best choice depends on the data and the purpose of clustering.</p>
<p>Illustration with Figure 12.15</p>
<p>This figure shows three observations (e.g., shoppers) measured on 20 variables (e.g., items).</p>
<p>Observations 1 and 3 have similar values for each variable, so their Euclidean distance is small, but they are weakly correlated (the shapes of their profiles differ), so correlation-based distance is large between them.
Observations 1 and 2 have different values for each variable, so their Euclidean distance is large, but the shape of their profiles is similar (e.g., both buy the same items in the same proportions, just at different scales), so correlation-based distance is small.</p>
<p>The Role of Scaling Variables Before Clustering
Why Scaling Matters</p>
<p>Variables may have different units or different variances.</p>
<p>Example: In online shopping data, socks might be purchased much more often than computers.
Without scaling, variables with larger magnitude or variance will dominate the dissimilarity calculation, overshadowing variables that are less frequent or have smaller numerical values.</p>
<p>What Happens If We Don’t Scale?</p>
<p>The clustering may reflect mainly the variable(s) with the largest values or most frequent purchases.</p>
<p>In Figure 12.16 (left), clustering based on raw purchase counts means that differences in sock purchases dominate the dissimilarity, and computer purchases have little effect.
This could be undesirable if the retailer cares about both product categories equally, or more about computers.</p>
<p>Scaling to Standard Deviation One</p>
<p>By scaling each variable to have mean zero and standard deviation one (often called z-score normalization), every variable contributes equally to the dissimilarity calculation.</p>
<p>In Figure 12.16 (center), after scaling, both socks and computers affect the clustering similarly.
This prevents high-frequency (or high-magnitude) variables from dominating.</p>
<p>Scaling for Different Units</p>
<p>If variables are measured in different units (e.g., centimeters vs. kilometers, or number of items vs. dollars spent), scaling is essential to make their contributions comparable.</p>
<p>In Figure 12.16 (right), clustering on the basis of dollars spent means computer purchases (being more expensive) now dominate the dissimilarity.</p>
<p>Choosing the Best Approach</p>
<p>The decision to scale or not, and which dissimilarity measure to use, depends on the scientific context and the specific goals of the analysis.</p>
<p>What do you mean by “similar” in your context?
Are you interested in grouping by overall activity, by preference profiles, or by some other criterion?</p>
<p>These choices are just as important for K-means clustering as for hierarchical clustering.</p>
<p>Euclidean distance measures absolute differences in values; it is affected by scaling and magnitude.
Correlation-based distance measures similarity in patterns or shapes of variable profiles, ignoring overall size.
Scaling variables (to standard deviation one) can ensure all variables contribute equally, preventing highly variable features from dominating the results.
The combination of the dissimilarity measure and scaling decisions fundamentally determines the clusters you find and their interpretability.</p>
</div>
</div>
<div id="practical-issues-in-clustering" class="section level5 hasAnchor" number="5.2.9.3.3">
<h5><span class="header-section-number">5.2.9.3.3</span> Practical Issues in Clustering<a href="statistical-inference.html#practical-issues-in-clustering" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>Practical Issues in Clustering: Why Small Decisions Matter
Clustering is a powerful tool in unsupervised learning, meaning it is used when we do not have any outcome variables or labels for our data. It helps us find groups or structure in the data that might not be obvious. However, successfully applying clustering methods is not as simple as running an algorithm—there are many practical considerations and choices that must be made along the way. Each of these choices can dramatically affect the results you get, and therefore, the conclusions you draw from your analysis.
Key Decisions Before and During Clustering
1. Standardization or Scaling of Variables</p>
<p>Why consider scaling?
The measurements for different features (variables) in your dataset might not be on the same scale or might vary in their units or ranges. For example, height could be measured in centimeters (ranging from 150-200), while weight could be in kilograms (ranging from 40-120). If you do not standardize (scale) the variables, features with larger numerical ranges will dominate the calculation of distances (dissimilarities), and thus, the clustering results.
Typical approach:
Standardizing each variable so that it has mean zero and standard deviation one, which puts all features on an equal footing, is a common practice. This is especially important for distance-based clustering methods like K-means and hierarchical clustering.</p>
<ol start="2" style="list-style-type: decimal">
<li>Decisions Specific to Hierarchical Clustering</li>
</ol>
<p>Choice of Dissimilarity Measure:
You must decide how to quantify how “different” or “far apart” two observations are. Common choices are Euclidean distance, Manhattan distance, or even correlation-based distances. The chosen measure affects which observations are considered similar and therefore grouped together.
Choice of Linkage Type:
When clusters contain more than one observation, you must decide how to define the distance between two clusters. Do you use the shortest distance between any pair (single linkage), the farthest distance (complete linkage), the average distance (average linkage), or the distance between cluster means (centroid linkage)? Each choice can produce vastly different dendrograms and clustering structures.
Choosing Where to Cut the Dendrogram:
Once the dendrogram is built, you must decide at what height to cut across the tree to form clusters. Cutting at different heights changes the number of clusters you get and how the data are grouped.</p>
<ol start="3" style="list-style-type: decimal">
<li>Decisions Specific to K-Means Clustering</li>
</ol>
<p>Choosing the Number of Clusters (K):
K-means requires the analyst to specify the number of clusters in advance. There is no universally correct value for K, and the clustering outcome can change dramatically with different choices. Analysts often try different values and evaluate the results using domain knowledge or quantitative criteria (such as the elbow method or silhouette score).</p>
<p>The Impact of These Decisions
Every one of these decisions can substantially affect the final clustering results. For example:</p>
<p>Failing to scale variables may cause clusters to reflect only the features with the largest values, ignoring potentially important structure in the other features.
Using different linkage methods may produce clusters of very different shapes and sizes.
Choosing the dissimilarity measure can mean the difference between grouping data by overall magnitude vs. by pattern.
Picking different cut points in a dendrogram changes the number and composition of clusters.
Selecting different values of K in K-means may reveal or obscure natural groupings in the data.</p>
<p>There is usually no single “correct” answer in clustering. The right choice depends on the data, the context, and the purpose of the analysis. In practice, analysts often try several different approaches, compare the results, and choose the solution that is most interpretable or useful for the application at hand. Any clustering that reveals interesting, valid structure in the data is worth considering.</p>
<div id="small-decisions-with-big-consequences" class="section level6 hasAnchor" number="5.2.9.3.3.1">
<h6><span class="header-section-number">5.2.9.3.3.1</span> Small Decisions with Big Consequences<a href="statistical-inference.html#small-decisions-with-big-consequences" class="anchor-section" aria-label="Anchor link to header"></a></h6>
<p>Clustering Always Produces Clusters</p>
<p>Whenever we apply a clustering algorithm—whether K-means, hierarchical, or any other method—to a dataset, the algorithm will always produce some grouping of the data into clusters.</p>
<p>This is true even if there is no real, meaningful structure or subgroups present in the data.
The clustering algorithm will partition or group the points according to its rules, regardless of whether those groups correspond to any real pattern in the underlying data.</p>
<p>The Central Question: Are the Clusters Real or Just Noise?</p>
<p>The key issue we face after running a clustering algorithm is:
Do the clusters we found represent real, meaningful subgroups in the data, or are they merely artifacts created by the algorithm as it tries to organize random fluctuations (noise) in the dataset?</p>
<p>In other words, if there were truly no structure in the data, the algorithm would still force the observations into clusters. How do we know if the clusters we see have any statistical or scientific validity?</p>
<p>The Challenge of Replicability</p>
<p>A natural way to test the validity of clusters is to ask:
If we collected a new, independent sample of data from the same population, would we find the same clusters?</p>
<p>If the clustering structure is real, it should appear again in new data.
If it was just a consequence of random noise, the clusters in the new dataset are likely to be completely different.
However, in practice, obtaining truly independent data can be difficult or expensive, and subtle differences in data collection or preprocessing can lead to different results.</p>
<p>Statistical Evaluation: p-values for Clusters</p>
<p>To address this, researchers have developed various statistical techniques to assign a p-value to a cluster.</p>
<p>A p-value in this context is a measure of how likely it is to see a cluster of a given strength or tightness purely by chance, under some null model where there are no real clusters.
If the p-value is very small, it suggests that the observed cluster is unlikely to have occurred by chance, and therefore may represent a real subgroup.
These methods might involve:</p>
<p>Randomly shuffling or permuting the data and repeating the clustering to see how often similar clusters appear by chance.
Creating synthetic datasets from a null distribution (with no cluster structure) and comparing the clustering results.
Bootstrapping (resampling with replacement from the data) to assess the stability of clusters.</p>
<p>The goal is to provide a statistical measure of confidence or evidence for the existence of each cluster.</p>
<p>Lack of Consensus on Best Practices</p>
<p>Despite the development of many such statistical validation techniques, there is no general agreement among statisticians and data scientists on a single best method for cluster validation.</p>
<p>Different methods may have different assumptions, may be appropriate for different kinds of data or clustering algorithms, and may yield different answers.
The field is still evolving, and the best approach may depend on the specific context, the data structure, and the goals of the analysis.
Therefore, cluster validation remains a challenging and active area of research.</p>
<p>Further Reading</p>
<p>For more detailed discussion and technical explanation of these methods, the text refers to ESL (presumably “The Elements of Statistical Learning”), where more advanced or alternative approaches to cluster validation are discussed.</p>
</div>
<div id="validating-the-clusters-obtained" class="section level6 hasAnchor" number="5.2.9.3.3.2">
<h6><span class="header-section-number">5.2.9.3.3.2</span> Validating the Clusters Obtained<a href="statistical-inference.html#validating-the-clusters-obtained" class="anchor-section" aria-label="Anchor link to header"></a></h6>
<p>Clustering Always Produces Clusters</p>
<p>Whenever we apply a clustering algorithm—whether K-means, hierarchical, or any other method—to a dataset, the algorithm will always produce some grouping of the data into clusters.</p>
<p>This is true even if there is no real, meaningful structure or subgroups present in the data.
The clustering algorithm will partition or group the points according to its rules, regardless of whether those groups correspond to any real pattern in the underlying data.</p>
<p>The Central Question: Are the Clusters Real or Just Noise?</p>
<p>The key issue we face after running a clustering algorithm is:
Do the clusters we found represent real, meaningful subgroups in the data, or are they merely artifacts created by the algorithm as it tries to organize random fluctuations (noise) in the dataset?</p>
<p>In other words, if there were truly no structure in the data, the algorithm would still force the observations into clusters. How do we know if the clusters we see have any statistical or scientific validity?</p>
<p>The Challenge of Replicability</p>
<p>A natural way to test the validity of clusters is to ask:
If we collected a new, independent sample of data from the same population, would we find the same clusters?</p>
<p>If the clustering structure is real, it should appear again in new data.
If it was just a consequence of random noise, the clusters in the new dataset are likely to be completely different.
However, in practice, obtaining truly independent data can be difficult or expensive, and subtle differences in data collection or preprocessing can lead to different results.</p>
<p>Statistical Evaluation: p-values for Clusters</p>
<p>To address this, researchers have developed various statistical techniques to assign a p-value to a cluster.</p>
<p>A p-value in this context is a measure of how likely it is to see a cluster of a given strength or tightness purely by chance, under some null model where there are no real clusters.
If the p-value is very small, it suggests that the observed cluster is unlikely to have occurred by chance, and therefore may represent a real subgroup.
These methods might involve:</p>
<p>Randomly shuffling or permuting the data and repeating the clustering to see how often similar clusters appear by chance.
Creating synthetic datasets from a null distribution (with no cluster structure) and comparing the clustering results.
Bootstrapping (resampling with replacement from the data) to assess the stability of clusters.</p>
<p>The goal is to provide a statistical measure of confidence or evidence for the existence of each cluster.</p>
<p>Lack of Consensus on Best Practices</p>
<p>Despite the development of many such statistical validation techniques, there is no general agreement among statisticians and data scientists on a single best method for cluster validation.</p>
<p>Different methods may have different assumptions, may be appropriate for different kinds of data or clustering algorithms, and may yield different answers.
The field is still evolving, and the best approach may depend on the specific context, the data structure, and the goals of the analysis.
Therefore, cluster validation remains a challenging and active area of research.</p>
<p>Further Reading</p>
<p>For more detailed discussion and technical explanation of these methods, the text refers to ESL (presumably “The Elements of Statistical Learning”), where more advanced or alternative approaches to cluster validation are discussed.</p>
</div>
<div id="other-considerations-in-clustering" class="section level6 hasAnchor" number="5.2.9.3.3.3">
<h6><span class="header-section-number">5.2.9.3.3.3</span> Other Considerations in Clustering<a href="statistical-inference.html#other-considerations-in-clustering" class="anchor-section" aria-label="Anchor link to header"></a></h6>
<p>Forced Assignment of Every Observation</p>
<p>Both K-means and hierarchical clustering algorithms are designed to assign every observation in your data set to a cluster, with no exceptions. This means that, no matter how unusual or dissimilar an observation is compared to the rest, it will still be grouped into one of the clusters.</p>
<p>In practice, this can be problematic when the data contain outliers—observations that are very different from the rest of the data, or even from each other.</p>
<p>Example: Outliers Among Clusters</p>
<p>Imagine a scenario where most observations naturally form a small number of genuine, meaningful subgroups (clusters).</p>
<p>For example, suppose you have a dataset of 100 points, with 95 of them forming three clear clusters, and the remaining 5 points being scattered far from these clusters and from each other.</p>
<p>Standard clustering algorithms like K-means or hierarchical clustering will still assign these 5 outliers to one of the existing clusters, because they have no mechanism for leaving observations unassigned.</p>
<p>This forced assignment can “pull” the clusters in unnatural directions, distorting the centroid (mean) or boundaries of the clusters, and making the resulting groups less meaningful or interpretable.
The presence of even a few such outliers can have a disproportionate effect on the cluster assignments of all the other points.</p>
<p>Outlier Accommodation: Mixture Models</p>
<p>Mixture models provide an alternative approach to clustering that can better handle outliers.</p>
<p>Rather than forcing each observation into a single cluster, mixture models assign probabilities to each observation for belonging to each cluster. This is called soft clustering.
For example, a point might have a 95% probability of belonging to cluster 1, a 4% probability for cluster 2, and a 1% probability for cluster 3.
Crucially, mixture models can accommodate outliers by assigning them low probability to every cluster, rather than forcing them into a group where they do not fit.
This approach is more flexible and can yield more accurate, meaningful clusters in the presence of outliers or “noise” points.
Mixture models are a generalization of K-means and are especially useful in more complex or noisy datasets. More details are available in specialized texts like ESL (“The Elements of Statistical Learning”).</p>
<p>Sensitivity of Clustering Results to Data Perturbations
Lack of Robustness</p>
<p>Another important issue is that clustering methods, including K-means and hierarchical clustering, are often not robust to small changes in the dataset.</p>
<p>In other words, small perturbations—such as removing a few observations at random, or making small changes to the data—can have a large effect on the resulting clusters.
This lack of robustness can make it difficult to interpret cluster assignments as truly reflecting stable, underlying structure.</p>
<p>Illustration of Instability</p>
<p>Suppose you have n observations and cluster them using your chosen algorithm.
Now, imagine you randomly remove a few of the n observations (say, 10% of the data), and then cluster the remaining observations again using the same method.
You might expect that the clusters you obtain in the second analysis would be similar to those from the first analysis, especially for the observations that were present in both runs.</p>
<p>However, in practice, it is often observed that the two sets of clusters can be quite different—the assignments may change, the shapes and boundaries of clusters may shift, or the number of clusters may even change.
This instability can undermine confidence in the clustering results and suggests that the clusters found may not be robust representations of real structure in the data.</p>
<p>Implications</p>
<p>These issues highlight that clustering is not a foolproof or universally reliable process.</p>
<p>The presence of outliers, the forced assignment of every point, and the sensitivity to small changes all mean that clustering results should be interpreted with caution.
Analysts should consider running clustering multiple times on different subsets of the data, or using methods (such as mixture models or robust clustering algorithms) that can better handle outliers and instability.
It is also crucial to validate clusters using external knowledge or statistical techniques, rather than relying solely on the output of a single clustering run.</p>
</div>
<div id="a-tempered-approach-to-interpreting-the-results-of-clustering" class="section level6 hasAnchor" number="5.2.9.3.3.4">
<h6><span class="header-section-number">5.2.9.3.3.4</span> A Tempered Approach to Interpreting the Results of Clustering<a href="statistical-inference.html#a-tempered-approach-to-interpreting-the-results-of-clustering" class="anchor-section" aria-label="Anchor link to header"></a></h6>
<p>The Value and Limitations of Clustering</p>
<p>Clustering is a powerful tool for exploring structure in unlabeled (unsupervised) data, and can reveal natural groupings that are not immediately obvious.
However, as described in earlier sections, clustering is not a foolproof process. There are several pitfalls and sources of uncertainty that must be kept in mind to avoid misinterpretation.</p>
<p>The Role of User Decisions in Clustering Results</p>
<p>Small choices can have big consequences.
The outcome of a clustering analysis depends heavily on a series of seemingly minor decisions made by the analyst. These include:</p>
<p>How variables are scaled or standardized (for example, whether features are put on the same scale or left in their original units).
The choice of distance or dissimilarity measure (such as Euclidean distance, correlation-based distance, or others).
The type of linkage used in hierarchical clustering (single, complete, average, centroid, etc.).
The number of clusters to extract (in methods like K-means).</p>
<p>Each of these choices can dramatically change which clusters are found, how the clusters are shaped, and even how many clusters are detected.</p>
<p>Sensitivity Analysis: Trying Different Parameters</p>
<p>Because clustering results are so dependent on analyst choices, it is recommended that clustering be performed multiple times, using different parameter settings.</p>
<p>For example, try clustering the data with and without variable standardization, using different linkage methods, or trying different distance metrics.
After running these analyses, compare the results to see which patterns are robust (i.e., consistently appear across many choices) and which are not.
Patterns that emerge consistently are more likely to reflect real structure in the data, while patterns that change with small parameter tweaks may be artifacts.</p>
<p>Testing Robustness: Subsets and Perturbations</p>
<p>Clustering algorithms are known to be non-robust: small changes in the data, or in the clustering parameters, can lead to big changes in the results.</p>
<p>To assess robustness, it is advised to cluster multiple random subsets of the data, or to repeat clustering after removing or perturbing some observations.
This helps identify which clusters are stable and which are highly sensitive to the particular data points included.
Robust clusters—those that persist across many random subsamples—are more likely to be meaningful.</p>
<p>Responsible Reporting and Interpretation</p>
<p>The results of any clustering analysis should be reported with caution.</p>
<p>Clustering output should never be interpreted as representing the absolute or final truth about the underlying structure of a dataset.
The clusters identified are always a function of the data, the algorithm, and the choices made by the analyst, and can change with new data or different parameter settings.
Therefore, clustering results should be viewed as exploratory: they are valuable for generating hypotheses, guiding further investigation, or suggesting possible groupings for future study.</p>
<p>Scientific Process: Clustering as a Hypothesis Generator</p>
<p>The most appropriate role for clustering in scientific research is as a starting point for developing scientific hypotheses.</p>
<p>Once clusters are found, they should be tested, validated, and explored using independent data whenever possible.
Follow-up studies should check if the same clusters are found in new data, or if the clusters are associated with meaningful differences in outcomes or other variables.</p>
<p>Summary of the Approach</p>
<p>Perform clustering with various choices of standardization, distance measure, and linkage type.
Cluster on subsets of the data to test robustness.
Look for consistent, stable patterns across analyses.
Report findings as exploratory and conditional, not as final or absolute truths.
Use clustering outcomes to guide further hypothesis development and validation, ideally with independent datasets.</p>
</div>
</div>
</div>
</div>
<div id="support-vector-machines" class="section level3 hasAnchor" number="5.2.10">
<h3><span class="header-section-number">5.2.10</span> Support Vector Machines<a href="statistical-inference.html#support-vector-machines" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Simpilest and one of the most elegant classifier</p>
<p>Introduction by Visually Explained:</p>
<p><a href="https://www.youtube.com/watch?v=_YPScrckx28" class="uri">https://www.youtube.com/watch?v=_YPScrckx28</a></p>
<p>Pros:
works well with small datasets, easy to interpret, straightforward to implement.</p>
<p>The support vector machine (SVM) is a popular classification method developed in the 1990s. SVMs are considered strong “out of the box” classifiers that perform well in many situations. The maximal margin classifier is a simple linear classifier, but is limited as it cannot be applied to most datasets due to the requirement of a linear boundary. The support vector classifier, is more flexible, and the support vector machine, can handle non-linear boundaries. Theres also SVMs for multiclass problems and these will be compared to other statistical methods like logistic regression.</p>
<div id="maximal-margin-classifier" class="section level4 hasAnchor" number="5.2.10.1">
<h4><span class="header-section-number">5.2.10.1</span> Maximal Margin Classifier<a href="statistical-inference.html#maximal-margin-classifier" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<div id="what-is-a-hyperplane" class="section level5 hasAnchor" number="5.2.10.1.1">
<h5><span class="header-section-number">5.2.10.1.1</span> What is a hyperplane?<a href="statistical-inference.html#what-is-a-hyperplane" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>In mathematics, a hyperplane is a fundamental geometric concept. In a space with p dimensions (called <span class="math inline">\(p\)</span>-dimensional space), a hyperplane is a flat surface that has one dimension less than the ambient space. In other words, it is a subspace of dimension <span class="math inline">\(p\)</span>-1. The hyperplane does not need to pass the origin (affine) and is positioned by <span class="math inline">\(\beta_0\)</span>, whereas, <span class="math inline">\((\beta_1, \ldots, \beta_p)\)</span> determines the orientation of the hyperplane.</p>
<ul>
<li>If <span class="math inline">\(p\)</span>=2: The space is a plane (think of a sheet of paper). A hyperplane in this space is a straight line. This line divides the plane into two regions.</li>
<li>If <span class="math inline">\(p\)</span>=3: The space is three-dimensional (like the world we live in). Here, a hyperplane is a flat, two-dimensional surface—a plane. This plane can divide the three-dimensional space into two parts.</li>
<li>If <span class="math inline">\(p\)</span>=3&gt;3: Though we cannot visualize it easily, the concept still applies. For example, in 4D, a hyperplane is a three-dimensional “slice” of that space.</li>
</ul>
<p>A hyperplane of two dimensions can be defined as:
<span class="math display">\[
\beta_0 + \beta_1 X_1 + \beta_2 X_2 = 0
\]</span></p>
<ul>
<li><span class="math inline">\(\beta_0, \beta_1, \beta_2\)</span> are constants (parameters or coefficients).</li>
<li><span class="math inline">\(X_1, X_2\)</span> are the coordinates of a point in two dimensions.</li>
</ul>
<p>A point <span class="math inline">\(X = (X_1, X_2)^T\)</span> is on the hyperplane if it satisfies this equation.</p>
<p>When we add more dimensions, <span class="math inline">\(p\)</span>-dimensions, the equations becomes:
<span class="math display">\[
\beta_0 + \beta_1 X_1 + \beta_2 X_2 + \cdots + \beta_p X_p = 0
\]</span></p>
<ul>
<li><span class="math inline">\((X_1, X_2, \ldots, X_p)^T\)</span> is any point in p-dimensional space.</li>
<li><span class="math inline">\(\beta_1, \ldots, \beta_p\)</span> are the coefficients for each coordinate.</li>
<li><span class="math inline">\(\beta_0\)</span> is called the intercept or bias.</li>
</ul>
<p>A point <span class="math inline">\(X\)</span> lies on the hyperplane if plugging its coordinates into the equation makes the left side exactly zero.</p>
<p>If <span class="math inline">\(X\)</span> does not satisfy the equation (<span class="math inline">\(X\)</span> is not 0), then we will either have:
<span class="math display">\[
   \beta_0 + \beta_1 X_1 + \beta_2 X_2 + \cdots + \beta_p X_p &gt; 0
   \]</span></p>
<p>or</p>
<p><span class="math display">\[
   \beta_0 + \beta_1 X_1 + \beta_2 X_2 + \cdots + \beta_p X_p &lt; 0
   \]</span></p>
<p>where <span class="math inline">\(X\)</span> will be on one side of the hyperplane or on the other side of the hyperplane.</p>
</div>
<div id="classification-using-a-seperating-hyperplane" class="section level5 hasAnchor" number="5.2.10.1.2">
<h5><span class="header-section-number">5.2.10.1.2</span> Classification Using a Seperating hyperplane<a href="statistical-inference.html#classification-using-a-seperating-hyperplane" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>Data represented as matrix <span class="math inline">\(\mathbf{X}\)</span> with <span class="math inline">\(n\)</span> rows and <span class="math inline">\(p\)</span> columns (<span class="math inline">\(n\)</span> x <span class="math inline">\(p\)</span>). Each row corresponds to a single observation (or data point) in a p-dimensional space. Generally, we write the <span class="math inline">\(i\)</span>-th observation as a column vector:
<span class="math display">\[
x_i = \begin{pmatrix}
x_{i1} \\
x_{i2} \\
\vdots \\
x_{ip}
\end{pmatrix}
\]</span></p>
<p>for <span class="math inline">\(i = 1, 2, \ldots, n\)</span>. That is, each observation contains <span class="math inline">\(p\)</span> features (variables, measurements, or inputs), and there are <span class="math inline">\(n\)</span> such observations.</p>
<p>The dataset is assumed to be labeled for binary classification. Each observation <span class="math inline">\(x_i\)</span> has a corresponding label <span class="math inline">\(y_i\)</span>, where <span class="math inline">\(y_i\)</span> takes one of two possible values: -1 or +1. These represent the two classes. For example:</p>
<ul>
<li><span class="math inline">\(y_i = +1\)</span> might represent “positive” class</li>
<li><span class="math inline">\(y_i = -1\)</span> might represent “negative” class</li>
</ul>
<p>This labeling is arbitrary; the important point is that there are two classes, and each observation is assigned to one or the other.
You may also have a test observation, denoted as <span class="math inline">\(x^*\)</span>, which is a new point in <span class="math inline">\(p\)</span>-dimensional space that you want to classify. This test point is written as:
<span class="math display">\[
x^* = \begin{pmatrix} x_1^* \\ x_2^* \\ \vdots \\ x_p^* \end{pmatrix}
\]</span></p>
<p>The values in <span class="math inline">\(x^*\)</span> are the observed feature measurements for this new data point.</p>
<p>The task is to use the labeled training data <span class="math inline">\(\{(x_1, y_1), ..., (x_n, y_n)\}\)</span> to build a classifier—a rule or function that, given any new observation <span class="math inline">\(x^*\)</span>, predicts whether it should belong to class +1 or class -1.
There are various methods for doing this (such as logistic regression, linear discriminant analysis, or decision trees), but this section focuses on using a separating hyperplane.</p>
<p>A separating hyperplane is a hyperplane that perfectly divides the training data according to their class labels:</p>
<p>All observations of class +1 are on one side of the hyperplane.
All observations of class -1 are on the other side.</p>
<p>This is made precise by the following property:</p>
<p>For every <span class="math inline">\(i\)</span> such that <span class="math inline">\(y_i = +1\)</span>:
<span class="math display">\[
  \beta_0 + \beta_1 x_{i1} + \beta_2 x_{i2} + \cdots + \beta_p x_{ip} &gt; 0
  \]</span></p>
<p>For every <span class="math inline">\(i\)</span> such that <span class="math inline">\(y_i = -1\)</span>:
<span class="math display">\[
  \beta_0 + \beta_1 x_{i1} + \beta_2 x_{i2} + \cdots + \beta_p x_{ip} &lt; 0
  \]</span></p>
<p>Which can be written formally as:
<span class="math display">\[
y_i\left(\beta_0 + \beta_1 x_{i1} + \beta_2 x_{i2} + \cdots + \beta_p x_{ip}\right) &gt; 0, \quad \forall i = 1, ..., n
\]</span></p>
<ul>
<li>If <span class="math inline">\(y_i = +1\)</span>, then the term in parentheses must be positive.</li>
<li>If <span class="math inline">\(y_i = -1\)</span>, then the term in parentheses must be negative.</li>
<li>In both cases, the product is positive.</li>
</ul>
<p>If a hyperplane exists, it can be used to classify new data points. For any new observation <span class="math inline">\(x^*\)</span>, compute:
<span class="math display">\[
f(x^*) = \beta_0 + \beta_1 x_1^* + \beta_2 x_2^* + \cdots + \beta_p x_p^*
\]</span></p>
<p>The sign of <span class="math inline">\(f(x^*)\)</span> determines the predicted class:</p>
<ul>
<li>If <span class="math inline">\(f(x^*) &gt; 0\)</span>, assign to class +1.</li>
<li>If <span class="math inline">\(f(x^*) &lt; 0\)</span>, assign to class -1.</li>
</ul>
<p>Additionally, the magnitude (absolute value) of f(x∗) gives information about the confidence of the prediction:</p>
<ul>
<li>If <span class="math inline">\(|f(x^*)|\)</span> is large, the point <span class="math inline">\(f(x^*)\)</span> is far from the hyperplane, so the prediction is made with high confidence.</li>
<li>If <span class="math inline">\(|f(x^*)|\)</span> is small (close to zero), <span class="math inline">\(f(x^*)\)</span> is near the hyperplane, so the prediction is less certain.</li>
</ul>
<p>Thus, the hyperplane not only divides the space into two regions but also provides a “distance” measure that reflects confidence in the classification.</p>
<p>A classifier based on a separating hyperplane always leads to a linear decision boundary. That is, the rule for classifying new points is based on a linear combination of their features, and the dividing surface between the two classes is flat (no curves).</p>
</div>
<div id="maximal-margin-classifier-1" class="section level5 hasAnchor" number="5.2.10.1.3">
<h5><span class="header-section-number">5.2.10.1.3</span> Maximal Margin Classifier<a href="statistical-inference.html#maximal-margin-classifier-1" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>When your data can be perfectly separated by a hyperplane (that is, you can draw a flat surface so that all points from one class are on one side and all points from the other class are on the other side), there is not just one unique hyperplane that can do this. In fact, there are infinitely many separating hyperplanes. This is because you can move and rotate a seperating hyperplane infinitely in many directions which will result in still perfectly separating the two classes as long as the hyperplane does not cross any of the data points.</p>
<p>So how is the “best” then defined?</p>
<p>A natural and widely-used principle is to choose the maximal margin hyperplane. This is also known as the optimal separating hyperplane. For any given hyperplane, you can measure the perpendicular distance from each data point to the hyperplane. This is the shortest path from the point to the hyperplane, not just along any direction. For each separating hyperplane, you find the smallest such distance among all data points. This is called the margin—the distance from the hyperplane to the closest point among all the training observations.</p>
<p>The maximal margin hyperplane is the one that maximizes this margin. In other words, it is the separating hyperplane that is as far away as possible from the closest data points in the training set. Mathematically: Out of all possible separating hyperplanes, choose the one where the minimal distance from any training observation to the hyperplane is the greatest possible.</p>
<p>The larger the margin, the more confident we can say a classifier in in its predictions. This makes the classifier more robust to small changes or noise in the data. The hope is that the classifier has large enough margins on the training data to reduce the risk of misclassification. In otherwords, we optimized generalization.</p>
<p>Once you have the maximal margin hyperplane, you can classify a new data point <span class="math inline">\(x^*\)</span> by looking at which side of the hyperplane it falls on.</p>
<p>The rule is:
<span class="math display">\[
  f(x^*) = \beta_0 + \beta_1 x_1^* + \beta_2 x_2^* + \cdots + \beta_p x_p^*
  \]</span></p>
<ul>
<li>If f<span class="math inline">\(f(x^*) &gt; 0\)</span>, assign to class +1</li>
<li>If <span class="math inline">\(f(x^*) &lt; 0\)</span>, assign to class -1</li>
<li>The coefficients <span class="math inline">\(\beta_0, \beta_1, ..., \beta_p\)</span> are those that define the maximal margin hyperplane.</li>
</ul>
<p>The maximal margin hyperplane lies at the center of the widest possible “slab” (region between two parallel hyperplanes) that can be fit between the two classes, such that no points lie inside the slab.</p>
<p>If you examine the data, you will typically find that some points are exactly at the edge of the margin, i.e., they are closest to the maximal margin hyperplane.</p>
<p>These points are called support vectors.</p>
<p>They are “supporting” the maximal margin hyperplane in the sense that if you moved any one of these points, the position of the maximal margin hyperplane would change.
Only these points matter for determining the hyperplane: moving any other point (that is farther from the margin) will not affect the maximal margin hyperplane, as long as it does not cross into the margin.</p>
<p>In 2D, you usually see two parallel dashed lines on either side of the maximal margin hyperplane, and the support vectors are the points that lie exactly on these dashed lines.</p>
<p>In any number of dimensions, support vectors are the points that are at the minimal distance from the hyperplane. The number of support vectors is at least p (the number of features), but can be more.
The property that only the support vectors determine the hyperplane is crucial; it leads to efficient algorithms and is a key idea in support vector machines (SVMs).</p>
<p>Overfitting and High Dimensions</p>
<p>While the maximal margin classifier is often successful, it can overfit when the number of features <span class="math inline">\(p\)</span> is large compared to the number of data points <span class="math inline">\(n\)</span>.
That is, in high-dimensional spaces, even random or noisy data can sometimes be perfectly separated, but the resulting hyperplane may not generalize well to new data.</p>
</div>
<div id="construction-of-the-maximal-margin-classifier" class="section level5 hasAnchor" number="5.2.10.1.4">
<h5><span class="header-section-number">5.2.10.1.4</span> Construction of the Maximal Margin Classifier<a href="statistical-inference.html#construction-of-the-maximal-margin-classifier" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>Suppose you have a dataset consisting of n training observations. Each observation is a point in <span class="math inline">\(p\)</span>-dimensional space, denoted as:
<span class="math display">\[
x_1, x_2, \ldots, x_n \in \mathbb{R}^p
\]</span></p>
<p>Each observation <span class="math inline">\(x_i\)</span> is associated with a class label <span class="math inline">\(y_i\)</span>, where <span class="math inline">\(y_i\)</span> can take on one of two possible values: -1 or +1. That is,
<span class="math display">\[
y_1, y_2, \ldots, y_n \in \{-1, 1\}
\]</span>
The goal is to find the maximal margin hyperplane: a separating hyperplane that maximizes the minimum distance (the margin) between itself and any of the training observations. This hyperplane will be used as a classifier.</p>
<p>The Optimization Problem
To find the maximal margin hyperplane, you need to solve the following optimization problem. You are searching for the values of the hyperplane parameters <span class="math inline">\(\beta_0, \beta_1, \ldots, \beta_p\)</span> and the margin <span class="math inline">\(M\)</span>:</p>
<p><span class="math display">\[
\underset{\beta_0, \beta_1, \ldots, \beta_p, M}{\text{maximize}} \quad M
\]</span></p>
<p>You want to make the margin M as large as possible.
Subject to (Constraints):</p>
<ol style="list-style-type: decimal">
<li>Normalization Constraint:
<span class="math display">\[
\sum_{j=1}^{p} \beta_j^2 = 1
\]</span></li>
</ol>
<p>This means the vector of coefficients <span class="math inline">\((\beta_1, \beta_2, \ldots, \beta_p)\)</span> has length 1 (unit norm). It’s a mathematical trick to ensure that the margin is measured in a consistent way; otherwise, you could make the margin arbitrarily large by simply scaling all the coefficients.</p>
<ol start="2" style="list-style-type: decimal">
<li>Margin Constraint:
<span class="math display">\[
y_i \left(\beta_0 + \beta_1 x_{i1} + \beta_2 x_{i2} + \cdots + \beta_p x_{ip}\right) \geq M \qquad \forall i = 1, \ldots, n
\]</span></li>
</ol>
<p>This must hold for every observation in the training set.</p>
<ul>
<li>If <span class="math inline">\(y_i = +1\)</span>, this constraint requires that the hyperplane function at <span class="math inline">\(x_i\)</span> is at least M (i.e., at least margin M away from the hyperplane, on the correct side).</li>
<li>If <span class="math inline">\(y_i = -1\)</span>, the constraint requires the hyperplane function at <span class="math inline">\(x_i\)</span> is at most -<span class="math inline">\(M\)</span> (i.e., at least margin M away from the hyperplane, but on the other side).</li>
<li>In both cases, the left-hand side must be at least <span class="math inline">\(M\)</span>, so all observations are not only on the correct side of the hyperplane, but also at least a distance <span class="math inline">\(M\)</span> away from it.</li>
</ul>
<p>Margin Constraint
The constraint
<span class="math display">\[
y_{i}\left(\beta_{0}+\beta_{1} x_{i 1}+\beta_{2} x_{i 2}+\cdots+\beta_{p} x_{i p}\right) \geq M
\]</span></p>
<p>ensures that every point is not just classified correctly, but with some cushion or buffer of size <span class="math inline">\(M\)</span>, which is the margin. This is a stricter requirement than simply being on the correct side.</p>
<p>Normalization Constraint
The constraint
<span class="math display">\[
\sum_{j=1}^{p} \beta_j^2 = 1
\]</span></p>
<p>is needed because without it, the coefficients could be scaled up or down arbitrarily, which would make the margin <span class="math inline">\(M\)</span> meaningless (since both the coefficients and margin would scale together). By fixing the length of the coefficient vector, the margin is a real, interpretable distance.</p>
<p>Invariance to Scaling
If you have a hyperplane defined by
<span class="math display">\[
\beta_0 + \beta_1 x_{i1} + \beta_2 x_{i2} + \cdots + \beta_p x_{ip} = 0
\]</span></p>
<p>then multiplying all coefficients by any nonzero constant <span class="math inline">\(k\)</span> (i.e., using <span class="math inline">\(k \beta_0, k \beta_1, \ldots, k \beta_p\)</span>) gives the same hyperplane:</p>
<p><span class="math display">\[
k\left(\beta_0 + \beta_1 x_{i1} + \beta_2 x_{i2} + \cdots + \beta_p x_{ip}\right) = 0
\]</span></p>
<p>So, the normalization constraint makes sure we’re only considering one scaling for the coefficients.</p>
<p>Perpendicular Distance to the Hyperplane
The formula
<span class="math display">\[
y_{i}\left(\beta_{0}+\beta_{1} x_{i 1}+\beta_{2} x_{i 2}+\cdots+\beta_{p} x_{i p}\right)
\]</span></p>
<p>with the normalization constraint in place, gives the perpendicular distance from the <span class="math inline">\(i\)</span>-th training observation to the hyperplane. This is because, when the norm of the coefficient vector is 1, the value inside the parentheses is the signed distance from the point to the hyperplane along the normal direction (the direction perpendicular to the hyperplane).</p>
</div>
<div id="the-non-separable-case" class="section level5 hasAnchor" number="5.2.10.1.5">
<h5><span class="header-section-number">5.2.10.1.5</span> The Non-separable Case<a href="statistical-inference.html#the-non-separable-case" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>The Non-separable Case in Classification
Maximal Margin Classifier and Its Limitation
The maximal margin classifier is a method for classifying data that works by finding the separating hyperplane with the largest possible margin between two classes. This approach is only feasible if the data are linearly separable—that is, if there exists at least one hyperplane that puts all data points of one class on one side, and all points of the other class on the other side, with no errors.
This requirement is formalized mathematically:</p>
<p>The optimization problem (described in the previous section, involving maximizing <span class="math inline">\(M\)</span> subject to all training points being at least margin <span class="math inline">\(M\)</span> from the hyperplane and on the correct side) only has a solution with M&gt;0 if and only if the data is perfectly separable.
If even a single data point is on the wrong side (for example, due to noise, outliers, or overlapping distributions), no hyperplane can satisfy all the constraints, and thus the optimization problem has no feasible solution with a positive margin.</p>
<p>When Data Is Not Linearly Separable
In many real-world situations, data from two (or more) classes overlap in feature space. This means:</p>
<p>There may be points from both classes that are intermingled or close together in some regions.
There may be outliers, or the boundary between classes may be nonlinear, or the features may not provide enough information to separate the classes perfectly.</p>
<p>In such cases:</p>
<p>No separating hyperplane exists that can perfectly divide the data into two classes with all points correctly classified.
The optimization problem for the maximal margin classifier cannot produce a solution where <span class="math inline">\(M &gt; 0\)</span>, because at least one constraint will always be violated (a point will be on the wrong side or within the margin).</p>
<p>What Happens Next?
While perfect separation may not be possible, we still want a classifier that performs well, ideally by finding a boundary that almost separates the classes as well as possible. This leads to the idea of relaxing the constraints of the maximal margin classifier.
Soft Margin and the Support Vector Classifier</p>
<p>Soft margin: Instead of requiring every point to be perfectly classified and at least margin <span class="math inline">\(M\)</span> away from the hyperplane, we allow some points to:</p>
<p>Be on the wrong side of the hyperplane (misclassified).
Lie within the margin (correctly classified but too close to the boundary).</p>
<p>The idea is to find a balance: maximize the margin as much as possible, but permit some violations of the constraints, penalizing them in the optimization.
This is called the soft margin approach.</p>
<p>Support Vector Classifier</p>
<p>The support vector classifier is the generalization of the maximal margin classifier to the non-separable case.
It introduces new variables (called slack variables) and a penalty parameter to control the trade-off between margin size and classification errors.
The optimization problem is adjusted to allow constraint violations, but penalizes them—so the solution is a hyperplane that “almost” separates the classes, but with the best possible trade-off between margin and misclassifications.</p>
<p>Generalization</p>
<p>This issue (no separating hyperplane) can arise in any dimension (<span class="math inline">\(p\)</span>), with any number of points (<span class="math inline">\(n\)</span>), and for any arrangement of feature values and labels.
The soft margin approach and support vector classifier can be used in all these cases, and are the foundation for support vector machines (SVMs).</p>
</div>
</div>
<div id="support-vector-classifiers" class="section level4 hasAnchor" number="5.2.10.2">
<h4><span class="header-section-number">5.2.10.2</span> Support Vector Classifiers<a href="statistical-inference.html#support-vector-classifiers" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<div id="overview-of-the-support-vector-classifier" class="section level5 hasAnchor" number="5.2.10.2.1">
<h5><span class="header-section-number">5.2.10.2.1</span> Overview of the Support Vector Classifier<a href="statistical-inference.html#overview-of-the-support-vector-classifier" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>Support Vector Classifiers: Motivation and Principles
Non-separability of Classes
In real-world data, observations from two classes are not always linearly separable—that is, you cannot always draw a straight line (in two dimensions), a flat plane (in three dimensions), or a hyperplane (in higher dimensions) that perfectly divides the classes so that all points from one class are on one side and all points from the other class are on the other side. This fundamental issue is illustrated in Figure 9.4, where some data points from each class are intermingled in such a way that no hyperplane exists to perfectly separate them.
Even When a Separating Hyperplane Exists
Even in situations where a separating hyperplane does exist, using it for classification may not be the best approach. Why? Because:</p>
<p>Perfect Separation = Perfect Fit to Training Data: A classifier based solely on a separating hyperplane will always classify all training data perfectly. Every data point will be on the correct side of the hyperplane (by construction).
Overfitting Risk: If the classifier is forced to fit every training example perfectly, it can become overly sensitive to small changes or outliers in the data.</p>
<p>Sensitivity and Margin
The distance of a data point to the hyperplane is called its margin. The margin is a measure of how confident the classifier is in its prediction for that point: the farther the point is from the hyperplane, the more confident the classifier is.
Sensitivity to Observations</p>
<p>If you add a single new observation, especially if it’s an outlier or on the “edge,” the separating hyperplane can shift dramatically to accommodate it.
As shown in Figure 9.5, the addition of just one new point can cause the hyperplane to move significantly, reducing the margin and confidence for other points.
This means the maximal margin hyperplane is not robust: it is highly sensitive to minor changes in the data.</p>
<p>Overfitting</p>
<p>Overfitting occurs when a classifier models not only the underlying pattern but also the noise or peculiarities of the training data.
A maximal margin classifier that fits every point (including outliers) perfectly may generalize poorly to new, unseen data because it is too closely tailored to the specifics of the training set.
The margin may become very small or “tiny,” which indicates low confidence in the classifications.</p>
<p>Why Allow Imperfect Separation?
Given this sensitivity and overfitting risk, it is often better to use a classifier that does not require perfect separation of the two classes. In practice, this means:</p>
<p>Allowing some points to be misclassified (on the wrong side of the hyperplane).
Allowing some points to be within the margin (too close to the boundary, even if on the correct side).
Focusing on better classification of most points, rather than perfect classification of all points.</p>
<p>This leads to greater robustness, meaning the classifier is less affected by noise, outliers, or small changes in the data.</p>
<p>The Support Vector Classifier (Soft Margin Classifier)
What Is It?</p>
<p>The support vector classifier (also called the soft margin classifier) generalizes the maximal margin classifier to allow for errors and margin violations.
The goal is no longer to find a hyperplane that perfectly separates the classes with the widest possible margin, but rather to find a hyperplane that balances two objectives:</p>
<p>Maximizing the margin (distance from the hyperplane to the nearest points).
Minimizing the number and severity of constraint violations (misclassified or margin-violating points).</p>
<p>How Does It Work?</p>
<p>Slack Variables: Instead of requiring every point to be on the correct side of the margin (as with the hard margin/maximal margin classifier), we introduce variables that allow some points to fall inside the margin or even on the wrong side of the hyperplane.
Penalty Parameter: The optimization problem includes a parameter that controls how much penalty is assigned to points that violate the margin or are misclassified. This balances the trade-off between margin size and classification errors.
Soft Margin: The margin is called “soft” because it is not strict; some points can violate it.</p>
<p>What Does It Achieve?</p>
<p>Most Points Correct: Most training observations will be on the correct side of the margin and hyperplane, but a small subset may not be.
Some Misclassifications: When perfect separation is impossible, some points will necessarily be misclassified (on the wrong side of the hyperplane).
Generalization: By not insisting on perfect classification, the support vector classifier often achieves better generalization to new data.</p>
<p>Generalization and Scenarios</p>
<p>These methods apply to any number of features (<span class="math inline">\(p\)</span>), any number of observations (<span class="math inline">\(n\)</span>), and any layout of data—even if the classes are highly overlapping, or if outliers are present.
The approach is robust to the addition or removal of a few atypical points.
It can be adjusted (via the penalty parameter) to tolerate more or fewer errors depending on the specific problem or the cost of misclassification.</p>
<p>Summary of Key Points</p>
<p>Separating hyperplanes may not exist, or may not be desirable due to overfitting and sensitivity.
Support vector classifiers allow for misclassification of training data (soft margin), leading to increased robustness and better performance on new data.
Soft margin classifiers are designed to find the best trade-off between margin width and misclassification, rather than perfect separation.</p>
</div>
<div id="details-of-the-support-vector-classifier" class="section level5 hasAnchor" number="5.2.10.2.2">
<h5><span class="header-section-number">5.2.10.2.2</span> Details of the Support Vector Classifier<a href="statistical-inference.html#details-of-the-support-vector-classifier" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>The support vector classifier is a classification method that finds a hyperplane to separate two classes, but unlike the maximal margin classifier, it allows some flexibility:</p>
<p>Most training observations are separated correctly (on the right side and outside the margin),
A small number may be on the wrong side of the margin,
And a smaller number may even be on the wrong side of the hyperplane (misclassified).</p>
<p>This method is particularly useful when perfect separation is not possible or not desirable, due to overlapping classes, noise, or outliers.</p>
<p>The Optimization Problem (Soft Margin SVM)
The support vector classifier is defined formally by solving the following optimization problem:
Variables</p>
<ul>
<li><span class="math inline">\(\beta_0, \beta_1, \ldots, \beta_p\)</span>: coefficients of the hyperplane</li>
<li><span class="math inline">\(M\)</span>: the margin (width between the closest points and the hyperplane)</li>
<li><span class="math inline">\(\epsilon_1, \ldots, \epsilon_n\)</span>: slack variables, one for each observation, quantifying margin or classification violations</li>
</ul>
<p><span class="math display">\[
\underset{\beta_0, \beta_1, \ldots, \beta_p, \epsilon_1, \ldots, \epsilon_n, M}{\text{maximize}} \quad M
\]</span></p>
<p>The goal is to make the margin <span class="math inline">\(M\)</span> as large as possible, while allowing for possible violations.
Constraints</p>
<ol style="list-style-type: decimal">
<li>Normalization:
<span class="math display">\[
\sum_{j=1}^{p} \beta_j^2 = 1
\]</span></li>
</ol>
<p>This ensures the coefficients define the margin in a standardized way, avoiding arbitrary scaling.</p>
<ol start="2" style="list-style-type: decimal">
<li>Soft Margin Constraint:
<span class="math display">\[
y_i(\beta_0 + \beta_1 x_{i1} + \beta_2 x_{i2} + \cdots + \beta_p x_{ip}) \geq M(1 - \epsilon_i) \quad \forall i
\]</span></li>
</ol>
<ul>
<li>If <span class="math inline">\(\epsilon_i = 0\)</span>, the <span class="math inline">\(i\)</span>th observation is on the correct side of the margin (at least distance M from the hyperplane).</li>
<li>If <span class="math inline">\(0 &lt; \epsilon_i \leq 1\)</span>, the ith observation is inside the margin but on the correct side of the hyperplane (closer than <span class="math inline">\(M\)</span>).</li>
<li>If <span class="math inline">\(\epsilon_i &gt; 1\)</span>, the ith observation is on the wrong side of the hyperplane (misclassified).</li>
</ul>
<ol start="3" style="list-style-type: decimal">
<li>Slack variables non-negative:</li>
</ol>
<p><span class="math display">\[
   \epsilon_i \geq 0
   \]</span></p>
<p>Negative slack makes no sense (would mean more than perfect separation).</p>
<ol start="4" style="list-style-type: decimal">
<li>Budget on violations (“C constraint”):</li>
</ol>
<p><span class="math display">\[
   \sum_{i=1}^n \epsilon_i \leq C
   \]</span></p>
<p><span class="math inline">\(C\)</span> is a non-negative parameter (called the tuning parameter or budget). It controls how much total violation to the margin and hyperplane is tolerated across all data.</p>
<p>Interpretation of Each Constraint and Parameter
Slack Variables <span class="math inline">\(\epsilon_i\)</span></p>
<p>Each slack variable <span class="math inline">\(\epsilon_i\)</span> quantifies how much the ith data point violates the margin constraint:</p>
<ul>
<li><span class="math inline">\(\epsilon_i = 0\)</span>: correctly classified, at least margin M away from the hyperplane (ideal case).</li>
<li><span class="math inline">\(0 &lt; \epsilon_i \leq 1\)</span>: on the correct side of the hyperplane, but inside the margin (not as confidently classified).</li>
<li><span class="math inline">\(\epsilon_i &gt; 1\)</span>: on the wrong side of the hyperplane (misclassified).</li>
</ul>
<p>Tuning Parameter (<span class="math inline">\(C\)</span>)</p>
<p>The sum of all slack variables is at most <span class="math inline">\(C\)</span>, so:</p>
<ul>
<li>Smaller <span class="math inline">\(C\)</span>: Less tolerance for violations—margin is narrower, fewer misclassifications or margin violations are allowed, more “rigid” fit.</li>
<li>Larger <span class="math inline">\(C\)</span>: More tolerance for violations—margin can be wider, more misclassifications or violations are allowed, less rigid fit.</li>
</ul>
<p><span class="math inline">\(C\)</span> can be chosen using cross-validation or other model selection methods to optimize out-of-sample (test) performance.
If <span class="math inline">\(C = 0\)</span>, then all <span class="math inline">\(\epsilon_i = 0\)</span>, and the problem reduces to the maximal margin classifier (hard margin SVM), which only works if the data is perfectly separable.</p>
<p>Geometric and Statistical Implications</p>
<p>The resulting hyperplane is not affected by points that are well away from the margin and on the correct side—only the points close to or inside the margin (or misclassified) matter.
These influential points are called support vectors.</p>
<p>Support vectors are the observations that either:</p>
<p>Lie exactly on the margin (<span class="math inline">\(\epsilon_i = 0\)</span> and margin constraint is tight),
Violate the margin (<span class="math inline">\(\epsilon_i &gt; 0\)</span>), including those that are misclassified (<span class="math inline">\(\epsilon_i &gt; 1\)</span>).</p>
<p>The position of other (non-support vector) observations does not affect the solution.</p>
<p>Bias-Variance Trade-off (Role of <span class="math inline">\(C\)</span>)</p>
<p>When <span class="math inline">\(C\)</span> is large:</p>
<ul>
<li>Margin is wide.</li>
<li>Many points violate the margin.</li>
<li>Many support vectors.</li>
<li>Classifier is less sensitive to individual points (lower variance), but may underfit (higher bias).</li>
</ul>
<p>When <span class="math inline">\(C\)</span> is small:</p>
<ul>
<li>Margin is narrow.</li>
<li>Few points violate the margin.</li>
<li>Fewer support vectors.</li>
<li>Classifier fits the training data more closely (lower bias), but may be more sensitive to noise or outliers (higher variance).</li>
</ul>
<p>Comparison With Other Methods</p>
<p>Support vector classifier depends only on a subset of observations (support vectors), making it robust to outliers or changes far from the decision boundary.
Linear discriminant analysis (LDA), in contrast, depends on the means and covariance of all observations in each class.</p>
<p>This means that every observation, even those far from the decision boundary, influences the classifier.</p>
<p>Logistic regression is similar to the support vector classifier in that it is also less sensitive to outlying observations far from the decision boundary.</p>
<p>If you adjust <span class="math inline">\(C\)</span>:</p>
<p>High <span class="math inline">\(C\)</span>: The classifier allows more violations, margin is larger, more points are support vectors.
Low <span class="math inline">\(C\)</span>: The classifier allows fewer violations, margin is smaller, fewer points are support vectors.
As <span class="math inline">\(C\)</span> changes, the number of support vectors and the width of the margin change accordingly.</p>
</div>
</div>
<div id="support-vector-machines-1" class="section level4 hasAnchor" number="5.2.10.3">
<h4><span class="header-section-number">5.2.10.3</span> Support Vector Machines<a href="statistical-inference.html#support-vector-machines-1" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<div id="classification-with-non-linerar-decision-boundaries" class="section level5 hasAnchor" number="5.2.10.3.1">
<h5><span class="header-section-number">5.2.10.3.1</span> Classification with Non-Linerar Decision Boundaries<a href="statistical-inference.html#classification-with-non-linerar-decision-boundaries" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>Converting Linear to Non-Linear Classifiers
The main idea is to start from a linear classifier (like a support vector classifier), which constructs a linear decision boundary between two classes, and find a general mechanism to convert it into a classifier that can handle non-linear boundaries between classes. The support vector machine (SVM) accomplishes this in an automatic and computationally efficient way.</p>
<p>9.3.1 Classification with Non-Linear Decision Boundaries
Limitations of Linear Classifiers</p>
<p>The support vector classifier is designed for situations where the boundary between two classes is linear; that is, the classes can be separated by a straight line (in 2D), a plane (in 3D), or a hyperplane (in higher dimensions).
In practice, class boundaries are often non-linear. This means a straight line or plane cannot adequately separate the classes.</p>
<p>Analogy to Regression</p>
<p>In regression (Chapter 7), when the relationship between predictors and outcome is non-linear, the performance of linear regression suffers.
To address this, we expand the feature space by including polynomial functions of predictors (e.g., quadratic, cubic terms), so that the model can capture non-linear relationships.</p>
<p>Expanding the Feature Space for Classification</p>
<p>Similarly, for classification, if we suspect (or observe) that the boundary between classes is non-linear, we can enlarge the feature space by including additional features constructed from the original ones, such as:</p>
<p>Quadratic terms: <span class="math inline">\(X_1^2, X_2^2, \ldots, X_p^2\)</span>
Cubic terms: <span class="math inline">\(X_1^3, X_2^3, \ldots, X_p^3\)</span>
Higher-order polynomials: <span class="math inline">\(X_j^d\)</span> for degree <span class="math inline">\(d\)</span>
Interaction terms: <span class="math inline">\(X_j X_{j&#39;}\)</span> for <span class="math inline">\(j \neq j&#39;\)</span>
Other non-linear functions</p>
<p>Example of Enlarged Feature Space
Suppose your original predictors are <span class="math inline">\(X_1, X_2, ..., X_p\)</span>. Instead of fitting a support vector classifier using just these <span class="math inline">\(p\)</span> features, you could expand the feature space to include their squares:</p>
<p><span class="math display">\[
X_1, X_1^2, X_2, X_2^2, ..., X_p, X_p^2
\]</span></p>
<p>This results in <span class="math inline">\(2p\)</span> features: each original feature and its square.</p>
<p>Mathematical Formulation in the Enlarged Space
The optimization problem for the support vector classifier, when using quadratic terms, becomes:
<span class="math display">\[
\begin{aligned}
&amp; \underset{\beta_0, \beta_{11}, \beta_{12}, ..., \beta_{p1}, \beta_{p2}, \epsilon_1, ..., \epsilon_n, M}{\text{maximize}} \quad M \\
&amp; \text{subject to:} \\
&amp; \quad y_i \left( \beta_0 + \sum_{j=1}^{p} \beta_{j1} x_{ij} + \sum_{j=1}^{p} \beta_{j2} x_{ij}^2 \right) \geq M(1 - \epsilon_i), \\
&amp; \quad \sum_{i=1}^n \epsilon_i \leq C, \quad \epsilon_i \geq 0, \\
&amp; \quad \sum_{j=1}^p \sum_{k=1}^2 \beta_{jk}^2 = 1
\end{aligned}
\]</span></p>
<ul>
<li><span class="math inline">\(y_i\)</span> is the class label for observation i.</li>
<li><span class="math inline">\(x_{ij}\)</span> is the value of feature j for observation i.</li>
<li><span class="math inline">\(\beta_0\)</span> is the intercept.</li>
<li><span class="math inline">\(\beta_{j1}\)</span> is the coefficient for the linear term in feature j.</li>
<li><span class="math inline">\(\beta_{j2}\)</span> is the coefficient for the quadratic term in feature j.</li>
<li><span class="math inline">\(\epsilon_i\)</span> are slack variables allowing for violations of the margin.</li>
<li><span class="math inline">\(M\)</span> is the margin to be maximized.</li>
<li><span class="math inline">\(c\)</span> is a parameter controlling the total allowed margin violations.</li>
</ul>
<p>Why Does This Lead to Non-Linear Decision Boundaries?
Geometry in Enlarged Space</p>
<p>In the enlarged feature space (with the quadratic features), the SVM finds a linear boundary (a hyperplane).
But when this boundary is projected back to the original feature space, it becomes a non-linear boundary.</p>
<p>The decision boundary in the original space is of the form <span class="math inline">\(q(x) = 0\)</span>, where <span class="math inline">\(q(x)\)</span> is a quadratic polynomial in the original features.
Generally, such equations define curves (like parabolas, ellipses, or more complicated shapes) rather than straight lines.</p>
<p>Generalization to Other Expansions</p>
<p>One can go beyond quadratic terms:</p>
<p>Cubic terms: <span class="math inline">\(X_1^3, X_2^3, ...\)</span>
Interaction terms: <span class="math inline">\(X_j X_{j&#39;}\)</span> for <span class="math inline">\(j \neq j&#39;\)</span>
Higher-order polynomials: Up to any desired degree.
Other functions: Trigonometric, exponential, indicator functions, etc.</p>
<p>The more complex the expansion, the more flexible the resulting decision boundary.</p>
<p>Computational Considerations</p>
<p>Curse of dimensionality: As you add more and more features (especially for high-degree polynomials or many interactions), the number of features can grow very large, quickly becoming computationally infeasible.
Efficient computation: The key innovation of the support vector machine is that it allows us to enlarge the feature space implicitly (using kernels), enabling the computation of very complex, non-linear boundaries without explicitly computing all new features.</p>
<p>Summary of the Mechanism (no summarizing, just expansion):</p>
<p>Linear classifiers work well only when the class boundary is linear.
When class boundaries are non-linear, one can expand the feature space by adding polynomial (and other) terms.
In the expanded space, the SVM finds a linear boundary, which corresponds to a non-linear boundary in the original space.
This approach can be generalized to any type of non-linear expansion, not just polynomials.
The number of features grows rapidly with the degree and number of predictors, making explicit computation expensive or infeasible for large expansions.
The support vector machine, by using kernels, allows us to benefit from these expansions efficiently, as it computes inner products in the expanded space without ever constructing the expanded feature vectors.</p>
</div>
<div id="the-supoort-vector-machines" class="section level5 hasAnchor" number="5.2.10.3.2">
<h5><span class="header-section-number">5.2.10.3.2</span> The Supoort Vector Machines<a href="statistical-inference.html#the-supoort-vector-machines" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>From Support Vector Classifier to SVM
A support vector machine (SVM) is a powerful generalization of the support vector classifier. The support vector classifier finds a linear boundary (a hyperplane) that best separates two classes, possibly allowing some margin violations as controlled by a tuning parameter. However, real-world data often cannot be separated by a straight line (or plane, or hyperplane) in the original feature space, because the relationship between the features and the classes is non-linear.
Enlarging the Feature Space
To solve this, SVMs enlarge the feature space—they implicitly map the original features into a higher-dimensional (even infinite-dimensional) space, where a linear separation might be possible. This mapping is performed not by directly computing new features, but by using a mathematical tool called a kernel.</p>
<p>A kernel is a function that quantifies the similarity between two observations, and mathematically it generalizes the concept of an inner product in the original feature space.
The Inner Product
Given two vectors <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> in <span class="math inline">\(\mathbb{R}^r\)</span>, their inner product is
<span class="math display">\[
\langle a, b \rangle = \sum_{i=1}^{r} a_i b_i
\]</span></p>
<p><span class="math display">\[
\langle a, b \rangle = \sum_{i=1}^{r} a_i b_i
\]</span></p>
<p>This is a measure of similarity, giving a large value when a and b point in similar directions.
For two observations xi​,xi′​ in a p-dimensional feature space, the inner product is</p>
<p><span class="math display">\[
\langle x_i, x_{i&#39;} \rangle = \sum_{j=1}^{p} x_{ij} x_{i&#39;j}
\]</span></p>
<p>This is the basis of the linear kernel.</p>
<p>The Support Vector Classifier in Terms of Inner Products
It can be shown that the decision function for the linear support vector classifier can be written as:
<span class="math display">\[
f(x) = \beta_0 + \sum_{i=1}^n \alpha_i \langle x, x_i \rangle
\]</span></p>
<p>where</p>
<ul>
<li><span class="math inline">\(\beta_0\)</span> is the intercept,</li>
<li><span class="math inline">\(\alpha_i\)</span> are coefficients determined during training, one for each training observation <span class="math inline">\(x_i\)</span>.</li>
</ul>
<p>However, only the support vectors (points on or inside the margin, or misclassified) have non-zero <span class="math inline">\(\alpha_i\)</span>. For all other points, <span class="math inline">\(\alpha_i = 0\)</span>. Thus, we can rewrite the function more efficiently as:</p>
<p><span class="math display">\[
f(x) = \beta_0 + \sum_{i \in S} \alpha_i \langle x, x_i \rangle
\]</span></p>
<p>where <span class="math inline">\(S\)</span> is the set of indices for the support vectors.
Key point: To compute <span class="math inline">\(f(x)\)</span> for any new point, we only need the inner product between x and each support vector. All other training points play no role in the prediction.</p>
<p>Generalizing the Inner Product: The Kernel Function
Suppose, instead of just using the linear inner product, we use a more general function K that measures similarity in a potentially more complex way:
<span class="math display">\[
K(x_i, x_{i&#39;}) = \text{kernel function applied to } x_i \text{ and } x_{i&#39;}
\]</span></p>
<p>Now, the decision function becomes:
<span class="math display">\[
f(x) = \beta_0 + \sum_{i \in S} \alpha_i K(x, x_i)
\]</span></p>
<p>This allows the SVM to find non-linear boundaries in the original feature space, because the kernel <span class="math inline">\(K\)</span> implicitly maps the data into a higher-dimensional space where a linear separation is possible.
You never actually need to compute the coordinates in the high-dimensional space; you only need to compute <span class="math inline">\(K(x, x_i)\)</span> for pairs of points.</p>
<p>Types of Kernels
Linear Kernel</p>
<p><span class="math display">\[
K(x_i, x_{i&#39;}) = \langle x_i, x_{i&#39;} \rangle = \sum_{j=1}^{p} x_{ij} x_{i&#39;j}
\]</span></p>
<p>This corresponds to the standard support vector classifier: the boundary is linear in the original features.
Polynomial Kernel</p>
<p><span class="math display">\[
K(x_i, x_{i&#39;}) = \left(1 + \sum_{j=1}^p x_{ij} x_{i&#39;j} \right)^d
\]</span></p>
<ul>
<li><span class="math inline">\(d\)</span> is a positive integer, the degree of the polynomial.</li>
<li>When <span class="math inline">\(d = 1\)</span>, this is just the linear kernel.</li>
<li>When <span class="math inline">\(d &gt; 1\)</span>, the boundary in the original feature space becomes more flexible, allowing for curved or more complex shapes. This is equivalent to implicitly fitting a classifier in a space of polynomial features up to degree d.</li>
</ul>
<p>Radial (Gaussian) Kernel
<span class="math display">\[
K(x_i, x_{i&#39;}) = \exp\left(-\gamma \sum_{j=1}^{p}(x_{ij} - x_{i&#39;j})^2\right)
\]</span></p>
<ul>
<li><span class="math inline">\(\gamma\)</span> is a positive parameter that controls the width of the kernel.</li>
<li>This kernel measures similarity based on distance between points. If two points are close, the value is near 1; if far, it is near 0.</li>
<li>This kernel is local: only nearby points have significant influence on the decision for a new observation.</li>
</ul>
<p>Decision Function With Kernels
With any kernel, the SVM decision function is always:
<span class="math display">\[
f(x) = \beta_0 + \sum_{i \in S} \alpha_i K(x, x_i)
\]</span></p>
<p>The sign of <span class="math inline">\(f(x)\)</span> determines the predicted class label.
Key insights:</p>
<p>The SVM’s decision for a new point depends only on its similarity (under the kernel) to the support vectors.
The choice of kernel determines the flexibility and shape of the decision boundary.
Kernels allow SVMs to efficiently compute decision boundaries in spaces that may be vastly higher-dimensional than the original feature space, or even infinite-dimensional (as with the radial kernel).</p>
<p>Kernel trick: By using kernel functions, all computations can be done in terms of the kernel without explicitly transforming data into the higher-dimensional or infinite-dimensional space.
This makes SVMs practical even for very large or complex feature spaces, because the actual computations never leave the original feature space.
For n training observations, you need only compute the kernel for each pair, i.e., <span class="math inline">\(K(x_i, x_{i&#39;})\)</span> for all pairs, which is <span class="math inline">\(\binom{n}{2}\)</span> computations.</p>
<p>Local and Global Behavior</p>
<p>Linear kernel: All points influence the decision globally.
Polynomial kernel: Influence can be more complex, depending on the degree.
Radial kernel: Only points near the test point (in Euclidean distance) influence its classification—far points have negligible effect.</p>
<p>Generalization</p>
<p>Any function <span class="math inline">\(K(x_i, x_{i&#39;})\)</span> that satisfies appropriate mathematical properties (symmetric and positive semi-definite) can serve as a kernel.
The SVM can thus be adapted to a wide variety of tasks, data types, and notions of similarity.</p>
<p>Summary (with no information skipped or summarized):</p>
<p>SVM extends the support vector classifier by allowing complex, nonlinear boundaries using kernels.
Kernels are functions that generalize the inner product to measure similarity in possibly complex ways.
The decision function of an SVM can always be written in terms of kernel evaluations with the support vectors.
Linear kernel yields a linear boundary; polynomial kernel yields a polynomial boundary; radial kernel yields a highly flexible, local boundary.
The kernel trick allows SVMs to work in implicitly vast or infinite-dimensional spaces without explicit computation in those spaces.
Only the support vectors (usually a subset of the training data) determine the boundary; all other observations have no effect on the decision function.
The behavior of the SVM decision boundary (global vs. local, linear vs. nonlinear) is determined by the choice of kernel and its parameters.</p>
</div>
<div id="an-application-to-the-heart-disease-data" class="section level5 hasAnchor" number="5.2.10.3.3">
<h5><span class="header-section-number">5.2.10.3.3</span> An Application to the Heart Disease Data<a href="statistical-inference.html#an-application-to-the-heart-disease-data" class="anchor-section" aria-label="Anchor link to header"></a></h5>
</div>
</div>
<div id="svm-with-more-than-two-classes" class="section level4 hasAnchor" number="5.2.10.4">
<h4><span class="header-section-number">5.2.10.4</span> SVM with More than Two classes<a href="statistical-inference.html#svm-with-more-than-two-classes" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>SVMs With More Than Two Classes
Binary Versus Multi-Class Classification
Until now, the discussion of support vector machines (SVMs) has focused exclusively on binary classification—distinguishing between two classes (for example, “yes” vs. “no”, “disease” vs. “no disease”, “cat” vs. “dog”). In binary SVM, a single separating hyperplane is learned, separating the two classes as well as possible (with a margin).
However, in many real-world problems, you must classify observations into one of <span class="math inline">\(K\)</span> classes, where <span class="math inline">\(K &gt; 2\)</span>. For example, classifying images as “cat”, “dog”, or “rabbit” means <span class="math inline">\(K = 3\)</span>.
The Challenge
SVMs are naturally constructed for two-class separation. There is no single hyperplane that can, in general, simultaneously separate more than two classes. Thus, to use SVMs for multi-class problems, we must adapt the approach.
Two Main Approaches: One-Versus-One and One-Versus-All</p>
<div id="one-versus-one-classification" class="section level5 hasAnchor" number="5.2.10.4.1">
<h5><span class="header-section-number">5.2.10.4.1</span> One-Versus-One Classification<a href="statistical-inference.html#one-versus-one-classification" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>Two Main Approaches: One-Versus-One and One-Versus-All
1. One-Versus-One (All-Pairs) Classification</p>
<p>Concept: For <span class="math inline">\(K\)</span> classes, construct a separate SVM classifier for every possible pair of classes.
The number of unique pairs among <span class="math inline">\(K\)</span> classes is:
<span class="math display">\[
  \binom{K}{2} = \frac{K(K-1)}{2}
  \]</span></p>
<p>For each pair <span class="math inline">\((k, k&#39;)\)</span>, fit an SVM that distinguishes class <span class="math inline">\(k\)</span> (coded as +1) from class <span class="math inline">\(k&#39;\)</span> (coded as -1), ignoring all other classes for that classifier.</p>
<p>Classification Process for a Test Observation</p>
<pre><code>1. For a new observation, run it through each of the \(\binom{K}{2}\) SVMs.
2. Each SVM “votes” for one of its two classes (the one it assigns to the observation).
3. Count up the votes: For each class, count how many times it was selected by the pairwise classifiers.
4. Final assignment: Assign the observation to the class with the most votes across all \(\binom{K}{2}\) classifiers.</code></pre>
<p>Generalization: This approach works for any number <span class="math inline">\(K &gt; 2\)</span> of classes.
Advantage: Each classifier only has to distinguish between two classes at a time, so the problem stays as simple as possible.
Disadvantage: The number of classifiers to train and evaluate grows quadratically with <span class="math inline">\(K\)</span>. For large <span class="math inline">\(K\)</span>. this can become computationally expensive.</p>
</div>
<div id="one-versus-all-classification" class="section level5 hasAnchor" number="5.2.10.4.2">
<h5><span class="header-section-number">5.2.10.4.2</span> One-Versus-All Classification<a href="statistical-inference.html#one-versus-all-classification" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<ol start="2" style="list-style-type: decimal">
<li>One-Versus-All (One-Versus-Rest) Classification</li>
</ol>
<p>Concept: For <span class="math inline">\(K\)</span> classes, construct <span class="math inline">\(K\)</span> different SVMs.
Each SVM is trained to distinguish one class (coded as +1) from all the other classes (coded as -1) combined.</p>
<p>Classification Process for a Test Observation</p>
<ol style="list-style-type: decimal">
<li>For each class <span class="math inline">\(k\)</span>, fit an SVM that separates class k from all other classes.</li>
</ol>
<ul>
<li>The SVM for class <span class="math inline">\(k\)</span> yields a set of parameters: <span class="math inline">\(\beta_{0k}, \beta_{1k}, \ldots, \beta_{pk}\)</span></li>
</ul>
<ol start="2" style="list-style-type: decimal">
<li>For a test observation <span class="math inline">\(x^* = (x_1^*, x_2^*, \ldots, x_p^*)\)</span>, compute the score for each class:
<span class="math display">\[
f_k(x^*) = \beta_{0k} + \beta_{1k} x_1^* + \beta_{2k} x_2^* + \cdots + \beta_{pk} x_p^*
\]</span></li>
</ol>
<p>for all <span class="math inline">\(k = 1, \ldots, K\)</span>.
3. Final assignment: Assign the observation to the class k with the largest score <span class="math inline">\(f_k(x^*)\)</span>.
- The largest score corresponds to the highest “confidence” that the observation belongs to that class, according to the SVM for that class.</p>
<p>Generalization: This approach also works for any number <span class="math inline">\(K &gt; 2\)</span> of classes.
Advantage: Only <span class="math inline">\(K\)</span> classifiers are needed (linear in <span class="math inline">\(K\)</span>), so it is computationally simpler for large <span class="math inline">\(K\)</span>.
Disadvantage: Each classifier must learn to separate one class from a potentially very heterogeneous set (“all other classes”), which can be more difficult, especially if classes are not well separated.</p>
<p>Mathematical Details and Generality
Number of Classifiers</p>
<p>One-versus-one: <span class="math inline">\(\binom{K}{2} = \frac{K(K-1)}{2}\)</span> SVMs
One-versus-all: <span class="math inline">\(K\)</span> SVMs</p>
<p>Coding of Classes</p>
<p>In each classifier, the classes being compared are coded as +1 and -1. All other classes are ignored (for one-versus-one) or lumped together as -1 (for one-versus-all).</p>
<p>Decision Rule</p>
<p>One-versus-one: Assign by majority vote across all pairwise comparisons.
One-versus-all: Assign to the class whose SVM gives the largest value of the decision function for the test observation.</p>
<p>Examples of Application (Generalized)
Suppose you have a dataset with <span class="math inline">\(K\)</span> different animal species, and you want to classify new images based on features (such as color, size, shape, etc.).</p>
<p>One-versus-one: You build a separate SVM for every pair of species (cat vs. dog, cat vs. rabbit, dog vs. rabbit, etc.), then combine their votes for each new image.
One-versus-all: For each species, you build an SVM to distinguish that species from all others combined, then, for a new image, assign it to the species whose classifier is most confident.</p>
<p>Summary of the Core Ideas (no skipping or summarizing):</p>
<p>SVMs are fundamentally binary classifiers, and do not naturally extend to multi-class problems.
Two common strategies make SVMs work for any number of classes:</p>
<p>One-versus-one: Build classifiers for every possible pair of classes and use majority voting.
One-versus-all: Build one classifier per class, each distinguishing that class from all others, and assign based on the highest score.</p>
<p>The formulas and decision rules outlined above are general and apply for any number of classes, any type of features, and any SVM kernel (linear, polynomial, radial, etc.).
The choice between one-versus-one and one-versus-all depends on computational constraints, the nature of the data, and class separability.</p>
<p>If you want to see the explicit step-by-step training or prediction process for either method, or want a concrete worked example, just say the word!</p>
</div>
</div>
<div id="relationship-to-logistic-regression" class="section level4 hasAnchor" number="5.2.10.5">
<h4><span class="header-section-number">5.2.10.5</span> Relationship to Logistic Regression<a href="statistical-inference.html#relationship-to-logistic-regression" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Relationship Between SVMs and Logistic Regression
Historical Context and Initial Differences
When support vector machines (SVMs) were first introduced, they were seen as fundamentally different from earlier classification methods such as:</p>
<p>Logistic regression (which models the probability of class membership using a logistic function),
Linear discriminant analysis (which models class boundaries based on statistical assumptions about the data).</p>
<p>SVMs were notable because:</p>
<p>They sought to find a hyperplane that separates the data as much as possible (maximizing the margin).
They allowed for some violations (training points on the “wrong” side of the margin or even the hyperplane).
They introduced the idea of kernels to expand the feature space, making it possible to fit non-linear decision boundaries.</p>
<p>This seemed novel: instead of modeling probabilities, the SVM focused on the geometry of the separating boundary.</p>
<p>Modern View: Deep Connections
Despite these apparent differences, it turns out that SVMs and classical statistical methods (like logistic regression and ridge regression) are deeply related. In fact, the SVM fitting criterion can be rewritten in the familiar “loss + penalty” form that appears throughout statistics and machine learning.</p>
<p>The SVM Objective Function
Let’s formalize the SVM’s objective for a linear support vector classifier. The function to be learned is:</p>
<p><span class="math display">\[
f(X) = \beta_0 + \beta_1 X_1 + \cdots + \beta_p X_p
\]</span></p>
<p>SVM Loss + Penalty Formulation
The SVM criterion (from earlier formulas 9.12–9.15) can be expressed as:</p>
<p><span class="math display">\[
\underset{\beta_0, \beta_1, \ldots, \beta_p}{\operatorname{minimize}} \left\{
\sum_{i=1}^{n} \max \left[0, 1 - y_i f(x_i)\right] + \lambda \sum_{j=1}^{p} \beta_j^2
\right\}
\]</span></p>
<p>where:</p>
<ul>
<li><span class="math inline">\(y_i\)</span> is the class label for observation i, coded as +1 or −1.</li>
<li><span class="math inline">\(f(x_i)\)</span> is the value of the decision function for observation i.</li>
<li><span class="math inline">\(\lambda\)</span> is a nonnegative tuning parameter that controls regularization.</li>
</ul>
<p>Interpreting the Terms</p>
<p><span class="math inline">\(\sum_{i=1}^{n} \max \left[0, 1 - y_i f(x_i)\right]\)</span> is known as the hinge loss:</p>
<ul>
<li><p>For each observation <span class="math inline">\(i\)</span>, calculate <span class="math inline">\(y_i f(x_i)\)</span>.</p></li>
<li><p>If this value is <span class="math inline">\(\geq 1\)</span>, the loss is zero (the point is on the correct side of the margin).</p></li>
<li><p>If this value is <span class="math inline">\(&lt; 1\)</span>, the loss increases linearly as the point moves further into the wrong side or closer to the margin.</p></li>
<li><p><span class="math inline">\(\lambda \sum_{j=1}^{p} \beta_j^2\)</span> is a ridge penalty (also known as L2 regularization), which penalizes the magnitude of the coefficients to prevent overfitting.</p></li>
</ul>
<p>Tuning Parameter λ</p>
<p>Large <span class="math inline">\(\lambda\)</span>: The penalty on coefficients is strong, so <span class="math inline">\(\beta_1, \ldots, \beta_p\)</span>​ are kept small. This allows more margin violations (i.e., more points closer to or on the wrong side of the boundary), leading to a model with higher bias but lower variance (less likely to overfit).
Small <span class="math inline">\(\lambda\)</span>: The penalty is weak, so coefficients can be larger to fit the data more closely. This results in fewer margin violations (points are kept further from the decision boundary), leading to lower bias but higher variance (more likely to overfit).</p>
<p>This is mathematically analogous to the trade-off controlled by the parameter C in the earlier SVM constraint <span class="math inline">\(\sum \epsilon_i \leq C\)</span>.</p>
<p>General “Loss + Penalty” Framework
The above SVM formulation is a specific case of a very general approach used throughout statistics and machine learning:</p>
<p><span class="math display">\[
\underset{\beta_0, \beta_1, \ldots, \beta_p}{\operatorname{minimize}} \left\{
L(\mathbf{X}, \mathbf{y}, \beta) + \lambda P(\beta)
\right\}
\]</span></p>
<p>Where:</p>
<ul>
<li><span class="math inline">\(L(\mathbf{X}, \mathbf{y}, \beta)\)</span> is a loss function that measures how well the model fits the data.</li>
<li><span class="math inline">\(P(\beta)\)</span> is a penalty function (regularization term) that discourages overly complex models.</li>
<li><span class="math inline">\(\lambda\)</span>controls the trade-off</li>
</ul>
<p>Examples:</p>
<p>Ridge regression: Loss is squared error, penalty is sum of squares of coefficients.
<span class="math display">\[
    L(\mathbf{X}, \mathbf{y}, \beta) = \sum_{i=1}^n \left( y_i - \beta_0 - \sum_{j=1}^p x_{ij} \beta_j \right)^2
    \]</span></p>
<p><span class="math display">\[
    P(\beta) = \sum_{j=1}^p \beta_j^2
    \]</span></p>
<p>Lasso: Loss is squared error, penalty is sum of absolute values of coefficients.</p>
<p><span class="math display">\[
    P(\beta) = \sum_{j=1}^p |\beta_j|
    \]</span></p>
<p>SVM: Loss is hinge loss, penalty is sum of squares of coefficients.</p>
<p>Hinge Loss vs. Logistic Loss</p>
<p>Hinge Loss (SVM):
<span class="math display">\[
    L(\mathbf{X}, \mathbf{y}, \beta) = \sum_{i=1}^{n} \max [0, 1 - y_i f(x_i)]
    \]</span></p>
<p>Zero for points “well-classified” (on correct side of margin).
Increases linearly for points inside margin or misclassified.
Only support vectors (points on or inside the margin) contribute to the loss and thus influence the fit.</p>
<p>Logistic Loss (Logistic Regression):</p>
<p>The loss is never exactly zero but is very small for points far from the boundary.
All points influence the fit, but those far from the boundary have much less effect.</p>
<p>Figure 9.12 (not shown here) visually compares these loss functions as a function of yi​(β0​+β1​xi1​+⋯+βp​xip​).</p>
<p>For hinge loss, the loss is exactly zero for values greater than 1.
For logistic loss, the loss is always positive, but rapidly decreases for larger values.</p>
<p>Model Fitting and the Role of Support Vectors</p>
<p>In SVMs, only the support vectors (points with nonzero hinge loss, i.e., those on or inside the margin) influence the classifier’s coefficients.
In logistic regression, all points influence the coefficients, though those far from the decision boundary have less effect.</p>
<p>Bias-Variance Tradeoff, Model Selection, and Flexibility</p>
<p>The tuning parameter λ (or equivalently C) is crucial:</p>
<p>It controls how flexible or rigid the boundary is.
Too much flexibility (small λ, large coefficients) leads to overfitting (low bias, high variance).
Too little flexibility (large λ, small coefficients) leads to underfitting (high bias, low variance).</p>
<p>The right balance is often found using cross-validation or other model selection techniques.</p>
<p>SVMs, Kernels, and Nonlinear Boundaries</p>
<p>SVMs are not unique in using kernels to handle complex, nonlinear boundaries in the data.
You can use kernels with logistic regression or other methods, though historically kernels are more common in SVMs.
The kernel trick allows you to work in very high- or infinite-dimensional feature spaces without explicitly computing those features.</p>
<p>Extension to Regression: Support Vector Regression</p>
<p>SVMs can also be adapted for regression problems (predicting a continuous value, not a class).
Support Vector Regression (SVR):</p>
<p>Instead of minimizing squared error, SVR minimizes a loss that only penalizes residuals outside a specified “margin” (called the ϵ-insensitive loss).
This means only points with large prediction errors influence the coefficients, analogous to support vectors in classification.</p>
<p>Summary of Key Mathematical Ideas (no skipping):</p>
<p>The SVM objective is a combination of hinge loss (which enforces a margin) and an L2 penalty (which controls model complexity), just like regularized regression methods.
Logistic regression uses a similar “loss + penalty” form but with a different loss function.
Both SVM and logistic regression can be interpreted as fitting a linear or nonlinear boundary, with regularization controlling bias-variance tradeoff.
The choice of tuning parameters (like λ or C) is critical for model performance.
Loss functions determine which training points have the most influence: only support vectors for SVM, all points (with diminishing influence) for logistic regression.
The kernel trick can be applied to SVMs and other models to handle non-linear relationships.</p>
</div>
</div>
<div id="deep-learning" class="section level3 hasAnchor" number="5.2.11">
<h3><span class="header-section-number">5.2.11</span> Deep Learning<a href="statistical-inference.html#deep-learning" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Deep learning is a rapidly growing area in machine learning and AI, with neural networks as its foundation. Neural networks gained popularity in the late 1980s but later lost favor to other methods like SVMs and random forests, partly because neural networks required more manual tuning and were often outperformed. However, after 2010, neural networks returned as “deep learning,” achieving notable successes in areas like image and speech recognition due to advances in architectures and the availability of large datasets.</p>
<p>The chapter will cover the basics of neural networks and deep learning, including specialized types such as convolutional neural networks (CNNs) for images and recurrent neural networks (RNNs) for sequences. Practical demonstrations will use the R package keras, which connects to the tensorflow software from Google. The material in this chapter is considered somewhat more challenging than the rest of the book.</p>
<div id="single-layer-neural-network" class="section level4 hasAnchor" number="5.2.11.1">
<h4><span class="header-section-number">5.2.11.1</span> Single Layer Neural Network<a href="statistical-inference.html#single-layer-neural-network" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Input, Structure, and Output
A neural network processes an input vector of <span class="math inline">\(p\)</span> variables:</p>
<p><span class="math display">\[
X = (X_1, X_2, \ldots, X_p)
\]</span></p>
<p>and constructs a nonlinear prediction function:
<span class="math display">\[
f(X)
\]</span></p>
<p><span class="math display">\[
f(X)
\]</span></p>
<p>to estimate or predict a response variable <span class="math inline">\(Y\)</span></p>
<p>What’s unique about a neural network? While earlier models (trees, boosting, generalized additive models) also produce nonlinear predictions, a neural network is characterized by its specific architecture. The structure consists of layers of units: input, hidden, and output.</p>
<p>General Model
The neural network with a single hidden layer is described by:</p>
<p><span class="math display">\[
f(X) = \beta_0 + \sum_{k=1}^{K} \beta_k h_k(X)
\]</span></p>
<p>where <span class="math inline">\(h_k(X)\)</span> is the output or activation from the <span class="math inline">\(k\)</span>th hidden unit.</p>
<p>But <span class="math inline">\(h_k(X)\)</span> itself is a nonlinear transformation of a linear combination of inputs:</p>
<p><span class="math display">\[
h_k(X) = g\left(w_{k0} + \sum_{j=1}^{p} w_{kj} X_j\right)
\]</span></p>
<p>where:</p>
<ul>
<li><span class="math inline">\(w_{k0}\)</span> is a bias (intercept) term for unit k,</li>
<li><span class="math inline">\(w_{kj}\)</span> is the weight from input j to hidden unit k,</li>
<li><span class="math inline">\(g(z)\)</span> is a nonlinear activation function (specified in advance).</li>
</ul>
<p>So, plugging this in, the model becomes:
<span class="math display">\[
f(X) = \beta_0 + \sum_{k=1}^{K} \beta_k \, g\left(w_{k0} + \sum_{j=1}^{p} w_{kj} X_j\right)
\]</span></p>
<p>Step-by-Step Construction</p>
<ol style="list-style-type: decimal">
<li>Linear combination: For each hidden unit k, compute the weighted sum of the inputs plus a bias:</li>
</ol>
<p><span class="math display">\[
    z_k = w_{k0} + \sum_{j=1}^{p} w_{kj} X_j
    \]</span></p>
<ol start="2" style="list-style-type: decimal">
<li>Activation: Apply the activation function:
<span class="math display">\[
A_k = h_k(X) = g(z_k)
\]</span></li>
<li>Output layer: Output <span class="math inline">\(f(X)\)</span> is a linear combination of the activations:
<span class="math display">\[
f(X) = \beta_0 + \sum_{k=1}^{K} \beta_k A_k
\]</span></li>
</ol>
<p>The activation function <span class="math inline">\(g(z)\)</span> introduces nonlinearity. Common choices:
Sigmoid (Logistic) Activation</p>
<p><span class="math display">\[
g(z) = \frac{e^z}{1 + e^z} = \frac{1}{1 + e^{-z}}
\]</span></p>
<ul>
<li>Smooth, S-shaped curve.</li>
<li>Output between 0 and 1.</li>
<li>Historically favored, especially for probability outputs.</li>
</ul>
<p>ReLU (Rectified Linear Unit)</p>
<p><span class="math display">\[
g(z) = (z)_{+} =
\begin{cases}
0 &amp; \text{if } z &lt; 0 \\
z &amp; \text{otherwise}
\end{cases}
\]</span></p>
<p>Outputs zero for negative z, and linear for positive z.
Popular for modern deep neural networks due to efficiency and ease of optimization.</p>
<p>The Role of Nonlinearity</p>
<p>If g(z) is linear (e.g., g(z)=z), the entire network is a linear model of the inputs, no matter how many hidden units are used.
With nonlinear g(z):</p>
<p>The model can capture complex patterns, interactions, and nonlinearities.
The hidden units act as learned “basis functions” (see generalized additive models).</p>
<p>Explicit Example: Nonlinear Interaction
Suppose you have <span class="math inline">\(p=2\)</span> inputs, <span class="math inline">\(X_1, X_2\)</span>, and <span class="math inline">\(K=2\)</span> hidden units with <span class="math inline">\(g(z) = z^2\)</span> (purely for illustration):
Let’s denote weights:</p>
<p><span class="math display">\[
\begin{aligned}
\beta_0 &amp;= 0 \\
\beta_1 &amp;= \frac{1}{4} \\
\beta_2 &amp;= -\frac{1}{4} \\
w_{10} &amp;= 0, \quad w_{11} = 1, \quad w_{12} = 1 \\
w_{20} &amp;= 0, \quad w_{21} = 1, \quad w_{22} = -1
\end{aligned}
\]</span></p>
<p>so:</p>
<p><span class="math display">\[
h_1(X) = (0 + X_1 + X_2)^2 = (X_1 + X_2)^2
\]</span></p>
<p><span class="math display">\[
h_2(X) = (0 + X_1 - X_2)^2 = (X_1 - X_2)^2
\]</span></p>
<p>plut into the output:
<span class="math display">\[
f(X) = \frac{1}{4}(X_1 + X_2)^2 - \frac{1}{4}(X_1 - X_2)^2 = X_1 X_2
\]</span></p>
<p>So, this network computes an interaction between features, a type of nonlinearity not directly available to linear models.</p>
<p>Fitting the Neural Network: Training</p>
<p>All parameters <span class="math inline">\(\beta_0, ..., \beta_K, w_{10}, ..., w_{Kp}\)</span> are learned from data.
For quantitative (regression) tasks, typically minimize the sum of squared errors:</p>
<p><span class="math display">\[
    \sum_{i=1}^{n} (y_i - f(x_i))^2
    \]</span>
For classification, other loss functions may be used (like cross-entropy).</p>
<p>Neural Network Terminology</p>
<p>Input layer: The original input features.
Hidden layer: Units that compute nonlinear transformations (activations) of linear combinations of the inputs.
Output layer: Produces the final output by combining the activations.
Weights: Parameters connecting inputs to hidden units <span class="math inline">\(w_{kj}\)</span>, and hidden units to output <span class="math inline">\(\beta_k\)</span>.</p>
<p>Biological Analogy</p>
<p>Hidden units are like “neurons”: if their activation <span class="math inline">\(A_k\)</span> is close to 1 (sigmoid), they “fire”; if close to 0, they are “silent”.</p>
<p>Application Example: Handwritten Digit Recognition</p>
<p>The MNIST dataset: Each image is a <span class="math inline">\(28 \times 28\)</span> grid of grayscale pixels (<span class="math inline">\(p = 784\)</span> input features).
Each pixel value is an integer from 0 (white) to 255 (black).
Neural networks excel at extracting complex patterns from such high-dimensional input data, learning multiple layers of nonlinear transformations to distinguish digits.</p>
<p>Why Nonlinear Activations Are Essential</p>
<p>Without nonlinearity: The output is just a linear function of the input, regardless of the number of hidden units.
With nonlinearity: The network can approximate highly complex functions, capture interactions, and fit intricate decision boundaries.</p>
</div>
<div id="multilayer-neural-networks" class="section level4 hasAnchor" number="5.2.11.2">
<h4><span class="header-section-number">5.2.11.2</span> Multilayer Neural networks<a href="statistical-inference.html#multilayer-neural-networks" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Why More Layers?</p>
<p>A single hidden layer with enough units can approximate any function, but using more layers makes learning complex functions much more efficient and practical.
Modern neural networks (“deep learning”) often use many hidden layers, each with many units.</p>
<p>Example: Handwritten Digit Recognition (MNIST)
Each image is <span class="math inline">\(28 \times 28 = 784\)</span> pixels, so the input vector has 784 numbers (each pixel’s gray level).
The output is a class label: which digit (0-9) the image represents.
The output is represented using one-hot encoding: a vector of 10 entries, with a 1 in the position for the correct digit and 0 elsewhere.
Example: Network Architecture</p>
<p>Input layer: 784 units (one per pixel).
First hidden layer: 256 units. Each unit computes a nonlinear function of a weighted sum of all 784 inputs.
Second hidden layer: 128 units. Each unit computes a nonlinear function of a weighted sum of all 256 outputs from the previous layer.
Output layer: 10 units (one per digit).</p>
<p>Mathematical Representation</p>
<p>First hidden layer:</p>
<p><span class="math display">\[
  A_k^{(1)} = g\left(w_{k0}^{(1)} + \sum_{j=1}^{p} w_{kj}^{(1)} X_j\right)
  \]</span></p>
<p>for <span class="math inline">\(k = 1, ..., 256\)</span>
Second hidden layer:</p>
<p><span class="math display">\[
  A_\ell^{(2)} = g\left(w_{\ell 0}^{(2)} + \sum_{k=1}^{256} w_{\ell k}^{(2)} A_k^{(1)}\right)
  \]</span></p>
<p>for <span class="math inline">\(\ell = 1, ..., 128\)</span></p>
<p>Output layer:
<span class="math display">\[
  Z_m = \beta_{m0} + \sum_{\ell=1}^{128} \beta_{m\ell} A_\ell^{(2)}
  \]</span></p>
<p>for <span class="math inline">\(m = 0, ..., 9\)</span> (one per digit).</p>
<p>These Zm​ values are then passed through a softmax function to convert them to probabilities:
<span class="math display">\[
  f_m(X) = \frac{e^{Z_m}}{\sum_{\ell=0}^9 e^{Z_{\ell}}}
  \]</span></p>
<p><span class="math display">\[
  f_m(X) = \frac{e^{Z_m}}{\sum_{\ell=0}^9 e^{Z_{\ell}}}
  \]</span></p>
<p>This guarantees all outputs are between 0 and 1 and sum to 1, so they can be interpreted as class probabilities.</p>
<ol start="4" style="list-style-type: decimal">
<li>Training and Loss for Classification</li>
</ol>
<p>For classification, the loss function used is the cross-entropy (also called negative log-likelihood for multinomial logistic regression):</p>
<p><span class="math display">\[
  -\sum_{i=1}^{n} \sum_{m=0}^{9} y_{im} \log(f_m(x_i))
  \]</span></p>
<p>Here, <span class="math inline">\(y_{im}\)</span> is 1 if observation <span class="math inline">\(i\)</span> is of class m, 0 otherwise; <span class="math inline">\(f_m(x_i)\)</span> is the predicted probability for class m on observation <span class="math inline">\(i\)</span>.</p>
<p>The goal is to choose weights and biases to minimize this loss over all the training data.</p>
<ol start="5" style="list-style-type: decimal">
<li>Regularization: Preventing Overfitting
Neural networks can have a huge number of parameters (weights and biases), sometimes more than the number of training observations. This flexibility can cause overfitting: the model fits the training data perfectly but performs poorly on new, unseen data.
Two Types of Regularization</li>
</ol>
<p>Ridge Regularization (L2 penalty):</p>
<p>Adds a penalty proportional to the sum of the squares of all the weights.
Encourages the network to keep weights small, which helps generalize better to new data.</p>
<p>Dropout Regularization:</p>
<p>During training, randomly “drops out” (sets to zero) a random subset of units on each update.
Forces the network to not rely too heavily on any single path through the network, improving robustness.</p>
<ol start="6" style="list-style-type: decimal">
<li>Example Applications and Datasets
MNIST</li>
</ol>
<p>A classic dataset of handwritten digits (0–9), each image is 28×28 pixels.
The input vector has 784 features (pixel values).
The output is one of 10 classes, encoded as a one-hot vector.</p>
<p>CIFAR100</p>
<p>A dataset of colored images from everyday life, with 100 different classes (such as animals, vehicles, objects, etc.).
Each class might have images of different sizes, content, etc.
Neural networks are powerful enough to learn to distinguish many complex classes from raw pixel data.</p>
<ol start="7" style="list-style-type: decimal">
<li>Model Complexity and Parameter Counting</li>
</ol>
<p>Neural networks can be very large. For example, the example network described has over 235,000 parameters (weights and biases), which is far more than the number of parameters in a typical logistic regression model.
If you have 60,000 training images and 235,000+ parameters, you must be careful to use regularization, or the network will “memorize” the training data instead of learning general patterns.</p>
<ol start="8" style="list-style-type: decimal">
<li>Summary of Mathematical Steps</li>
</ol>
<p>Forward pass: Input is passed through each layer, applying linear transformations and then nonlinear activation functions.
Output: Final layer produces either a number (regression) or class probabilities (classification, via softmax).
Loss calculation: Compute error using squared error (regression) or cross-entropy (classification).
Training: Adjust weights and biases to minimize the loss, using optimization algorithms like gradient descent.
Regularization: Add penalties or use dropout to prevent overfitting.</p>
<ol start="9" style="list-style-type: decimal">
<li>Generalization to Any Problem</li>
</ol>
<p>The described structure (input layer, several hidden layers, output layer; weights, biases, activations; nonlinear activation functions; cross-entropy or squared-error loss; regularization) can be adapted to any input/output problem.
For images, the input is all pixel values; for tabular data, it’s numerical or categorical features; for text, it can be word or character encodings.</p>
</div>
<div id="convolution-neural-networks" class="section level4 hasAnchor" number="5.2.11.3">
<h4><span class="header-section-number">5.2.11.3</span> Convolution Neural Networks<a href="statistical-inference.html#convolution-neural-networks" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>What Are CNNs and Why Are They Important?
Convolutional neural networks are a special kind of neural network that have achieved huge success in image recognition and classification, especially since around 2010. They have become the main tool for tasks that involve images, such as recognizing objects in photos, identifying faces, or even self-driving car vision systems.
The Data: Images as Arrays</p>
<p>An image in a computer is made up of tiny dots called pixels. Each pixel has a value that represents its color and brightness.
For color images, each pixel usually has three numbers corresponding to red, green, and blue components (these are called “channels”).
For example, an image might be 32 pixels wide and 32 pixels tall. For a color image, every pixel has three numbers (for the three colors), so the image data forms a three-dimensional array:</p>
<p>The first two dimensions are the spatial dimensions (height and width: 32 x 32).
The third dimension is the channel (color): 3 (one for each color).</p>
<p>This three-dimensional array is called a feature map in the context of neural networks.</p>
<p>Datasets</p>
<p>Large datasets like CIFAR100 contain tens of thousands of images, each labeled with a class (e.g., “dog,” “cat,” “car,” “tree,” etc.).
The CIFAR100 dataset, for instance, has 60,000 images, organized into 100 different classes, grouped into 20 superclasses (like “aquatic mammals,” “flowers,” etc.).
Usually, there is a split into a training set (used to teach the network) and a test set (used to see how well the network learned).</p>
<p>How Do CNNs Work?
CNNs are designed to recognize patterns in images. They do this by mimicking the way humans look at images: by detecting small details (like edges or colors) and then combining these to identify larger patterns (like eyes, ears, or wheels), and finally recognizing whole objects (like a tiger, a car, or a dog).
Step-by-Step Feature Detection</p>
<p>Low-level features: The network first looks for simple patterns—edges, corners, blobs of color. These are very basic building blocks.
High-level features: It then combines these simple patterns to detect more complex shapes—like parts of objects (e.g., an eye, an ear, a wheel).
Whole object detection: By combining the presence of these parts, the network can figure out what object is in the image.</p>
<p>Analogy
Think of how a child learns to draw a face: first, they learn to draw circles and lines (low-level features), then they arrange them to make eyes, mouth, ears (higher-level features), and finally, the whole face (object recognition).</p>
<p>The Architecture: Convolution and Pooling Layers
A CNN is built from two main types of layers:
1. Convolution Layers</p>
<p>These layers scan small regions of the image (often called “filters” or “kernels”) and look for patterns.
Each filter is like a little template that slides over the image and checks how much the template matches the underlying pixels.
The filter’s job is to detect a specific feature (like an edge or a spot of color) wherever it appears in the image.</p>
<p>Mathematical Operation (Generalized)</p>
<p>For each position in the image, the filter computes a weighted sum of the pixel values covered by the filter. If the pattern matches, the output is high; if not, it’s low.
The same filter is used across the whole image, which allows the network to find the same feature no matter where it appears.</p>
<ol start="2" style="list-style-type: decimal">
<li>Pooling Layers</li>
</ol>
<p>These layers reduce the size of the image representation, while keeping the most important information.
The most common pooling operation is “max pooling,” which splits the image into small regions and takes the maximum value in each region.
Pooling makes the network more robust to small changes in the image (like slight shifts or distortions).</p>
<p>Building a Hierarchy of Features</p>
<p>By stacking many convolution and pooling layers, the network can build up a hierarchy:</p>
<p>Early layers find basic patterns.
Middle layers combine these into more complex features.
Final layers recognize entire objects.</p>
<p>The network can learn to recognize, for instance, a tiger by first detecting stripes, colors, shapes of eyes and ears, and then combining these clues to decide “this is a tiger.”</p>
<p>Example from the Text</p>
<p>The figure in the text shows how a cartoon image of a tiger might be recognized by a CNN:</p>
<p>The network finds small features (edges, spots, curves).
It combines them to make compound features (eyes, ears).
These compound features are used to decide that the image is a tiger.</p>
<p>Why Are CNNs Special?</p>
<p>Shared weights: Each convolution filter is used across the whole image, dramatically reducing the number of parameters compared to a fully-connected network.
Translation invariance: Because the same filter is used everywhere, the network can recognize the same object even if it appears in a different part of the image.
Efficiency: By only connecting each output to a small region of the input, CNNs are much more efficient for images than standard neural networks.</p>
<p>Generalization to Any Similar Problem</p>
<p>Although CNNs are best known for image recognition, the same principles can be applied to any data that has a spatial or sequential structure (for example, audio signals, time series, or even text).
The key is the ability to detect local patterns and then build up more complex understanding through a hierarchy of layers.</p>
<p>Summary of Key Concepts and Mathematical Steps</p>
<p>Input: An image is represented as a 3D array (height x width x channels).
Convolution layers: Slide filters over the image, detect local patterns.
Pooling layers: Reduce the size of the representation, keep important features.
Hierarchical learning: By stacking layers, learn increasingly complex features.
Final classification: Use the learned features to assign the image to a class (like “tiger” or “car”).
Training: Adjust the filters and other weights to improve accuracy on labeled images.</p>
<div id="convolution-layer" class="section level5 hasAnchor" number="5.2.11.3.1">
<h5><span class="header-section-number">5.2.11.3.1</span> Convolution Layer<a href="statistical-inference.html#convolution-layer" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>What Is a Convolution Layer?
The Big Picture
A convolution layer is a fundamental building block in convolutional neural networks (CNNs), which are used to process images and other data with a grid-like structure. The main role of a convolution layer is to look for patterns or features (like edges, lines, textures, or shapes) in small regions of an image, and to do this across the whole image.
Convolution Filters: Pattern Detectors</p>
<p>The convolution layer is made up of many convolution filters (also called “kernels”).
What is a filter? Think of a filter as a small square or rectangle of numbers. Each filter is like a tiny template that is designed to detect a specific pattern in part of the image.</p>
<p>For example, one filter might detect horizontal edges (like the boundary between a tiger’s stripe and its fur), another might detect vertical edges, and others might look for corners or spots.</p>
<p>How does a filter work? The filter is slid (or “scanned”) over the image, one small patch at a time.</p>
<p>In each position, the filter checks how much the local region of the image matches the pattern encoded in the filter.</p>
<p>The Convolution Operation: Multiply and Add</p>
<p>At each position, the filter and the corresponding patch of the image are multiplied element-wise (each number in the filter is multiplied by the corresponding number in the image patch).
All these products are then added up to get a single number for that location.
This process is called a convolution.</p>
<p>Example (Generalized):
Imagine you have a small image patch and a filter, both as tiny grids of numbers. If the numbers in the image patch and the numbers in the filter “match up” (meaning the pattern is present), the result will be a large number (high score). If they don’t match up, the result will be smaller.
This multiplication-and-adding is done for every position in the image, so that for every location, we get a score that tells us how much the pattern in the filter is present there.
Output: The Convolved Image (Feature Map)</p>
<p>After the filter has scanned the entire image, we get a new “image” (called a feature map or convolved image) that shows where the filter’s pattern was found most strongly.
If you have multiple filters, you get multiple feature maps, each highlighting a different kind of pattern in the original image.</p>
<p>Mathematical Example (Accessible Explanation)
Suppose you have an image represented as a grid of numbers (imagine a 4x3 matrix for simplicity):</p>
<p><span class="math display">\[
\begin{bmatrix}
a &amp; b &amp; c \\
d &amp; e &amp; f \\
g &amp; h &amp; i \\
j &amp; k &amp; l
\end{bmatrix}
\]</span></p>
<p>And you have a filter that is a smaller grid, say 2x2:
<span class="math display">\[
\begin{bmatrix}
\alpha &amp; \beta \\
\gamma &amp; \delta
\end{bmatrix}
\]</span></p>
<p>To apply the filter:</p>
<ol style="list-style-type: decimal">
<li>Place the filter on the top-left of the image.</li>
<li>Multiply corresponding numbers together and add them up:
<ul>
<li>For the top-left 2x2 patch: <span class="math inline">\(a\alpha + b\beta + d\gamma + e\delta\)</span></li>
</ul></li>
<li>Move the filter one step to the right, and repeat for the next 2x2 patch: <span class="math inline">\(b\alpha + c\beta + e\gamma + f\delta\)</span></li>
<li>Continue this process for every possible location where the filter fits in the image.</li>
<li>The result is a new, smaller grid (the “convolved image”), where each value represents how much the filter’s pattern was found at that spot.</li>
</ol>
<p>The size of the convolved image is smaller than the original, because the filter can only be centered on regions where it fully fits within the image.</p>
<p>Why Is This Useful?</p>
<p>Highlighting features: If a region of the image is similar to the filter’s pattern, the result at that location will be high. This means the filter has “found” its pattern there.
Detecting local patterns everywhere: By scanning the filter across the whole image, the convolution layer can detect where patterns like edges, corners, or textures occur, no matter where they are in the image.</p>
<p>Multiple Filters, Multiple Channels</p>
<p>In practice, images have multiple color channels (red, green, blue), so each filter actually has weights for each channel.
If you use K different filters, you get K output “feature maps”—think of these as new layers of information that capture different patterns.</p>
<p>Applying Nonlinearity</p>
<p>After the convolution, it’s common to apply a nonlinear activation function (like ReLU, which outputs the value itself if it’s positive or zero otherwise) to the result. This helps the network capture more complex patterns.</p>
<p>Summary (No Steps Skipped)</p>
<p>The convolution layer is a pattern detector, scanning for specific features in an image.
Each filter is a small matrix of numbers, designed to find a particular local pattern.
The filter is slid across the image, and at each location, the corresponding values are multiplied and summed.
The output is a new image (feature map) showing where the pattern was detected.
Many filters can be used at once, each producing its own feature map.
This process is the foundation of how CNNs “see” and interpret image data.</p>
</div>
<div id="pooling-layers" class="section level5 hasAnchor" number="5.2.11.3.2">
<h5><span class="header-section-number">5.2.11.3.2</span> Pooling layers<a href="statistical-inference.html#pooling-layers" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>What Is a Pooling Layer?
A pooling layer is a special type of layer used in convolutional neural networks (CNNs) to make the information from an image more manageable and to help the network focus on the most important features. Pooling layers take a large image or feature map and summarize it, creating a smaller version that keeps only the most significant information.</p>
<p>Why Do We Need Pooling?</p>
<p>Reduce size: Images and feature maps can be very large. By shrinking them, pooling makes computations easier and faster, and helps prevent the network from overfitting (memorizing details that are not important).
Preserve important features: Pooling keeps the most important features while discarding less relevant or redundant information.
Location invariance: Pooling helps the network recognize features even if they move a little in the image. For example, a cat’s eye might be in a slightly different spot in two pictures, but pooling helps the network still recognize it.</p>
<p>What Is Max Pooling?
Max pooling is the most common kind of pooling. Here’s how it works:</p>
<p>Divide the image into blocks: The image (or feature map) is divided into non-overlapping small blocks, usually 2x2 squares.
Find the maximum in each block: For each block, look at all the numbers (which might represent brightness, color, or the presence of a feature) and keep only the largest number.
Create a new, smaller image: The collection of these maximum values forms a new, smaller image.</p>
<p>Step-by-Step Example
Suppose you have this 4x4 grid of numbers (could be pixel values or feature activations):</p>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; 2 &amp; 5 &amp; 3 \\
3 &amp; 0 &amp; 1 &amp; 2 \\
2 &amp; 1 &amp; 3 &amp; 4 \\
1 &amp; 1 &amp; 2 &amp; 0
\end{bmatrix}
\]</span></p>
<p>Let’s apply max pooling with 2x2 blocks:
Block 1 (top-left):
<span class="math display">\[
\begin{bmatrix}
1 &amp; 2 \\
3 &amp; 0
\end{bmatrix}
\]</span></p>
<p>Maximum is 3.
Block 2 (top-right):</p>
<p><span class="math display">\[
\begin{bmatrix}
5 &amp; 3 \\
1 &amp; 2
\end{bmatrix}
\]</span></p>
<p>Maximum is 5.
Block 3 (bottom-left):</p>
<p><span class="math display">\[
\begin{bmatrix}
2 &amp; 1 \\
1 &amp; 1
\end{bmatrix}
\]</span></p>
<p>Maximum is 2.
Block 4 (bottom-right):</p>
<p><span class="math display">\[
\begin{bmatrix}
3 &amp; 4 \\
2 &amp; 0
\end{bmatrix}
\]</span></p>
<p>So, after max pooling, the output is a 2x2 grid:
<span class="math display">\[
\begin{bmatrix}
3 &amp; 5 \\
2 &amp; 4
\end{bmatrix}
\]</span></p>
<p>What Does This Achieve?</p>
<p>Compression: The original 4x4 grid becomes a 2x2 grid—a much smaller summary.
Highlighting important features: If any value in a block is large (for example, if a certain edge or pattern is detected strongly in that area), that value will be preserved in the summary.
Location invariance: It doesn’t matter exactly where the large value is within the block; as long as it’s there, it will be kept. So if a feature shifts a little within the block, it’s still recognized.</p>
<p>Other Types of Pooling
While max pooling is most common, there are other pooling methods:</p>
<p>Average pooling: Takes the average of all the values in the block.
Min pooling: Takes the minimum value in the block.
But max pooling tends to work best for most image tasks, as it preserves the strongest responses.</p>
<p>Why Is Pooling Important in Neural Networks?</p>
<p>Faster computation and less memory: Smaller images/feature maps mean the next layers have less work to do.
Helps generalization: By summarizing, pooling prevents overfitting to tiny details, helping the model recognize features even if they are not in exactly the same place in every image.
Used after convolution: Typically, pooling is applied after convolution layers to further distill the detected features.</p>
<p>Summary (No Steps Skipped)</p>
<p>A pooling layer reduces the size of an image or feature map by summarizing local regions (blocks).
Max pooling keeps the largest value in each block.
This makes the data smaller, more manageable, and helps the network focus on the most important features, with some tolerance for small shifts or changes in position.
The process is repeated for every block, creating a new, smaller summary image or feature map.</p>
</div>
<div id="architecture-of-a-convolution-neural-network" class="section level5 hasAnchor" number="5.2.11.3.3">
<h5><span class="header-section-number">5.2.11.3.3</span> Architecture of a convolution neural network<a href="statistical-inference.html#architecture-of-a-convolution-neural-network" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>What is a Convolutional Neural Network (CNN)?
A convolutional neural network (CNN) is a type of machine learning model that is especially good at recognizing patterns in images. For example, it could look at a picture and recognize if it is a cat, a dog, or a car.</p>
<p>The Structure of a CNN
1. Input Layer</p>
<p>This is where the image goes into the network.
Images are made up of pixels, and in color images, each pixel has three numbers (one for red, one for green, one for blue).
For a standard color image, think of it as a 3D block: height × width × number of colors (channels).</p>
<p>For example, a 32 × 32 color image has shape 32 (height) × 32 (width) × 3 (channels).</p>
<ol start="2" style="list-style-type: decimal">
<li>Convolution Layer</li>
</ol>
<p>This is the main building block of a CNN.
Imagine a small window (called a filter or kernel) sliding over the image and looking at a few pixels at a time.
Each filter looks for a specific pattern, like edges or textures.
The result of applying one filter is a new 2D image called a “feature map.” If you use several filters, you get several feature maps, stacked together as a 3D block.</p>
<p>Example:</p>
<p>If you have 6 filters and each filter scans a 32 × 32 image, you get 6 new 32 × 32 images (feature maps).
The number of filters = number of output “channels.”</p>
<p>Analogy:</p>
<p>Filters in CNNs are like different colored glasses, each highlighting a different feature in the image.</p>
<ol start="3" style="list-style-type: decimal">
<li>Pooling Layer</li>
</ol>
<p>This layer reduces the size of the feature maps, making the network faster and helping it focus on the most important information.
The most common pooling method is “max-pooling,” which keeps the largest number in each small region.
For example, a 2 × 2 max-pool looks at every 2 × 2 block and only keeps the biggest number from each block.
This reduces the height and width by half (so a 32 × 32 feature map becomes 16 × 16 after 2 × 2 pooling).</p>
<p>Why Pooling?</p>
<p>It makes the network smaller and more efficient.
It helps the network be less sensitive to small changes in the image (like if an object moves a little).</p>
<ol start="4" style="list-style-type: decimal">
<li>Repeating Layers</li>
</ol>
<p>It’s common to repeat convolution and pooling layers several times.
After each pooling, the image gets smaller, but we often use more filters to capture more complex patterns.</p>
<ol start="5" style="list-style-type: decimal">
<li>Flattening</li>
</ol>
<p>After several convolution and pooling layers, the 3D block of numbers (feature maps) is flattened into a long list.
This step is like unrolling the block into a single row.</p>
<ol start="6" style="list-style-type: decimal">
<li>Fully Connected Layer</li>
</ol>
<p>This layer works like a traditional neural network.
Each number from the flattened list connects to every “neuron” in this layer.
The last fully connected layer outputs one number for each class (for example, 100 numbers if there are 100 categories to choose from).</p>
<ol start="7" style="list-style-type: decimal">
<li>Output Layer and Softmax</li>
</ol>
<p>The final layer uses a function called “softmax” to turn the output numbers into probabilities.
For example, if there are 100 categories, the softmax function makes sure the output numbers add up to 1 and represent the likelihood of the image being in each category.</p>
<p>Formula for Softmax:
If the last layer gives numbers <span class="math inline">\(z_1, z_2, ..., z_{100}\)</span>, the softmax probability for class <span class="math inline">\(j\)</span> is:</p>
<p><span class="math display">\[
\text{softmax}(z_j) = \frac{e^{z_j}}{\sum_{k=1}^{100} e^{z_k}}
\]</span></p>
<ul>
<li><span class="math inline">\(e\)</span> is a mathematical constant (about 2.718).</li>
<li>This formula makes the biggest <span class="math inline">\(z_j\)</span> turn into the highest probability.</li>
</ul>
<p>Data Augmentation</p>
<p>Sometimes, to help the network learn better, we make small changes to the training images (like rotating, shifting, or adding blur).
This creates new, slightly different images from the original ones but keeps the same label.
It helps the network not get fooled by small changes and “regularizes” the learning, making it perform better on new images.</p>
<p>Common Scenario Generalized
Imagine you want a computer to tell if a photo is of a dog or a cat. You use a CNN:</p>
<p>The image goes in.
The network uses filters to scan for features (like fur, ears, noses).
After several steps of reducing and combining features, the network makes a guess—dog or cat.</p>
<p>This is the same process, regardless of whether you are classifying animals, vehicles, or any other objects in pictures.</p>
</div>
<div id="data-augmentation" class="section level5 hasAnchor" number="5.2.11.3.4">
<h5><span class="header-section-number">5.2.11.3.4</span> Data Augmentation<a href="statistical-inference.html#data-augmentation" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>What is Data Augmentation?</p>
<p>Data augmentation is a powerful trick used when training computer models to recognize images.
The idea is simple: you take each original training image and create many new, slightly altered versions of it.
These changes are made in such a way that a human would still recognize the object in the image, but the computer now has more examples to learn from.</p>
<p>Why Do We Augment Data?</p>
<p>The goal is to increase the variety of images available for training, without needing to actually collect more real-world data.
This helps the model learn to recognize objects even if they look a bit different, which is important because objects in real life can appear in many ways (different positions, lighting, or sizes).</p>
<p>How is it Done?</p>
<p>Distortions (changes) commonly used include:</p>
<p>Zoom: Making the object appear closer or farther.
Shift: Moving the image left, right, up, or down.
Shear: Skewing the image diagonally.
Rotation: Rotating the image by small angles.
Flip: Flipping the image horizontally (like seeing a mirror image).</p>
<p>For example, if you have a picture of a cat, you can create new training images by flipping it, zooming in, or rotating it slightly.</p>
<p>What’s the Benefit?</p>
<p>Prevents Overfitting: If your model only ever sees perfect, unaltered images, it may learn to memorize those exact examples and not generalize to new, unseen images. Augmentation helps the model learn the important features that define an object, not just memorize.
Regularization: In machine learning, regularization is a strategy to prevent overfitting. Data augmentation acts as a kind of regularization by “fattening” the cloud of training data, meaning the model sees many variations of each example, making it more robust.
No Need to Store All Images: Instead of saving all the new, altered images, we can create them “on the fly” (in real time) during training, which saves computer memory.</p>
<p>Analogy</p>
<p>Imagine teaching someone to recognize apples. If you only show them one photo of an apple, they might not recognize an apple from a different angle or with a bite taken out. But if you show them apples of all shapes, sizes, and colors, they’ll be able to recognize any apple in real life.</p>
</div>
<div id="results-using-a-pretrained-classifier" class="section level5 hasAnchor" number="5.2.11.3.5">
<h5><span class="header-section-number">5.2.11.3.5</span> Results Using a Pretrained Classifier<a href="statistical-inference.html#results-using-a-pretrained-classifier" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>What is a Pretrained Classifier?</p>
<p>Instead of training a model from scratch (which takes a lot of time and data), we can use a model that has already been trained on a huge collection of images, such as the “ImageNet” dataset.
This model (like “resnet50”) has learned to recognize thousands of different objects.
We can use this model to classify new images, even ones it’s never seen before.</p>
<p>How Does Classification Work?</p>
<p>When you give the model a new image, it tries to guess what’s in the image by assigning probabilities to different possible categories.
For example, for an image of a flamingo, the model might say:</p>
<p>Flamingo: 83%
Spoonbill: 17%
White stork: 0%</p>
<p>These numbers mean the model is most confident the image is a flamingo, but there’s a chance it could be a spoonbill.</p>
<p>Example Table Explanation
The following table is an example of how a classifier might output its guesses:</p>
<p>TSV_TABLE{“value”:“Image Label”} {“value”:“Model’s Top Guess (probability)”} {“value”:“Second Guess (probability)”} {“value”:“Third Guess (probability)”}
{“value”:“flamingo”} {“value”:“flamingo (0.83)”} {“value”:“spoonbill (0.17)”} {“value”:“white stork (0.00)”}
{“value”:“hawk”} {“value”:“kite (0.60)”} {“value”:“great grey owl (0.09)”} {“value”:“robin (0.06)”}
{“value”:“hawk (zoomed out)”} {“value”:“fountain (0.35)”} {“value”:“nail (0.12)”} {“value”:“hook (0.07)”}
{“value”:“dog”} {“value”:“Tibetan terrier (0.56)”} {“value”:“Lhasa (0.32)”} {“value”:“cocker spaniel (0.03)”}
{“value”:“cat”} {“value”:“Old English sheepdog (0.82)”} {“value”:“Shih-Tzu (0.04)”} {“value”:“Persian cat (0.04)”}
{“value”:“Cape weaver”} {“value”:“jacamar (0.28)”} {“value”:“macaw (0.12)”} {“value”:“robin (0.12)”}
END_TSV_TABLE</p>
<p>The model gives its best guesses for each image. Sometimes it gets confused, especially if the image is unusual (like zoomed out or a rare viewpoint).</p>
<p>Why Use Pretrained Models?</p>
<p>Efficiency: They save a huge amount of time and resources, since training from scratch on millions of images is expensive.
Transfer Learning: You can use the knowledge from a pretrained model for new tasks. For example, you can use the early layers (which have learned basic shapes and textures) and only retrain the final layers for your specific problem. This process is called weight freezing: you “freeze” (don’t change) the early layer weights, and only update the last layers during training on your smaller dataset.</p>
<p>Analogy</p>
<p>Think of a pretrained model like a student who has already studied a lot of subjects. If you want them to specialize in one new subject, you don’t need to teach them everything from the beginning—just the extra details for that subject.</p>
<p>Step-by-Step General Scenario (No Specific Values Needed)</p>
<p>Start with a set of labeled images (cats, dogs, birds, etc.).
Apply data augmentation to multiply your training images by creating altered versions (rotations, flips, zooms, shifts).
Train a CNN (or use a pretrained one) to learn to recognize patterns in these images.
For new images, the model predicts the probability for each possible label (for example, “dog: 70%, cat: 25%, rabbit: 5%”).
If using a pretrained model, you can “freeze” most of the layers (don’t update them) and only train the last few layers on your own data.
The output can be used for many purposes (classifying photos, detecting objects, etc.).</p>
<p>Key Terms and Concepts Explained</p>
<p>Data Augmentation: Creating new training examples by altering existing ones.
Overfitting: When a model memorizes the training data instead of learning to generalize.
Regularization: Techniques to prevent overfitting. Data augmentation is one type.
Pretrained Classifier: A model trained on a huge, diverse dataset, ready to be reused for new tasks.
Weight Freezing: Keeping the early layers of a model unchanged and only training the last layers on new data.
Probability Output: The model’s confidence in each possible label for a given image.</p>
</div>
</div>
<div id="document-classification" class="section level4 hasAnchor" number="5.2.11.4">
<h4><span class="header-section-number">5.2.11.4</span> Document Classification<a href="statistical-inference.html#document-classification" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>What Is Document Classification?
Document classification is a process where we train a computer to look at a piece of text (like a review, email, tweet, or news article) and decide what kind of document it is or what it’s about. For example, the computer could figure out whether a review is positive or negative (sentiment analysis), or what topic a news article is about.
Example Scenario (Generalized)
Imagine you have lots of customer reviews for a product. You want a program to automatically decide if each review is positive (“I love this!”) or negative (“I hate this!”), instead of reading them all yourself.</p>
<p>The Challenge With Text</p>
<p>Text is messy: People use different words, slang, make spelling mistakes, or write reviews of different lengths.
We need to turn text into numbers: Computers work with numbers, so we need a way to convert words into a format a computer can understand and use to make predictions.</p>
<p>Featurization: Turning Text into Numbers
Featurize means to create a set of “features” (predictors) from the text. Think of features as ingredients in a recipe: each ingredient has a quantity, and the combination determines the final dish (or, for us, the classification).
The Bag-of-Words Model
This is the most basic and common way to featurize text:</p>
<p>Dictionary: Make a list of the most common words in your collection of documents (like the top 10,000 words).
Feature Vector: For each document, make a list that is as long as the number of words in the dictionary.</p>
<p>Each position in the list represents a word.
If the word is present in the document, put a 1 in that position; if it’s not, put a 0.</p>
<p>Binary Vector: Because we only care about presence/absence (1 or 0), this is called a binary feature vector.</p>
<p>Example (No Real Values)
Suppose your dictionary is [“dog”, “cat”, “happy”, “sad”]. For the review “I am happy with my dog”, your feature vector would look like:</p>
<p>“dog”: 1 (present)
“cat”: 0 (not present)
“happy”: 1 (present)
“sad”: 0 (not present)</p>
<p>So, your document becomes [1, 0, 1, 0].</p>
<p>Dealing With Document Length</p>
<p>Reviews can be short or long. By using the bag-of-words, every document gets a vector of the same length (equal to the dictionary size), regardless of how many words are in the review.
Sometimes, very rare words or words not in the dictionary are marked as “unknown” (UNK).</p>
<p>The Feature Matrix (Big Table of Numbers)</p>
<p>If you have 25,000 reviews and use the top 10,000 words in your dictionary, you get a big table (called a “matrix”) with 25,000 rows (one for each review) and 10,000 columns (one for each word).
Each entry is 1 if the word is in that review, or 0 if it isn’t.
Sparse Matrix: Most entries are 0, because most reviews use only a small number of words from the dictionary. This makes the matrix “sparse,” and there are special ways to store it efficiently.</p>
<p>What Models Are Used?
Two main types of models are mentioned:</p>
<p>Lasso Logistic Regression</p>
<p>A mathematical model for predicting if something is in one category or another (for example, positive or negative).
Uses a technique called “regularization” to avoid overfitting (memorizing the training data rather than learning general rules).
In the plot, the x-axis shows <span class="math inline">\(-\log(\lambda)\)</span>, which is related to how much regularization is used. A higher <span class="math inline">\(\lambda\)</span> means more regularization.
Neural Network (Two Hidden Layers)</p>
<p>A model inspired by the brain, with layers of “neurons” that learn to recognize patterns in the data.
The x-axis in the neural network plot shows “epochs,” which are the number of times the model has seen all the training data.</p>
<p>Both types of models try to find patterns between the presence or absence of words and the sentiment (positive or negative) of the review.</p>
<p>Accuracy and Overfitting</p>
<p>Accuracy: The fraction of documents the model correctly classifies.
Overfitting: When a model does very well on the training data but not on new, unseen data.
Both models in the example achieve about 88% accuracy on test data, even though their training accuracy (how well they fit known data) can be higher.</p>
<p>Mathematical Formulas Explained
Logistic Regression for Two Classes
The formula given is:</p>
<p><span class="math display">\[
\log \left(\frac{\operatorname{Pr}(Y=1 \mid X)}{\operatorname{Pr}(Y=0 \mid X)}\right) = Z_{1} - Z_{0}
\]</span></p>
<ul>
<li>This formula calculates the “log-odds” of the document being in class 1 (for example, positive) versus class 0 (negative).</li>
<li><span class="math inline">\(\operatorname{Pr}(Y=1 \mid X)\)</span> means the probability that the sentiment is positive, given the features <span class="math inline">\(X\)</span> (the presence/absence of words).</li>
<li><span class="math inline">\(Z_1\)</span> and <span class="math inline">\(Z_0\)</span> are scores the model calculates for each class.</li>
<li>The bigger <span class="math inline">\(Z_1\)</span> compared to <span class="math inline">\(Z_0\)</span>, the more likely the document is positive.</li>
</ul>
<p>Expanded, it becomes:
<span class="math display">\[
= (\beta_{10} - \beta_{00}) + \sum_{\ell=1}^{K_2} (\beta_{1\ell} - \beta_{0\ell}) A_{\ell}^{(2)}
\]</span>
Here, <span class="math inline">\(\beta_{10}\)</span> and <span class="math inline">\(\beta_{00}\)</span> are coefficients (numbers the model learns).
The sum adds up contributions from each “hidden” feature the model finds.</p>
<p>Limitations of the Bag-of-Words Model</p>
<p>Ignores context: It only cares whether a word is present, not what words are next to it.</p>
<p>Bag-of-n-grams: To add some context, we can count pairs (2-grams), triples (3-grams), etc., of words that appear together.</p>
<p>Example: “not good” (negative) is different from “good” (positive).</p>
<p>Sequence models: More advanced models look at the order of all words, not just which words are present.</p>
<p>TSV_TABLE{“value”:“Concept”} {“value”:“Simple Explanation”} {“value”:“Why It Matters”}
{“value”:“Bag-of-Words”} {“value”:“Turn each document into a list of 1s and 0s for each word”} {“value”:“Lets the computer handle text as numbers”}
{“value”:“Sparse Matrix”} {“value”:“Most entries are 0, only a few are 1”} {“value”:“Efficient to store and process”}
{“value”:“Lasso Logistic Regression”} {“value”:“A model that predicts categories and avoids overfitting”} {“value”:“Finds the most important words”}
{“value”:“Neural Network”} {“value”:“Model inspired by the brain, with layers that find patterns”} {“value”:“Can learn complex relationships”}
{“value”:“n-grams”} {“value”:“Pairs or groups of words that appear together”} {“value”:“Adds some context to the analysis”}
END_TSV_TABLE</p>
<p>General Scenario (No Specific Values)</p>
<p>Gather a set of documents (like reviews), each labeled by their type or sentiment.
Build a dictionary of common words (or word pairs).
For each document, record whether each word (or word pair) in the dictionary is present.
Organize the data in a big table (matrix), where each row is a document, and each column is a word.
Train a model (such as logistic regression or a neural network) on this data.
Use the model to predict the label of new documents, based on which words they contain.</p>
<div id="reccurent-neural-networks" class="section level5 hasAnchor" number="5.2.11.4.1">
<h5><span class="header-section-number">5.2.11.4.1</span> Reccurent Neural networks<a href="statistical-inference.html#reccurent-neural-networks" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>What Are Recurrent Neural Networks (RNNs)?
Key Idea</p>
<p>Many types of data are sequential: the order of the data matters.
RNNs are a type of neural network designed specifically to work with sequential data.</p>
<p>Why Does Sequence Matter?
Think of things like:</p>
<p>Sentences or reviews: The meaning depends on the order of words.
Weather data: Today’s temperature depends on previous days.
Stock prices: Tomorrow’s price is related to past prices.
Speech/music/handwriting: Each sound or letter depends on what came before.</p>
<p>Examples of Sequential Data</p>
<p>Text: Reviews, articles, tweets—RNNs can help figure out the sentiment or meaning by looking at the order of words.
Weather/time series: Predicting future weather using past measurements.
Finance: Predicting future stock prices from past prices.
Audio: Recognizing speech or music by analyzing sequences of sounds.
Handwriting: Turning handwritten digits or words into digital text (optical character recognition).</p>
<p>How Does an RNN Work?
The Structure</p>
<p>The input is a sequence: <span class="math inline">\(X = \{X_1, X_2, ..., X_L\}\)</span>
- Each <span class="math inline">\(X_\ell\)</span> is a part of the sequence (e.g., a word, a time step).
The RNN processes each item in the sequence one at a time, in order.
At each step, it keeps track of what it has seen so far (its “memory”).</p>
<p>Schematic</p>
<p>At each time step <span class="math inline">\(\ell\)</span>, the RNN:</p>
<p>Takes the current input <span class="math inline">\(X_\ell\)</span>.
Combines it with its previous “memory” or activation <span class="math inline">\(A_{\ell-1}\)</span>.
Produces a new activation <span class="math inline">\(A_\ell\)</span>.
Optionally, outputs a prediction <span class="math inline">\(O_\ell\)</span>.</p>
<p>Usually, only the final output <span class="math inline">\(O_L\)</span> is used (e.g., overall sentiment for a review).
Diagram Explanation</p>
<p>The left side of the diagram is a compact way to show the entire network.
The right side “unrolls” the network to show what happens at each step.</p>
<p>Mathematical Details
Representing the Sequence</p>
<p>Each input <span class="math inline">\(X_\ell\)</span> can be a vector, such as a “one-hot” encoding (a way to represent words using 0s and a single 1).
The sequence is processed one step at a time: <span class="math inline">\(X_1\)</span>, then <span class="math inline">\(X_2\)</span>, etc.</p>
<p>The Hidden Layer (Activations)
At each time step <span class="math inline">\(\ell\)</span>, the RNN computes a new activation value for each hidden unit in the network:
<span class="math display">\[
A_{\ell k} = g \left( w_{k0} + \sum_{j=1}^{p} w_{kj} X_{\ell j} + \sum_{s=1}^{K} u_{ks} A_{\ell-1,s} \right)
\]</span>
Let’s break this down:</p>
<ul>
<li><span class="math inline">\(k\)</span> indexes the hidden units (there are <span class="math inline">\(K\)</span> of them).</li>
<li><span class="math inline">\(w_{kj}\)</span>: weights connecting the input <span class="math inline">\(X_{\ell}\)</span> (with <span class="math inline">\(p\)</span> features) to the hidden unit.</li>
<li><span class="math inline">\(u_{ks}\)</span>: weights connecting the previous hidden activations to the current ones.</li>
<li><span class="math inline">\(g(\cdot)\)</span>: activation function, like ReLU, which adds non-linearity (makes the network more powerful).</li>
<li><span class="math inline">\(w_{k0}\)</span>: bias term (extra number added in).</li>
<li><span class="math inline">\(X_{\ell j}\)</span>: the jth component of the input at step <span class="math inline">\(\ell\)</span>.
<span class="math inline">\(A_{\ell-1, s}\)</span>: the sth hidden activation at the previous step.</li>
</ul>
<p>Big picture: Each hidden activation at step <span class="math inline">\(\ell\)</span> combines information from the current input and the hidden activations from the previous step.
The Output
At each step, you can compute an output:
<span class="math display">\[
O_{\ell} = \beta_0 + \sum_{k=1}^{K} \beta_k A_{\ell k}
\]</span></p>
<ul>
<li><span class="math inline">\(\beta_0\)</span>: output bias term.</li>
<li><span class="math inline">\(\beta_k\)</span>: weights for each hidden activation.</li>
</ul>
<p>Usually, only the final output <span class="math inline">\(O_L\)</span> (after the last element in the sequence) is used for prediction.
Weight Sharing</p>
<p>The same weights (<span class="math inline">\(\mathbf{W}, \mathbf{U}, \mathbf{B}\)</span>) are used at every step. This is called weight sharing.
This allows the RNN to process sequences of any length, reusing what it has learned at each step.</p>
<p>Training the RNN</p>
<p>The goal is to adjust the weights (<span class="math inline">\(\mathbf{W}, \mathbf{U}, \mathbf{B}\)</span>) to minimize the difference between the predictions and the actual values.
For regression (predicting numbers), the loss for a single example is:
<span class="math display">\[
(Y - O_L)^2
\]</span></p>
<p>where <span class="math inline">\(Y\)</span> is the true value, and <span class="math inline">\(O_L\)</span> is the prediction at the end of the sequence.</p>
<p>For a dataset with n examples, the total loss is:</p>
<p><span class="math display">\[
\sum_{i=1}^{n} (y_i - o_{iL})^2
\]</span></p>
<p>where <span class="math inline">\(y_i\)</span> is the true value for the ith sequence, and <span class="math inline">\(o_{iL}\)</span> is its predicted value.
Why Use RNNs?</p>
<p>RNNs remember what has happened before in a sequence, which helps them make better predictions about what comes next or the overall meaning.
They are suited to tasks where order and context are crucial (unlike models that treat each data point independently).</p>
<p>When Are Intermediate Outputs Used?</p>
<p>Sometimes, you want an output at every step (for example, translating each word in a sentence to another language).
Other times, only the final output is needed (like predicting if a review is positive or negative after reading the whole thing).</p>
<p>Generalized Scenario</p>
<p>You have a dataset where the order of items matters (e.g., words in a review, daily temperatures, notes in music).
You represent each item in the sequence as a vector (for example, a “one-hot” vector for a word).
An RNN processes each item in order, updating its “memory” at each step.
At the end, the RNN uses all the information it has seen to make a prediction (or, if needed, makes predictions at each step).
The RNN is trained by adjusting its weights to make its predictions as close as possible to the correct answers, over many examples.</p>
<div id="sequential-models-for-document-classification" class="section level6 hasAnchor" number="5.2.11.4.1.1">
<h6><span class="header-section-number">5.2.11.4.1.1</span> Sequential Models for Document Classification<a href="statistical-inference.html#sequential-models-for-document-classification" class="anchor-section" aria-label="Anchor link to header"></a></h6>
<p>Sequential Models for Document Classification: The Big Idea
We want a computer to read a document (like a movie review) and predict something about it (like whether it’s positive or negative). The earlier approach, the bag-of-words, ignored word order. Now, we want to use the actual sequence of words as they appear to make our prediction.</p>
<p>The Dimensionality Challenge: Why Not Just Use One-Hot Vectors?
One-hot encoding is a way to represent each word as a long list (vector) of 0s and a single 1. For example, if your dictionary contains 10,000 words, the word “cat” might be represented by a vector where the 4,512th entry is 1, and the rest are all 0. Every word gets its own spot in this long list.
Problem: This is very inefficient.</p>
<p>Each word is a huge list of mostly zeros.
With a big dictionary, it takes a lot of memory and computation.</p>
<p>Solution: Word Embeddings
Instead of one-hot vectors, we use embeddings to represent each word as a much shorter list of numbers (for example, a list of 50 or 100 numbers instead of 10,000). These numbers capture information about the meaning and usage of the word.
Embedding Space</p>
<p>Every word is mapped to a location in a lower-dimensional space (embedding space).
Similar words (like synonyms) end up close to each other in this space.
Each word’s embedding is a vector of real numbers (not just 0s and 1s), and none are typically zero.</p>
<p>How Embeddings Are Used</p>
<p>We construct a big matrix <span class="math inline">\(\mathbf{E}\)</span>, where each column represents one word in the dictionary, and each row represents one of the embedding dimensions.</p>
<p>The shape of <span class="math inline">\(\mathbf{E}\)</span>: <span class="math inline">\(m \times D\)</span> (where m is the number of embedding dimensions, and <span class="math inline">\(D\)</span> is the dictionary size).
To get the embedding for a word, you look up its column in <span class="math inline">\(\mathbf{E}\)</span>.</p>
<p>Where Do Embeddings Come From?
There are two main ways:</p>
<p>Learned During Training: The neural network learns the best embeddings for your specific task.
Pretrained Embeddings: You use a set of embeddings that were learned from a huge amount of text before, such as word2vec or GloVe. These embeddings can be kept fixed (weight freezing) or further adjusted during your training.</p>
<p>Practical Representation</p>
<p>Now, every document is represented as a sequence of embedding vectors (one for each word in the document).
If documents are of different lengths:</p>
<p>We pick a maximum length <span class="math inline">\(L\)</span>.
Documents shorter than <span class="math inline">\(L\)</span> get padded (filled up) at the beginning with zeros, so all documents have the same length.</p>
<p>Feeding Into an RNN</p>
<p>Each document becomes a sequence of vectors: <span class="math inline">\(X = \{X_1, X_2, ..., X_L\}\)</span>, with each <span class="math inline">\(X_\ell\)</span> an embedding vector.
The RNN reads these vectors one at a time, from the first word to the last.</p>
<p>The RNN Model
Structure</p>
<p>The RNN keeps a “hidden state” or memory as it moves through the sequence.
At each word, it updates its memory based on the current word and what it remembers from the previous words.
After reading the whole document, the RNN uses its final memory to make a prediction (like the sentiment).</p>
<p>Parameters</p>
<p>Embedding matrix E: Each word’s embedding.
Weight matrices <span class="math inline">\(\mathbf{W}, \mathbf{U}, \mathbf{B}\)</span>: Control how the RNN processes the sequence.</p>
<ul>
<li><span class="math inline">\(\mathbf{W}\)</span>: Connects input to hidden layer.</li>
<li><span class="math inline">\(\mathbf{U}\)</span>: Connects previous hidden state to current hidden state.</li>
<li><span class="math inline">\(\mathbf{B}\)</span>: Output layer weights.</li>
</ul>
<p>The number of parameters depends on the embedding size, the number of hidden units, and the dictionary size.</p>
<p>Model Training and Performance</p>
<p>The model is trained to minimize the difference between its predictions and the true labels (using a loss function like squared error or cross-entropy).
More advanced RNNs, like LSTM (Long Short-Term Memory) networks, solve problems with remembering information from earlier in long sequences.
LSTM keeps two types of memory: short-term and long-term, allowing the model to remember important information for longer.</p>
<p>Results and Improvements</p>
<p>Simple RNNs can be outperformed by more advanced models like LSTM.
LSTM can improve accuracy, but they are slower to train.
The best models combine good embeddings, enough hidden units, and proper training.</p>
<p>Generalized Example (No Specific Values)
Suppose you want to classify any sequence where order matters (not just text—could be DNA, actions, etc.).</p>
<p>Build a dictionary of all possible items (words, actions, etc.).
Assign each item an embedding (a short vector of numbers).
For each input sequence, turn it into a list of embedding vectors.
Feed the sequence, one embedding at a time, into an RNN.
The RNN updates its memory each step, then uses its final state to make a prediction.
Train the RNN to minimize error on many labeled examples.</p>
</div>
<div id="time-series-forecasting" class="section level6 hasAnchor" number="5.2.11.4.1.2">
<h6><span class="header-section-number">5.2.11.4.1.2</span> Time Series Forecasting<a href="statistical-inference.html#time-series-forecasting" class="anchor-section" aria-label="Anchor link to header"></a></h6>
<ol style="list-style-type: decimal">
<li><p>What is Time Series Forecasting?
Time series refers to any data collected over time—such as daily stock trading volumes, temperatures over months, or website visits by the hour. The key thing is that the order of the data matters: what happens today depends on what happened yesterday (and maybe days before that).</p></li>
<li><p>Types of Data and Variables
In the example, three types of daily statistics are tracked:</p></li>
</ol>
<p>Trading volume: How much is traded each day, relative to a recent average.
Return: How much a value (like a stock index) changes from one day to the next.
Volatility: How much prices move around, measured day by day.</p>
<p>Each day is represented by a group of these measurements.</p>
<ol start="3" style="list-style-type: decimal">
<li>Why is This Different from Other Problems?
Most data problems assume that each example is independent. In time series, this is not true:</li>
</ol>
<p>Autocorrelation: Values close in time often look similar (for example, trading volume today probably looks a lot like yesterday).
Lag: The effect of a past value on the current value, measured by how many days apart they are.</p>
<p>This means that yesterday’s (or previous days’) values are useful for predicting today’s.</p>
<ol start="4" style="list-style-type: decimal">
<li>How Do We Build the Input for a Model?
To predict the value at a certain time (say, today), we use:</li>
</ol>
<p>The values from the last several days (how many is a parameter you choose, called the lag).
All the types of measurements for each of those days.</p>
<p>Each prediction is based on a mini-sequence: a short stretch of recent days’ data, not the entire series at once.
Generalized Example:
Say you want to predict tomorrow’s temperature. You might use measurements from the last week (temperature, humidity, wind) as your input.</p>
<ol start="5" style="list-style-type: decimal">
<li>How Does the Model Learn?
For every day (after the first few used for the lag), you create a pair:</li>
</ol>
<p>Input: The lagged window of past days’ data.
Target: The value you want to predict (for example, today’s trading volume).</p>
<p>You repeat this for each day in your dataset, creating many input/target pairs for training.</p>
<ol start="6" style="list-style-type: decimal">
<li>RNN Forecaster
An RNN (Recurrent Neural Network) is a model that is designed to learn from sequences—making it ideal for time series.</li>
</ol>
<p>It processes each day’s data in order, keeping a kind of “memory” of what it has seen.
It can use not only the main variable you care about (like trading volume), but also other variables (like return and volatility) from the past.</p>
<p>Structure:</p>
<p>Input: A sequence of vectors (one for each day in the lag window, each containing all the variables for that day).
Output: The predicted value for the next day.</p>
<ol start="7" style="list-style-type: decimal">
<li><p>How Do We Evaluate the Model?
A common way to measure how well the model predicts is the <span class="math inline">\(R^2\)</span> (R-squared) statistic, which measures how much of the variation in the data the model can explain. Higher is better, with 1 being perfect.</p></li>
<li><p>Comparison With Other Models</p></li>
</ol>
<ol style="list-style-type: lower-alpha">
<li>Autoregression (AR)</li>
</ol>
<p>A traditional, simpler method is autoregression: predicting today’s value as a weighted sum of previous days’ values.
The formula for an order-<span class="math inline">\(L\)</span> AR model (using the last L days) is:
<span class="math display">\[
\hat{v}_t = \hat{\beta}_0 + \hat{\beta}_1 v_{t-1} + \hat{\beta}_2 v_{t-2} + \cdots + \hat{\beta}_L v_{t-L}
\]</span></p>
<ul>
<li><span class="math inline">\(\hat{\beta}_0\)</span> is like a baseline, and each <span class="math inline">\(\hat{\beta}_i\)</span> tells how much the value from i days ago matters.
You can also add in lagged versions of other variables (like return or volatility) as extra predictors.</li>
</ul>
<ol start="2" style="list-style-type: lower-alpha">
<li>Feedforward Neural Network</li>
</ol>
<p>Another model is a regular neural network that just takes all the lagged values as a single input vector (“flattening” the sequence), rather than stepping through them in order.
This model can capture more complex (nonlinear) relationships.</p>
<ol start="9" style="list-style-type: decimal">
<li>How Do These Models Compare?</li>
</ol>
<p>All three types—AR, RNN, and feedforward neural network—can perform pretty well on time series forecasting.
The RNN and feedforward neural net can sometimes capture more complex patterns than AR, especially if the relationships are nonlinear.
However, the difference in performance might not be huge for some problems, depending on the data.</p>
<ol start="10" style="list-style-type: decimal">
<li>Improving the Models
Adding Day-of-Week Effects</li>
</ol>
<p>Trading patterns often depend on the day of the week (e.g., more trades on Mondays or Fridays).
You can add a day_of_week variable to the model.</p>
<p>This is done by one-hot encoding: creating a set of binary (0 or 1) variables, one for each possible day.</p>
<p>This extra information helps all models do better, because it gives them a regular pattern to learn from.</p>
<p>Using LSTM (Long Short-Term Memory)</p>
<p>LSTM is a special type of RNN that remembers information for longer periods.
Using LSTM can sometimes lead to small improvements, especially when the effects of past days last a long time.</p>
<ol start="11" style="list-style-type: decimal">
<li>Practical Considerations</li>
</ol>
<p>Picking how many past days (lag length) to use is important. Too few may miss important history; too many may add noise.
All these models need to be carefully trained and evaluated, often using separate data for testing (not used in training) to see if they generalize well.</p>
</div>
<div id="summary-of-rnns" class="section level6 hasAnchor" number="5.2.11.4.1.3">
<h6><span class="header-section-number">5.2.11.4.1.3</span> Summary of RNNs<a href="statistical-inference.html#summary-of-rnns" class="anchor-section" aria-label="Anchor link to header"></a></h6>
<p>Only the Beginning</p>
<p>The examples shown (like document classification and time series) are just the start. RNNs are powerful tools for handling any data where order matters.</p>
<p>There Are Many Advanced Variations of RNNs
1. Convolutional Networks for Sequences</p>
<p>Sometimes, instead of using an RNN, we can use a convolutional neural network (CNN) designed for sequences.
In this approach, the sequence (like a row of word embeddings) is treated like a one-dimensional image.
A convolution filter (a small sliding window) moves along the sequence, looking for important patterns—like phrases or groups of words—regardless of where they appear.
This helps the model learn to recognize specific combinations of words or short sequences that are important for the task.</p>
<p>Analogy:</p>
<p>It’s like scanning a sentence for a particular phrase or structure, no matter where it shows up.</p>
<ol start="2" style="list-style-type: decimal">
<li>Stacking Hidden Layers</li>
</ol>
<p>The simple RNN described earlier had just one hidden layer (one memory being updated at each step).
Stacked RNNs: You can add more hidden layers, creating a deeper network.</p>
<p>The output of one layer (the sequence of activations, <span class="math inline">\(A_\ell\)</span>​) becomes the input to the next hidden layer.</p>
<p>This allows the model to learn more complex and abstract patterns in the sequence.
Analogy:</p>
<p>Think of each layer as a different level of understanding, where each layer builds on what the previous one learned.</p>
<ol start="3" style="list-style-type: decimal">
<li>Bidirectional RNNs</li>
</ol>
<p>In the standard RNN, the sequence is read from start to finish, using only the past to predict the future.
Bidirectional RNNs read the sequence both forwards and backwards.</p>
<p>They can use information from both earlier and later in the sequence to make better predictions.</p>
<p>Example:</p>
<p>Understanding the meaning of a word in a sentence often depends on both the words before and after it.</p>
<ol start="4" style="list-style-type: decimal">
<li>Sequence-to-Sequence (Seq2Seq) Models</li>
</ol>
<p>Sometimes, you want your model to output a sequence, not just a single value.</p>
<p>Example: Translating a sentence from one language to another.</p>
<p>Seq2Seq models use two RNNs:</p>
<p>Encoder: Reads the input sequence and summarizes it into a “hidden state”.
Decoder: Uses this hidden state to generate the output sequence (word by word).</p>
<p>The hidden units in these models are thought to capture the meaning of the whole input sequence, so they can generate meaningful outputs in a different order or language.</p>
<p>Why These Variations Matter</p>
<p>These enhancements let RNNs tackle more complicated problems, like:</p>
<p>Understanding the meaning of a document.
Translating languages.
Summarizing text.
Generating music or captions.</p>
<p>Training and Using RNNs Is Hard — But Software Helps</p>
<p>Training RNNs (finding the best settings for all their internal numbers) involves lots of calculations and can be slow even for powerful computers.
Luckily, modern software (like TensorFlow, PyTorch, Keras) handles most of the complexity for you.
This makes it possible for many people to use these powerful models without being experts in the math or programming behind them.</p>
<p>Everyday Use: Real-World Applications</p>
<p>Many tools you use daily, like Google Translate, use advanced versions of RNNs (and their descendants).
These models are built and trained by teams of experts, using huge amounts of data and computational power.
As a result, you get accurate translations and other language tools, even though the underlying models are incredibly complex.</p>
<p>Generalized Scenario
Imagine you want to solve any problem where the input is a sequence (words, actions, measurements) and the output could be a single result (like sentiment) or another sequence (like a translated sentence). By choosing and combining different RNN variations, you can build a model that:</p>
<p>Learns from the order and context of items.
Understands meaning across the whole sequence.
Can generate outputs that are also sequences, not just single labels.</p>
</div>
</div>
</div>
<div id="when-to-use-deep-learning" class="section level4 hasAnchor" number="5.2.11.5">
<h4><span class="header-section-number">5.2.11.5</span> When to Use Deep Learning<a href="statistical-inference.html#when-to-use-deep-learning" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Deep Learning: Where It Excels
Deep learning (using neural networks with many layers) has been very successful, especially in:</p>
<p>Image recognition (like identifying objects in photos, scanning X-rays, or reading handwriting).
Speech and language tasks (like translating text, generating speech, or summarizing documents).
Time series forecasting (predicting things that change over time, like weather or stock prices).</p>
<p>These successes are often reported in the news and scientific journals.</p>
<p>The Big Question: Should We Always Use Deep Learning?
With all the hype, it’s tempting to think we should use deep learning for every data problem. But the text argues that we shouldn’t discard older, simpler tools just because deep learning is popular.
To explore this, the authors revisit a classic regression problem: predicting the salary of a baseball player based on their past year’s performance.</p>
<p>The Example: Salary Prediction
Here’s the setup, generalized:</p>
<p>Goal: Predict a target value (like salary) using information from the past (performance stats, age, etc.).
Data: Each data point (player) has multiple features (variables).
Split: The data is split into a training set (to build the model) and a test set (to see how well the model works on new data).</p>
<p>Three Types of Models Compared
1. Linear Regression</p>
<p>What is it? A simple model that finds the best straight-line relationship between the input variables and the target.
How many “knobs” (parameters) does it have? One for each variable plus one for the overall level (the intercept).
How does it work? Adds up the variables, each multiplied by a learned weight.</p>
<ol start="2" style="list-style-type: decimal">
<li>Lasso Regression</li>
</ol>
<p>What is it? A linear regression with a twist: it tries to set as many weights as possible to zero, keeping only the most important variables (feature selection).
Why? To avoid overfitting and make the model simpler and easier to interpret.
How is it tuned? Uses cross-validation: tries different levels of “push towards zero” and picks the best one on unseen data.</p>
<ol start="3" style="list-style-type: decimal">
<li>Neural Network</li>
</ol>
<p>What is it? A much more flexible model with many “hidden” units (neurons) and nonlinear transformations (like ReLU, which outputs zero for negative numbers and the input itself for positive numbers).
How many parameters? Can have dozens, hundreds, or thousands of parameters, depending on its size.
How does it work? Each input is sent through layers of calculations, allowing the model to learn complex patterns.</p>
<p>TSV_TABLE{“value”:“Model”} {“value”:“# Parameters”} {“value”:“Mean Absolute Error”} {“value”:“Test Set <span class="math inline">\(R^2\)</span>”}
{“value”:“Linear Regression”} {“value”:“few”} {“value”:“low”} {“value”:“high”}
{“value”:“Lasso”} {“value”:“fewer”} {“value”:“lowest”} {“value”:“still high”}
{“value”:“Neural Network”} {“value”:“many”} {“value”:“slightly higher”} {“value”:“still high”}
END_TSV_TABLE</p>
<p>All three models gave similar performance on the test data.
The simpler models were much easier and faster to fit.
The neural network needed much more tuning and trial-and-error to get reasonable results.</p>
<p>Interpretation and Simplicity</p>
<p>Linear models are easy to understand: you can look at the coefficients and see how much each variable contributes to the prediction.
Lasso regression helps even more by dropping unimportant variables (making the model “sparse”).
Neural networks are often called a “black box” because it’s hard to see what’s going on inside—hard to interpret which inputs matter most.</p>
<p>Occam’s Razor Principle
Occam’s razor says that when you have several ways to do something equally well, you should pick the simplest.</p>
<p>Simpler models are easier to explain, less likely to break if the data changes, and faster to use.</p>
<p>Selection Bias Warning</p>
<p>If you choose your best model by checking which one worked best on your training data, you might fool yourself. Always check the model’s performance on new (test) data that wasn’t used for model selection.</p>
<p>When Deep Learning is Really Useful</p>
<p>Large Datasets: Deep learning shines when you have huge amounts of data (thousands or millions of examples).
Complex Relationships: When the relationship between input and output is very complicated or nonlinear.
Interpretability Not Needed: If you don’t care about being able to explain exactly how the model works.</p>
<p>Practical Recommendations</p>
<p>Try the simple models first. If they work just as well, use them—they’re easier to explain, faster, and less likely to break.
Use deep learning when:</p>
<p>You have lots of data.
The problem is very complex (like image or speech recognition).
You don’t need to explain every prediction.</p>
<p>Always compare performance and complexity. Only use more complex models if they really give better results.</p>
<p>TSV_TABLE{“value”:“Concept”} {“value”:“Explanation”} {“value”:“Why It Matters”}
{“value”:“Linear regression”} {“value”:“Fits a straight-line relationship between variables and target”} {“value”:“Simple, interpretable, quick to fit”}
{“value”:“Lasso”} {“value”:“Linear regression with variable selection”} {“value”:“Simplifies the model, avoids overfitting”}
{“value”:“Neural Network”} {“value”:“Flexible, can capture complex relationships”} {“value”:“Needs more data, harder to interpret, more complex”}
{“value”:“Occam’s razor”} {“value”:“Prefer the simplest model that works”} {“value”:“Reduces risk of overfitting, easier to explain”}
{“value”:“Selection bias”} {“value”:“Picking a model based on the same data used for fitting”} {“value”:“Can give overly optimistic results”}
END_TSV_TABLE</p>
<p>Generalized Scenario
Whenever you need to predict an outcome (like price, score, or risk) from a set of features:</p>
<p>Start simple: Try linear or lasso models.
Compare performance: If a simple model works well, use it.
Try more complex models if needed: If the simple models aren’t good enough and you have lots of data, try a neural network or other advanced tool.
Balance accuracy, simplicity, and interpretability: Pick the model that gives the best tradeoff for your needs.</p>
</div>
<div id="fitting-a-neural-network" class="section level4 hasAnchor" number="5.2.11.6">
<h4><span class="header-section-number">5.2.11.6</span> Fitting a Neural Network<a href="statistical-inference.html#fitting-a-neural-network" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>What Does “Fitting a Neural Network” Mean?</p>
<p>Neural network: A model inspired by the brain, made up of layers of “neurons” (units) connected by “weights” (parameters).
Fitting: Adjusting the parameters (weights and biases) so the neural network does a good job predicting the correct output (target) for each input in your data.</p>
<p>The Structure of a Simple Neural Network
Suppose you have:</p>
<p>Inputs: Several features for each data point (could be measurements, scores, etc.).
Hidden layer: A group of units, each doing a calculation based on the inputs.
Output: The final prediction from the network.</p>
<p>The Parameters
Weights (<span class="math inline">\(w_{kj}\)</span>): Numbers that control how much each input influences each unit in the hidden layer.
Biases (<span class="math inline">\(w_{k0}\)</span>, <span class="math inline">\(\beta_0\)</span>): Extra numbers added to each unit’s calculation, giving the model more flexibility.
Output weights (<span class="math inline">\(\beta_k\)</span>): Each hidden unit’s output is multiplied by a weight before being added up for the final prediction.</p>
<p>The Prediction Formula
The neural network makes a prediction for each input <span class="math inline">\(x_i\)</span> using:
<span class="math display">\[
f(x_i) = \beta_0 + \sum_{k=1}^K \beta_k \, g\left(w_{k0} + \sum_{j=1}^p w_{kj} x_{ij}\right)
\]</span></p>
<p>Let’s break this down:</p>
<ul>
<li><span class="math inline">\(x_{ij}\)</span>: The <span class="math inline">\(j\)</span>-th feature of the <span class="math inline">\(i\)</span>-th data point.</li>
<li><span class="math inline">\(p\)</span>: The number of input features.</li>
<li><span class="math inline">\(K\)</span>: The number of hidden units.</li>
<li><span class="math inline">\(g(\cdot)\)</span>: An activation function (like ReLU or sigmoid), which adds nonlinearity.</li>
<li><span class="math inline">\(\sum_{j=1}^p w_{kj} x_{ij}\)</span>: Weighted sum of inputs for the k-th hidden unit.</li>
<li><span class="math inline">\(w_{k0}\)</span>: Bias for the <span class="math inline">\(k\)</span>-th hidden unit.</li>
<li><span class="math inline">\(\beta_k\)</span>: How much the k-th hidden unit’s output contributes to the final prediction.</li>
<li><span class="math inline">\(\beta_0\)</span>: Final bias added to the prediction.</li>
</ul>
<p>General scenario:
Think of each hidden unit as a “mini-expert” looking at all the inputs and producing a signal. The network combines all these mini-experts’ signals to make its final prediction.</p>
<p>The Training Objective: Minimizing Error
We want our predictions to be as close as possible to the real values for all data points. We measure this with the mean squared error (MSE):</p>
<p><span class="math display">\[
\frac{1}{2} \sum_{i=1}^{n}(y_i - f(x_i))^2
\]</span></p>
<ul>
<li><span class="math inline">\(y_i\)</span>: The true answer for data point i.</li>
<li><span class="math inline">\(f(x_i)\)</span>: The neural network’s prediction for i.</li>
<li><span class="math inline">\(n\)</span>: Number of data points.</li>
</ul>
<p>The goal is to find the values of all the weights and biases that make this error as small as possible.</p>
<p>Why Is Fitting Hard?</p>
<p>The error function can have many hills and valleys (it is “non-convex”), so there can be many possible “best” (minimum) points.</p>
<p>Local minimum: A point that is lower than all nearby points, but not necessarily the lowest possible.
Global minimum: The lowest point overall.</p>
<p>Neural networks have many parameters, making the landscape even more complicated.
The solution you find depends on where you start (your initial guess for the parameters).</p>
<p>How Is Fitting Done? Gradient Descent
The Gradient Descent Algorithm</p>
<p>Start with an initial guess for all weights and biases (collectively called θ0).
Calculate the error (how far off the predictions are from the actual answers).
Change the parameters a tiny bit in the direction that makes the error go down (this is “going downhill”).
Repeat steps 2–3 until you can’t reduce the error any more or you detect overfitting.</p>
<p>In math:</p>
<p><span class="math display">\[
R(\theta) = \frac{1}{2} \sum_{i=1}^{n} (y_i - f_\theta(x_i))^2
\]</span></p>
<p>At each step, update θ to a new value that lowers <span class="math inline">\(R(\theta)\)</span>.</p>
<p>Visual analogy:
Imagine you’re on a hilly landscape (the error surface). Gradient descent is like walking downhill, always taking the steepest step down, until you reach a valley (minimum error).</p>
<p>Challenges: Local vs. Global Minimum</p>
<p>Sometimes you might get stuck in a “local minimum” (a valley that’s not the lowest possible).
If you’re lucky (or have a good starting point), you reach the “global minimum” (lowest valley).</p>
<p>Strategies to Make Fitting Work Better</p>
<p>Slow Learning:</p>
<p>Take small steps (small changes to parameter values) to avoid skipping over the lowest points.
Stop the process before the model starts fitting the noise in the data (overfitting).</p>
<p>Regularization:</p>
<p>Add a penalty to the error for having large weights or too many nonzero weights.
Two common types:</p>
<p>Lasso regularization: Pushes some weights to zero (simplifies the model).
Ridge regularization: Penalizes large weights (keeps them small).</p>
<p>Step-by-Step: Gradient Descent for Neural Networks</p>
<p>Initialize parameters:
Start with random values for all weights and biases (<span class="math inline">\(\theta^0\)</span>), set <span class="math inline">\(t = 0\)</span>.
Iterate:</p>
<p>Compute the error.
Calculate in which direction a small change will reduce the error the most (<span class="math inline">\(\delta\)</span>).
Update parameters:<span class="math inline">\(\theta^{t+1} = \theta^t + \delta\)</span>.
Repeat until the error doesn’t go down anymore.</p>
<p>Illustration (from Figure 10.17)</p>
<p>The error function <span class="math inline">\(R(\theta)\)</span> can have multiple dips.
Gradient descent will take you from your starting point to the nearest dip.
Sometimes this is the global minimum (the lowest dip), sometimes it’s just a local minimum (not as low as possible).</p>
<div id="backpropagation" class="section level5 hasAnchor" number="5.2.11.6.1">
<h5><span class="header-section-number">5.2.11.6.1</span> Backpropagation<a href="statistical-inference.html#backpropagation" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>The Big Picture: Why Backpropagation?
When training a neural network, our goal is to find the set of parameters (weights and biases, collectively called <span class="math inline">\(\theta\)</span>) that make the model’s predictions as close as possible to the real answers for all examples in the training data. We measure “closeness” using a function called the objective or loss (for example, mean squared error, <span class="math inline">\(R(\theta)\)</span>). The lower this number, the better our model is doing.
But how do we actually adjust the parameters to make this number smaller?</p>
<p>The Gradient: Our Direction Finder</p>
<p>The gradient is a mathematical tool that tells us, at any set of parameter values, which direction will make the objective (error) rise the fastest.
Since we want to reduce the error, we go in the opposite direction of the gradient.</p>
<p>Mathematically:</p>
<p><span class="math display">\[
\nabla R(\theta^m) = \left. \frac{\partial R(\theta)}{\partial \theta} \right|_{\theta = \theta^m}
\]</span></p>
<ul>
<li><span class="math inline">\(\nabla R(\theta^m)\)</span>: The gradient of <span class="math inline">\(R\)</span> at the current guess for parameters <span class="math inline">\(\theta^m\)</span>.</li>
<li>This is a vector: for each parameter in <span class="math inline">\(\theta\)</span>, the gradient tells you how much increasing or decreasing that parameter will change the loss.</li>
</ul>
<p>Updating the Parameters: Gradient Descent
To improve the model, we move from our current parameters <span class="math inline">\(\theta^m\)</span> to new parameters <span class="math inline">\(\theta^{m+1}\)</span> by taking a small step in the direction that most reduces the error:
<span class="math display">\[
\theta^{m+1} \leftarrow \theta^{m} - \rho \nabla R(\theta^m)
\]</span></p>
<ul>
<li><span class="math inline">\(\rho\)</span> (rho): The learning rate—a small number that controls how big a step we take.
If the learning rate is too big, we might “overshoot” the minimum; if it’s too small, learning will take a long time.</li>
</ul>
<p>Why Does This Work?</p>
<p>If you imagine the error function as a landscape of hills and valleys, the gradient always points uphill.
By moving in the opposite direction, you go downhill, reducing the error.
If the gradient is zero (flat), you are at a minimum—hopefully the lowest (global minimum), but possibly just a local dip.</p>
<p>Calculating the Gradient: Chain Rule and Backpropagation
The Chain Rule</p>
<p>The objective function depends on the parameters in a complicated, layered way because of how neural networks are built.
To compute how changing any parameter affects the output, we use the chain rule from calculus, which breaks down the effect into steps, layer by layer.</p>
<p>Example: Calculating Derivatives
Suppose we have:</p>
<p><span class="math display">\[
R_i(\theta) = \frac{1}{2}\left(y_i - \beta_0 - \sum_{k=1}^K \beta_k g(w_{k0} + \sum_{j=1}^p w_{kj} x_{ij})\right)^2
\]</span></p>
<p>We want to know:</p>
<p>How does the loss change if we adjust <span class="math inline">\(\beta_k\)</span> (the output weight)?
How does the loss change if we adjust <span class="math inline">\(w_{kj}\)</span> (a hidden layer weight)?</p>
<ol style="list-style-type: decimal">
<li>With respect to <span class="math inline">\(\beta_k\)</span>:
<span class="math display">\[
\frac{\partial R_i(\theta)}{\partial \beta_k} = -(y_i - f_\theta(x_i)) \cdot g(z_{ik})
\]</span></li>
</ol>
<ul>
<li><span class="math inline">\(y_i - f_\theta(x_i)\)</span>: The residual (difference between true value and predicted value).</li>
<li><span class="math inline">\(g(z_{ik})\)</span>: The output of the k-th hidden unit for input <span class="math inline">\(i\)</span>.</li>
</ul>
<ol start="2" style="list-style-type: decimal">
<li>With respect to <span class="math inline">\(w_{kj}\)</span>:
<span class="math display">\[
\frac{\partial R_i(\theta)}{\partial w_{kj}} = -(y_i - f_\theta(x_i)) \cdot \beta_k \cdot g&#39;(z_{ik}) \cdot x_{ij}
\]</span></li>
</ol>
<p>-<span class="math inline">\(g&#39;(z_{ik})\)</span> : The derivative of the activation function (how sensitive it is at that point).
- <span class="math inline">\(x_{ij}\)</span>: The j-th input for the i-th example.</p>
<p>These formulas show how the “blame” for an error gets distributed backwards through the network, from the output layer to each hidden unit, and then to each input connection.</p>
<p>The Backpropagation Algorithm: What’s Really Happening</p>
<p>Forward pass: Compute the predictions for all examples in the data using current parameter values.
Compute error: Measure how far off each prediction is (the residual).
Backward pass (Backpropagation):</p>
<p>Use the chain rule to pass the residuals backward through the network.
Calculate, for each parameter, how much changing it would have reduced the error.
This tells you the gradient for each parameter.</p>
<p>Update parameters: Take a small step for each parameter in the direction that most reduces the error.</p>
<p>Why Is This Called Backpropagation?</p>
<p>“Backpropagation” means propagating (passing) the error backward through the network, so every parameter gets its share of the blame (and can adjust itself to reduce future errors).</p>
<p>Why Is This Efficient?</p>
<p>Even for large networks, the chain rule lets us efficiently and systematically compute all the gradients with a small number of calculations—much faster than if we tried to do each one from scratch.</p>
<p>Generalized Scenario
Suppose you have any prediction problem (could be images, text, numbers, etc.):</p>
<p>Build a neural network model.
For each batch of training data, use backpropagation to figure out how to adjust each parameter to reduce the errors.
Repeat the process, gradually improving performance.</p>
</div>
<div id="regulaization-and-stochastic-gradient-descent" class="section level5 hasAnchor" number="5.2.11.6.2">
<h5><span class="header-section-number">5.2.11.6.2</span> Regulaization and Stochastic Gradient Descent<a href="statistical-inference.html#regulaization-and-stochastic-gradient-descent" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>Gradient Descent in Practice</p>
<p>Gradient Descent is a process where the neural network slowly adjusts its parameters (weights and biases) to make better predictions.
It does this by repeatedly looking at how much its predictions differ from the correct answers (the error or loss), then nudging the parameters to reduce this error.</p>
<p>But in real life, especially with large datasets and big neural networks, some challenges arise:</p>
<ol style="list-style-type: decimal">
<li>Minibatches and Stochastic Gradient Descent (SGD)</li>
</ol>
<p>When you have a huge amount of data, it’s inefficient to look at every single example for every tiny adjustment to the parameters.
Instead, you can randomly pick a small group of examples (called a minibatch) and use just these to estimate how to update the parameters.
Doing this repeatedly, with new random minibatches each time, is called Stochastic Gradient Descent (SGD).</p>
<p>“Stochastic” means “random”—the updates are based on random samples.
This is now the standard approach for training deep neural networks.</p>
<p>Why use minibatches?</p>
<p>Faster updates: You don’t have to wait to process all your data before making each tiny improvement.
Memory efficient: You only need to load a small part of the data at any time.
Adds a bit of randomness: This can help the model avoid getting stuck in a bad local minimum (a suboptimal solution).</p>
<p>General scenario:
Imagine you have thousands of photos for training an image classifier. Instead of adjusting your model after looking at every photo, you look at a handful (say, 128) at a time, learn from them, then move on to the next handful.</p>
<ol start="2" style="list-style-type: decimal">
<li>Regularization: Preventing Overfitting</li>
</ol>
<p>Overfitting is when a model gets too good at matching the training data, but performs poorly on new, unseen data.
Regularization adds rules or penalties to the learning process so the model doesn’t become too complex or memorize the data.</p>
<p>Types of Regularization
a. Ridge Regularization (L2)</p>
<p>Adds a penalty term to the loss function: <span class="math inline">\(\lambda \sum_j \theta_j^2\)</span>
Encourages the weights to stay small.
<span class="math inline">\(\lambda\)</span> is a tuning parameter that controls how strong the penalty is.</p>
<ol start="2" style="list-style-type: lower-alpha">
<li>Lasso Regularization (L1)</li>
</ol>
<p>Adds a penalty based on the sum of the absolute values of the weights.
Tends to push some weights all the way to zero, making the model simpler and easier to interpret.</p>
<ol start="3" style="list-style-type: lower-alpha">
<li>Dropout</li>
</ol>
<p>Randomly “drops out” (temporarily removes) some neurons during each training step.
Forces the network to not rely too heavily on any single connection, making it more robust.</p>
<p>See Figure 10.19:
On the left, every neuron is always connected.
On the right, some neurons (grey) are ignored in each training round, chosen at random.
d. Early Stopping</p>
<p>While training, watch how well the model does on a separate “validation” set (data not used for training).
If the validation error starts to increase (even as the training error keeps going down), stop training! This means the model is starting to overfit.</p>
<ol start="3" style="list-style-type: decimal">
<li>Training in Epochs</li>
</ol>
<p>Epoch: One full pass over the entire training dataset.
In practice, you do many epochs, checking after each one how well the model is doing on the validation data.</p>
<p>Example:
If you have 48,000 training examples and use minibatches of 128, you’ll do about 375 minibatch updates in one epoch.</p>
<ol start="4" style="list-style-type: decimal">
<li>Putting It All Together: The Loss Function with Regularization
When training with regularization, the objective (loss) function might look like:</li>
</ol>
<p><span class="math display">\[
R(\theta; \lambda) = \text{Loss from predictions} + \lambda \times \text{Penalty on weights}
\]</span></p>
<p>For example, in classification:
<span class="math display">\[
R(\theta ; \lambda) = -\sum_{i=1}^{n} \sum_{m=0}^{9} y_{im} \log(f_m(x_i)) + \lambda \sum_j \theta_j^2
\]</span></p>
<p>The first part measures how well the model predicts the correct class (using log-likelihood).
The second part (multiplied by <span class="math inline">\(\lambda\)</span>) discourages large weights.</p>
<ol start="5" style="list-style-type: decimal">
<li>Why These Tricks Matter</li>
</ol>
<p>Minibatch SGD: Makes learning scalable and efficient for massive datasets.
Regularization (ridge, lasso, dropout, early stopping): Keeps models from becoming overly complex, improving their ability to generalize to new data.
Validation set: Used to decide when to stop training and how to set parameters like <span class="math inline">\(\lambda\)</span>, without “cheating” by looking at the test set.</p>
<p>Generalized Scenario
If you’re training a neural network for any problem (speech recognition, image classification, forecasting, etc.):</p>
<p>Use minibatches to update parameters quickly and efficiently.
Apply regularization techniques (ridge, lasso, dropout, early stopping) to keep the model from overfitting.
Monitor performance on a validation set to decide when to stop and how to tune parameters.
Repeat over multiple epochs to improve the model.</p>
</div>
<div id="dropout-learning" class="section level5 hasAnchor" number="5.2.11.6.3">
<h5><span class="header-section-number">5.2.11.6.3</span> Dropout Learning<a href="statistical-inference.html#dropout-learning" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>What is Dropout?
Dropout is a technique used in training neural networks to help the model generalize better and avoid “overfitting.” Overfitting happens when a model becomes too specialized to the training data and fails to perform well on new, unseen data.</p>
<p>How Does Dropout Work?</p>
<p>When training a neural network, each layer has several “units” (neurons).
In dropout, for each training example (each time you feed data into the network while learning), you randomly turn off (drop out) a certain fraction (ϕ) of these units.
“Turning off” a unit means it does not participate in that round of learning: it acts as if it is not there at all for that training example.</p>
<p>Key Points:</p>
<p>Random selection: The units to drop out are picked at random, and this is done differently for every example during training.
Fraction dropped: If, for example, ϕ=0.5, then half the units in the layer are dropped out at each step.</p>
<p>Why Do We Use Dropout?</p>
<p>Prevents over-specialization: If the same units always work together, they can form “shortcuts”—relying on each other too much and not learning to work alone.
Forces robustness: Because a unit can’t count on others always being there, it has to learn features that are useful on their own.
Regularization: Like other forms of regularization (such as ridge or lasso), dropout helps the network avoid fitting the training data too perfectly, improving its ability to generalize.</p>
<p>What Happens to the Remaining Units?</p>
<p>The units that are not dropped out are still active and contribute to the network’s output.
To make up for the missing units, the outputs of the remaining units are scaled up by a factor of <span class="math inline">\(\frac{1}{1-\phi}\)</span>.
For example, if half the units are dropped out (<span class="math inline">\(\phi = 0.5\)</span>), the surviving units are each doubled in strength for that training step.</p>
<p>How is Dropout Implemented?</p>
<p>In practice, dropout is done by setting the outputs (activations) of the dropped units to zero during the forward pass.
This is done only during training. When making predictions on new data (testing), all units are used, but their outputs are scaled down to account for the training procedure.</p>
<p>Visual Example (Generalized)
Imagine a neural network as a team of people working together on a task:</p>
<p>Normally, everyone is always present.
With dropout, for each new project (training example), you randomly tell some people to stay home.
The people who show up have to work harder (their output is scaled up), and over time, everyone learns to be flexible and not rely too much on any single team member.</p>
<p>Generalized Scenario
If you are training a neural network (for images, text, forecasting, etc.):</p>
<p>For every training example, randomly pick some neurons to ignore (drop out).
The remaining neurons work harder to “cover” for the missing ones (by scaling up their outputs).
This random dropping out happens every time you show the network a new training example.
When you use the model for real predictions, all neurons are used, but their outputs are scaled down appropriately.</p>
</div>
<div id="network-tuning" class="section level5 hasAnchor" number="5.2.11.6.4">
<h5><span class="header-section-number">5.2.11.6.4</span> Network Tuning<a href="statistical-inference.html#network-tuning" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>What is Network Tuning?
Network tuning refers to the process of adjusting various parts of a neural network and its training procedure to get the best possible results. This is also called “hyperparameter tuning,” because most of these settings are not learned by the model itself—they are chosen by the person training the model.</p>
<p>Key Choices in Network Tuning
1. Number of Hidden Layers and Units per Layer</p>
<p>Hidden layers: These are layers between the input and the output. More layers can allow the network to learn more complex patterns.
Units per layer: Each layer contains several units (neurons). More units allow the network to capture more information at each layer.</p>
<p>Modern practice:
It’s now common to use many units per layer, sometimes even hundreds or thousands, because regularization techniques (like dropout or L2/L1 penalties) help prevent the network from becoming too complex and overfitting.</p>
<ol start="2" style="list-style-type: decimal">
<li>Regularization Tuning Parameters</li>
</ol>
<p>Dropout rate (<span class="math inline">\(\phi\)</span>): What fraction of units to randomly drop out during training. Common values are between 0.2 and 0.5, but it depends on the problem.
Lasso (λ, L1 regularization): Controls how strongly to push weights towards exactly zero, which can make the model simpler.
Ridge (λ, L2 regularization): Controls how strongly to keep weights small, which helps prevent the model from becoming overly flexible.</p>
<p>These values can be set differently for each layer to tailor the regularization to different parts of the network.</p>
<ol start="3" style="list-style-type: decimal">
<li>Details of Stochastic Gradient Descent (SGD)</li>
</ol>
<p>Batch size: How many training examples you use to compute each update to the network. Small batch sizes make updates noisier but can help the model escape bad local minima.
Number of epochs: How many times you go through the entire training set. More epochs give the model more opportunities to learn, but too many can lead to overfitting.
Data augmentation: Techniques to artificially expand the training data by creating slightly altered versions (for example, rotating images, adding noise, etc.). This can help the model generalize better.</p>
<p>Why Do These Choices Matter?</p>
<p>Each of these settings can have a big impact on how well the model learns and how well it performs on new, unseen data.
There’s no one-size-fits-all answer—what works best depends on the data and the problem.</p>
<p>The Process of Tuning</p>
<p>Set initial values for all parameters (number of layers, units, regularization, etc.).
Train the network and evaluate its performance on a validation set (data not used for training).
Adjust the parameters (for example, try different dropout rates or batch sizes) and retrain.
Repeat until you find a combination that gives good results without overfitting.</p>
<p>This process often involves a lot of trial and error.</p>
<p>What Happens If You Tune Carelessly?</p>
<p>If you make the network too big and don’t use enough regularization, it will overfit—memorize the training data but fail on new data.
If you make it too small, it won’t have enough capacity to learn the patterns in the data.
If you tune too much based on the validation set, you can even start to overfit to that set!</p>
<p>Example (Generalized Scenario)
Imagine you’re building a neural network to classify images or predict sales:</p>
<p>You can choose to have 2 or 3 hidden layers, with dozens or hundreds of units per layer.
You set a dropout rate (how many neurons to ignore during each training step).
You pick a batch size (how many images/sales to use per update).
You train for a certain number of epochs (passes through the data).
You try different values for these choices, watching to see which combination gives the best performance on unseen data.
If you get great results on training but poor on new data, you increase regularization or decrease network size.
If your results are poor everywhere, you try making the network bigger, training longer, or tweaking the learning rate.</p>
<p>Tuning a neural network is a careful balancing act:</p>
<p>You want it big and powerful enough to learn patterns, but not so big it memorizes everything.
You use regularization, dropout, and careful training practices to keep it under control.
You experiment, measure, and adjust, always checking performance on data the model hasn’t seen before.</p>
</div>
</div>
<div id="interpolation-and-double-descent" class="section level4 hasAnchor" number="5.2.11.7">
<h4><span class="header-section-number">5.2.11.7</span> Interpolation and Double Descent<a href="statistical-inference.html#interpolation-and-double-descent" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<ol style="list-style-type: decimal">
<li>Bias-Variance Trade-off and the Classic “U-shape”
What is the bias-variance trade-off?</li>
</ol>
<p>In machine learning, the bias-variance trade-off is a fundamental concept:</p>
<p>Bias is the error from making strong assumptions in your model (e.g., assuming a straight line when the true relationship is curved).
Variance is the error from a model being too sensitive to small fluctuations in the training data (i.e., it “wiggles” too much).</p>
<p>The best models are usually in the middle: not too simple (high bias, low variance) and not too complex (low bias, high variance).</p>
<p>Visualizing the trade-off:</p>
<p>Imagine plotting model flexibility (how complex the model is) on the x-axis, and error on new data (test error) on the y-axis.
Test error typically forms a U-shape:</p>
<p>Too simple: error is high (left side—high bias).
Just right: error is low (bottom of the U).
Too complex: error goes up again (right side—high variance).</p>
<p>Training error (error on the data used to fit the model) always goes down as flexibility increases—it never goes up.</p>
<ol start="2" style="list-style-type: decimal">
<li>Interpolating the Training Data</li>
</ol>
<p>Interpolation means creating a model that fits the training data perfectly—training error is exactly zero.
Traditionally, this was considered bad, because the model could be just memorizing the training data, leading to very high test error (bad predictions for new data).</p>
<ol start="3" style="list-style-type: decimal">
<li>The Double Descent Phenomenon
What is double descent?</li>
</ol>
<p>Recent research found that in certain cases, making your model even more flexible (even past the point where it can perfectly fit the training data) can sometimes make the test error go down again after a brief spike.
This is called double descent:</p>
<p>The test error curve goes down (left side of the U), then up (the classic rise in the U-shape), then down again (the “second descent”) as the model gets even more complex.</p>
<p>Why is it called “double descent”?</p>
<p>Because the test error first descends, then ascends, then descends again, instead of following a single U-shape.</p>
<ol start="4" style="list-style-type: decimal">
<li>Illustration with a Generalized Example
Suppose you want to predict a value Y based on some input X. Here’s a generalized version of the scenario:
You collect some data: pairs of inputs <span class="math inline">\(X\)</span> and outputs <span class="math inline">\(Y\)</span>.
You fit a model to this data using a method called a spline, which lets you adjust how “wiggly” the curve is (the number of wiggles or “degrees of freedom”).</li>
</ol>
<p>Degrees of freedom (<span class="math inline">\(d\)</span>): How many “knobs” the model has to fit the data—higher d means more wiggles.</p>
<p>Low degrees of freedom (small <span class="math inline">\(d\)</span>): The fitted curve is smooth and may miss some details in the data.
Degrees of freedom equals the number of data points (<span class="math inline">\(d = n\)</span>): The curve fits every data point exactly—zero training error (interpolates the data).
Degrees of freedom greater than number of data points (<span class="math inline">\(d &gt; n\)</span>): There are many ways to fit the data exactly, and the chosen solution is the “smoothest” one according to a mathematical rule (minimum-norm).</p>
<ol start="5" style="list-style-type: decimal">
<li>What Happens to Training and Test Error?</li>
</ol>
<p>Training error: Drops to zero when the model becomes flexible enough to fit all data points (interpolation).
Test error:</p>
<p>Follows a U-shape for low to moderate flexibility.
Spikes up when interpolation is first reached—model becomes extremely “wiggly” and unstable.
Drops again when flexibility is increased even further and a “smooth” solution is chosen from among the many possible fits.</p>
<p>Visual summary from the figures:</p>
<p>With moderate flexibility, the model is not too wiggly and generalizes well.
At the interpolation threshold (model is just flexible enough to memorize the data), the model becomes unstable and test error spikes.
With even more flexibility, the model can interpolate smoothly, and test error can go down again.</p>
<ol start="6" style="list-style-type: decimal">
<li>Why Does This Happen?</li>
</ol>
<p>At the interpolation threshold (model just fits the data), there’s often only one way to fit all points, and it’s usually very wild and unstable.
With even more flexibility, there are many ways to fit the data, so you can pick the smoothest one, which tends to generalize better.</p>
<ol start="7" style="list-style-type: decimal">
<li>Application to Neural Networks and Deep Learning</li>
</ol>
<p>This “double descent” is not just for splines—it can happen in neural networks too.
When neural networks have a huge number of parameters (many layers, many units), they can fit the training data exactly (zero error).
Surprisingly, in some cases, these highly flexible networks still perform very well on new data (test set)—especially in “high signal-to-noise” problems (the pattern in the data is strong and clear).</p>
<ol start="8" style="list-style-type: decimal">
<li>Key Takeaways and Warnings</li>
</ol>
<p>Double descent does not break the classic bias-variance trade-off; it just shows that the relationship between flexibility and error can be more complicated than a simple U-shape.
Most regularized methods do not show double descent: Regularization (like ridge or lasso) prevents the model from interpolating the data, so you don’t see this phenomenon.
Zero training error can sometimes be good (as with “support vector machines” or well-regularized neural networks), but it depends on the details—especially the signal-to-noise ratio.
In practice: It is usually safer and more reliable to use regularization, early stopping, and other techniques to avoid overfitting, rather than relying on double descent.
The shape of the error curve can depend on how you measure “flexibility”. Depending on your choice of x-axis (e.g., number of parameters, basis functions, etc.), the error curve may not always look like a U or double descent.</p>
<ol start="10" style="list-style-type: decimal">
<li>Final Summary</li>
</ol>
<p>The classic wisdom is to avoid models that fit the training data perfectly, because they tend to perform poorly on new data (overfitting).
Double descent shows there are special cases (especially with neural networks and splines) where making the model even more flexible can make test error go down again, provided the model picks a smooth solution among many possible fits.
Regularization, early stopping, and smoothness constraints are better-understood and safer ways to get good test error, and are widely used in practice.
The bias-variance trade-off is still important and should always be kept in mind. Double descent is a fascinating phenomenon, but not a rule to replace the basics of model selection and regularization.</p>
</div>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="setup.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="bayesian-statistics.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
  "sharing": {
    "github": false,
    "facebook": true,
    "twitter": true,
    "linkedin": false,
    "weibo": false,
    "instapaper": false,
    "vk": false,
    "whatsapp": false,
    "all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
  },
  "fontsettings": {
    "theme": "white",
    "family": "sans",
    "size": 2
  },
  "edit": {
    "link": null,
    "text": null
  },
  "history": {
    "link": null,
    "text": null
  },
  "view": {
    "link": null,
    "text": null
  },
  "download": null,
  "search": false,
  "toc": {
    "collapse": "section"
  }
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
